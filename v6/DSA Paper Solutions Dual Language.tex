{[}TOC{]}

\hypertarget{dsa-summer-2024}{%
\subsection{1333203 DSA Summer 2024}\label{dsa-summer-2024}}

\hypertarget{question-1a-define-linear-data-structure-and-give-its-examples.-03-marks}{%
\subsubsection{Question 1(a): Define linear data structure and give its
examples. (03
marks)}\label{question-1a-define-linear-data-structure-and-give-its-examples.-03-marks}}

\textbf{Ans 1(a):} A linear data structure is a type of data
organization where elements are arranged in a sequential manner, with
each element directly linked to its adjacent elements. Key
characteristics of linear data structures include:

\begin{itemize}
\tightlist
\item
  Elements are organized in a linear or sequential order.
\item
  Each element has a unique predecessor and successor, except for the
  first and last elements.
\item
  Data can be traversed in a single run, i.e., in one pass.
\end{itemize}

Examples of linear data structures:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Array}: A collection of elements stored in contiguous memory
  locations.
\item
  \textbf{Linked List}: A sequence of nodes where each node contains
  data and a reference to the next node.
\item
  \textbf{Stack}: Follows Last-In-First-Out (LIFO) principle for element
  access.
\item
  \textbf{Queue}: Follows First-In-First-Out (FIFO) principle for
  element access.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    subgraph Array}
\NormalTok{    A[0] {-}{-}\textgreater{} |10| B[1]}
\NormalTok{    B {-}{-}\textgreater{} |20| C[2]}
\NormalTok{    C {-}{-}\textgreater{} |30| D[3]}
\NormalTok{    D {-}{-}\textgreater{} |40| E[4]}
\NormalTok{    end}

\NormalTok{    subgraph "Linked List"}
\NormalTok{    F["10 | {-}\textgreater{}"] {-}{-}\textgreater{} G["20 | {-}\textgreater{}"]}
\NormalTok{    G {-}{-}\textgreater{} H["30 | {-}\textgreater{}"]}
\NormalTok{    H {-}{-}\textgreater{} I["40 | null"]}
\NormalTok{    end}

\NormalTok{    subgraph Stack}
\NormalTok{    J[Top] {-}{-}\textgreater{} |40| K}
\NormalTok{    K {-}{-}\textgreater{} |30| L}
\NormalTok{    L {-}{-}\textgreater{} |20| M}
\NormalTok{    M {-}{-}\textgreater{} |10| N[Bottom]}
\NormalTok{    end}

\NormalTok{    subgraph Queue}
\NormalTok{    O[Front] {-}{-}\textgreater{} |10| P}
\NormalTok{    P {-}{-}\textgreater{} |20| Q}
\NormalTok{    Q {-}{-}\textgreater{} |30| R}
\NormalTok{    R {-}{-}\textgreater{} |40| S[Rear]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa85-uxab0uxa96uxaaf-uxaa1uxa9f-uxab8uxa9fuxab0uxa95uxa9auxab0-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0-uxa85uxaa8-uxaa4uxaa8-uxa89uxaa6uxab9uxab0uxaa3-uxa86uxaaa.-uxae6uxae9}{%
\subsubsection{પ્રશ્ન 1(અ): રેખીય ડેટા સ્ટ્રક્ચર વ્યાખ્યાયિત કરો અને તેના ઉદાહરણો
આપો.
(૦૩)}\label{uxaaauxab0uxab6uxaa8-1uxa85-uxab0uxa96uxaaf-uxaa1uxa9f-uxab8uxa9fuxab0uxa95uxa9auxab0-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0-uxa85uxaa8-uxaa4uxaa8-uxa89uxaa6uxab9uxab0uxaa3-uxa86uxaaa.-uxae6uxae9}}

\textbf{જવાબ 1(અ):} રેખીય ડેટા સ્ટ્રક્ચર એ ડેટા સંગઠનનો એક પ્રકાર છે જ્યાં elements
ક્રમિક રીતે ગોઠવાયેલા હોય છે, જેમાં દરેક element તેના આજુબાજુના elements સાથે સીધી
રીતે જોડાયેલો હોય છે. રેખીય ડેટા સ્ટ્રક્ચરની મુખ્ય લાક્ષણિકતાઓમાં સામેલ છે:

\begin{itemize}
\tightlist
\item
  Elements રેખીય અથવા ક્રમિક ક્રમમાં ગોઠવાયેલા હોય છે.
\item
  દરેક element ને અનન્ય પૂર્વગામી અને અનુગામી હોય છે, સિવાય કે પ્રથમ અને છેલ્લા
  elements.
\item
  ડેટાને એક જ run માં, એટલે કે એક પાસમાં traverse કરી શકાય છે.
\end{itemize}

રેખીય ડેટા સ્ટ્રક્ચરના ઉદાહરણો:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Array}: સળંગ મેમરી સ્થાનોમાં સંગ્રહિત elements નો સમૂહ.
\item
  \textbf{Linked List}: nodes નો ક્રમ જ્યાં દરેક node માં ડેટા અને આગળના node
  નો સંદર્ભ હોય છે.
\item
  \textbf{Stack}: Element access માટે Last-In-First-Out (LIFO) સિદ્ધાંતને
  અનુસરે છે.
\item
  \textbf{Queue}: Element access માટે First-In-First-Out (FIFO) સિદ્ધાંતને
  અનુસરે છે.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    subgraph Array}
\NormalTok{    A[0] {-}{-}\textgreater{} |10| B[1]}
\NormalTok{    B {-}{-}\textgreater{} |20| C[2]}
\NormalTok{    C {-}{-}\textgreater{} |30| D[3]}
\NormalTok{    D {-}{-}\textgreater{} |40| E[4]}
\NormalTok{    end}

\NormalTok{    subgraph "Linked List"}
\NormalTok{    F["10 | {-}\textgreater{}"] {-}{-}\textgreater{} G["20 | {-}\textgreater{}"]}
\NormalTok{    G {-}{-}\textgreater{} H["30 | {-}\textgreater{}"]}
\NormalTok{    H {-}{-}\textgreater{} I["40 | null"]}
\NormalTok{    end}

\NormalTok{    subgraph Stack}
\NormalTok{    J[Top] {-}{-}\textgreater{} |40| K}
\NormalTok{    K {-}{-}\textgreater{} |30| L}
\NormalTok{    L {-}{-}\textgreater{} |20| M}
\NormalTok{    M {-}{-}\textgreater{} |10| N[Bottom]}
\NormalTok{    end}

\NormalTok{    subgraph Queue}
\NormalTok{    O[Front] {-}{-}\textgreater{} |10| P}
\NormalTok{    P {-}{-}\textgreater{} |20| Q}
\NormalTok{    Q {-}{-}\textgreater{} |30| R}
\NormalTok{    R {-}{-}\textgreater{} |40| S[Rear]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{question-1b-define-time-and-space-complexity.-04-marks}{%
\subsubsection{Question 1(b): Define time and space complexity. (04
marks)}\label{question-1b-define-time-and-space-complexity.-04-marks}}

\textbf{Ans 1(b):} Time and space complexity are crucial concepts in
algorithm analysis that help evaluate the efficiency and resource
requirements of an algorithm.

\textbf{Time Complexity:} Time complexity is a measure of the amount of
time an algorithm takes to complete as a function of the input size. It
represents the number of operations or steps an algorithm performs
relative to the input size.

Key points about time complexity: - Expressed using Big O notation,
e.g., O(n), O(log n), O(n\^{}2) - Focuses on the worst-case scenario -
Helps compare the efficiency of different algorithms - Independent of
hardware or implementation details

Example: An algorithm with O(n) time complexity means its execution time
grows linearly with the input size.

\textbf{Space Complexity:} Space complexity refers to the amount of
memory space an algorithm requires relative to the input size. It
measures how much additional or auxiliary space is needed by the
algorithm to solve a problem.

Key points about space complexity: - Also expressed using Big O notation
- Includes both auxiliary space and space used by the input - Helps
evaluate memory efficiency of algorithms - Important for applications
with limited memory resources

Example: An algorithm with O(1) space complexity uses a constant amount
of extra space regardless of input size.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Complexity Analysis] {-}{-}\textgreater{} B[Time Complexity]}
\NormalTok{    A {-}{-}\textgreater{} C[Space Complexity]}
\NormalTok{    B {-}{-}\textgreater{} D[Measures execution time]}
\NormalTok{    B {-}{-}\textgreater{} E[Uses Big O notation]}
\NormalTok{    C {-}{-}\textgreater{} F[Measures memory usage]}
\NormalTok{    C {-}{-}\textgreater{} G[Includes auxiliary space]}
\NormalTok{    E {-}{-}\textgreater{} H["e.g., O(n), O(log n), O(n\^{}2)"]}
\NormalTok{    G {-}{-}\textgreater{} I["e.g., O(1), O(n), O(n\^{}2)"]}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxaac-uxa9fuxa87uxaae-uxa85uxaa8-uxab8uxaaauxab8-uxa95uxaaeuxaaauxab2uxa95uxab7uxa9f-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}{%
\subsubsection{પ્રશ્ન 1(બ): ટાઇમ અને સ્પેસ કોમ્પ્લેક્ષીટી વ્યાખ્યાયિત કરો.
(૦૪)}\label{uxaaauxab0uxab6uxaa8-1uxaac-uxa9fuxa87uxaae-uxa85uxaa8-uxab8uxaaauxab8-uxa95uxaaeuxaaauxab2uxa95uxab7uxa9f-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}}

\textbf{જવાબ 1(બ):} ટાઇમ અને સ્પેસ કોમ્પ્લેક્ષીટી એ અલ્ગોરિધમ વિશ્લેષણમાં મહત્વપૂર્ણ
ખ્યાલો છે જે અલ્ગોરિધમની કાર્યક્ષમતા અને સંસાધન જરૂરિયાતોનું મૂલ્યાંકન કરવામાં મદદ કરે
છે.

\textbf{ટાઇમ કોમ્પ્લેક્ષીટી:} ટાઇમ કોમ્પ્લેક્ષીટી એ ઇનપુટ સાઇઝના ફંક્શન તરીકે
અલ્ગોરિધમ પૂર્ણ થવામાં લાગતા સમયનું માપ છે. તે ઇનપુટ સાઇઝના સંબંધમાં અલ્ગોરિધમ દ્વારા
કરવામાં આવતા operations અથવા steps ની સંખ્યાને રજૂ કરે છે.

ટાઇમ કોમ્પ્લેક્ષીટી વિશેના મુખ્ય મુદ્દાઓ: - Big O notation નો ઉપયોગ કરીને વ્યક્ત
કરવામાં આવે છે, દા.ત., O(n), O(log n), O(n\^{}2) - સૌથી ખરાબ કેસ સ્થિતિ પર
ધ્યાન કેન્દ્રિત કરે છે - વિવિધ અલ્ગોરિધમ્સની કાર્યક્ષમતાની તુલના કરવામાં મદદ કરે છે -
હાર્ડવેર અથવા અમલીકરણની વિગતોથી સ્વતંત્ર

ઉદાહરણ: O(n) ટાઇમ કોમ્પ્લેક્ષીટી ધરાવતા અલ્ગોરિધમનો અર્થ એ છે કે તેનો execution
સમય ઇનપુટ સાઇઝ સાથે રૈખિક રીતે વધે છે.

\textbf{સ્પેસ કોમ્પ્લેક્ષીટી:} સ્પેસ કોમ્પ્લેક્ષીટી એ ઇનપુટ સાઇઝના સંબંધમાં અલ્ગોરિધમને
જરૂરી મેમરી સ્પેસની રકમનો ઉલ્લેખ કરે છે. તે સમસ્યાનો ઉકેલ લાવવા માટે અલ્ગોરિધમને જરૂરી
વધારાની અથવા સહાયક જગ્યાનું માપ કરે છે.

સ્પેસ કોમ્પ્લેક્ષીટી વિશેના મુખ્ય મુદ્દાઓ: - પણ Big O notation નો ઉપયોગ કરીને વ્યક્ત
કરવામાં આવે છે - સહાયક સ્પેસ અને ઇનપુટ દ્વારા વપરાયેલ સ્પેસ બંને સામેલ છે - અલ્ગોરિધમ્સની
મેમરી કાર્યક્ષમતાનું મૂલ્યાંકન કરવામાં મદદ કરે છે - મર્યાદિત મેમરી સંસાધનો ધરાવતા
એપ્લિકેશનો માટે મહત્વપૂર્ણ

ઉદાહરણ: O(1) સ્પેસ કોમ્પ્લેક્ષીટી ધરાવતો અલ્ગોરિધમ ઇનપુટ સાઇઝને ધ્યાનમાં લીધા વિના
સતત પ્રમાણમાં વધારાની જગ્યાનો ઉપયોગ કરે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Complexity Analysis] {-}{-}\textgreater{} B[ટાઇમ કોમ્પ્લેક્ષીટી]}
\NormalTok{    A {-}{-}\textgreater{} C[સ્પેસ કોમ્પ્લેક્ષીટી]}
\NormalTok{    B {-}{-}\textgreater{} D[execution સમય માપે છે]}
\NormalTok{    B {-}{-}\textgreater{} E[Big O notation નો ઉપયોગ કરે છે]}
\NormalTok{    C {-}{-}\textgreater{} F[મેમરી વપરાશ માપે છે]}
\NormalTok{    C {-}{-}\textgreater{} G[સહાયક સ્પેસ સામેલ કરે છે]}
\NormalTok{    E {-}{-}\textgreater{} H["દા.ત., O(n), O(log n), O(n\^{}2)"]}
\NormalTok{    G {-}{-}\textgreater{} I["દા.ત., O(1), O(n), O(n\^{}2)"]}
\end{Highlighting}
\end{Shaded}

\hypertarget{question-1c-explain-the-concept-of-class-and-object-with-example.-07-marks}{%
\subsubsection{Question 1(c): Explain the concept of class and object
with example. (07
marks)}\label{question-1c-explain-the-concept-of-class-and-object-with-example.-07-marks}}

\textbf{Ans 1(c):} Classes and objects are fundamental concepts in
object-oriented programming (OOP). They provide a way to structure code,
encapsulate data, and create reusable components.

\textbf{Class:} A class is a blueprint or template for creating objects.
It defines the attributes (data) and methods (functions) that the
objects of that class will have.

Key points about classes: - Act as a blueprint for objects - Encapsulate
data and behavior - Support inheritance and polymorphism - Promote code
reusability and organization

\textbf{Object:} An object is an instance of a class. It represents a
specific entity with its own set of data and ability to perform actions
defined by its class.

Key points about objects: - Instances of a class - Have their own unique
set of attributes - Can perform actions (methods) defined in their class
- Interact with other objects

\textbf{Example: Car Class and Objects}

Let's illustrate these concepts with a \texttt{Car} class and car
objects:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Car:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, make, model, year, color):}
        \VariableTok{self}\NormalTok{.make }\OperatorTok{=}\NormalTok{ make}
        \VariableTok{self}\NormalTok{.model }\OperatorTok{=}\NormalTok{ model}
        \VariableTok{self}\NormalTok{.year }\OperatorTok{=}\NormalTok{ year}
        \VariableTok{self}\NormalTok{.color }\OperatorTok{=}\NormalTok{ color}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ accelerate(}\VariableTok{self}\NormalTok{, increase):}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{+=}\NormalTok{ increase}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ is now going }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ km/h"}\NormalTok{)}

    \KeywordTok{def}\NormalTok{ brake(}\VariableTok{self}\NormalTok{, decrease):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.speed }\OperatorTok{{-}}\NormalTok{ decrease }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
            \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.speed }\OperatorTok{{-}=}\NormalTok{ decrease}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ slowed down to }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ km/h"}\NormalTok{)}

\CommentTok{\# Creating car objects}
\NormalTok{car1 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Toyota"}\NormalTok{, }\StringTok{"Corolla"}\NormalTok{, }\DecValTok{2022}\NormalTok{, }\StringTok{"Blue"}\NormalTok{)}
\NormalTok{car2 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Honda"}\NormalTok{, }\StringTok{"Civic"}\NormalTok{, }\DecValTok{2023}\NormalTok{, }\StringTok{"Red"}\NormalTok{)}

\CommentTok{\# Using object methods}
\NormalTok{car1.accelerate(}\DecValTok{50}\NormalTok{)}
\NormalTok{car2.accelerate(}\DecValTok{60}\NormalTok{)}
\NormalTok{car1.brake(}\DecValTok{20}\NormalTok{)}
\NormalTok{car2.brake(}\DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In this example: 1. The \texttt{Car} class defines the blueprint for car
objects. 2. It has attributes like \texttt{make}, \texttt{model},
\texttt{year}, \texttt{color}, and \texttt{speed}. 3. It also has
methods \texttt{accelerate()} and \texttt{brake()} to modify the car's
speed. 4. We create two car objects, \texttt{car1} and \texttt{car2},
each with its own set of attributes. 5. We can call methods on these
objects to change their state.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class Car \{}
\NormalTok{        +make: string}
\NormalTok{        +model: string}
\NormalTok{        +year: int}
\NormalTok{        +color: string}
\NormalTok{        +speed: int}
\NormalTok{        +accelerate(increase: int)}
\NormalTok{        +brake(decrease: int)}
\NormalTok{    \}}
\NormalTok{    Car \textless{}|{-}{-} car1: instance}
\NormalTok{    Car \textless{}|{-}{-} car2: instance}
    
\NormalTok{    class car1 \{}
\NormalTok{        make = "Toyota"}
\NormalTok{        model = "Corolla"}
\NormalTok{        year = 2022}
\NormalTok{        color = "Blue"}
\NormalTok{    \}}
    
\NormalTok{    class car2 \{}
\NormalTok{        make = "Honda"}
\NormalTok{        model = "Civic"}
\NormalTok{        year = 2023}
\NormalTok{        color = "Red"}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the relationship between the \texttt{Car} class
and its objects, showing how each object is an instance of the class
with its own unique set of attributes.

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa95-uxa95uxab2uxab8-uxa85uxaa8-uxa93uxaacuxa9cuxa95uxa9f-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}{%
\subsubsection{પ્રશ્ન 1(ક): ક્લાસ અને ઓબ્જેક્ટ ઉદાહરણ સાથે સમજાવો.
(૦૭)}\label{uxaaauxab0uxab6uxaa8-1uxa95-uxa95uxab2uxab8-uxa85uxaa8-uxa93uxaacuxa9cuxa95uxa9f-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}}

\textbf{જવાબ 1(ક):} Class અને object એ object-oriented programming
(OOP)માં મૂળભૂત concepts છે. તેઓ કોડને structure કરવા, data ને encapsulate કરવા
અને reusable components બનાવવાની રીત પ્રદાન કરે છે.

\textbf{Class:} Class એ objects બનાવવા માટેનો blueprint અથવા template છે.
તે attributes (data) અને methods (functions) ને વ્યાખ્યાયિત કરે છે જે તે class ના
objects ધરાવશે.

Class વિશેના મુખ્ય મુદ્દાઓ: - Objects માટે blueprint તરીકે કાર્ય કરે છે - Data અને
behavior ને encapsulate કરે છે - Inheritance અને polymorphism ને support કરે છે
- Code reusability અને organization ને પ્રોત્સાહન આપે છે

\textbf{Object:} Object એ class નું instance છે. તે ચોક્કસ entity નું
પ્રતિનિધિત્વ કરે છે જે તેના પોતાના data set અને તેના class દ્વારા વ્યાખ્યાયિત
ક્રિયાઓ કરવાની ક્ષમતા ધરાવે છે.

Objects વિશેના મુખ્ય મુદ્દાઓ: - Class ના instances છે - તેમના પોતાના અનન્ય
attributes set ધરાવે છે - તેમના class માં વ્યાખ્યાયિત ક્રિયાઓ (methods) કરી શકે
છે - અન્ય objects સાથે interact કરે છે

\textbf{ઉદાહરણ: Car Class અને Objects}

આ concepts ને \texttt{Car} class અને car objects સાથે સમજાવીએ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Car:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, make, model, year, color):}
        \VariableTok{self}\NormalTok{.make }\OperatorTok{=}\NormalTok{ make}
        \VariableTok{self}\NormalTok{.model }\OperatorTok{=}\NormalTok{ model}
        \VariableTok{self}\NormalTok{.year }\OperatorTok{=}\NormalTok{ year}
        \VariableTok{self}\NormalTok{.color }\OperatorTok{=}\NormalTok{ color}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ accelerate(}\VariableTok{self}\NormalTok{, increase):}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{+=}\NormalTok{ increase}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ હવે }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ km/h પર જઈ રહ્યું છે"}\NormalTok{)}

    \KeywordTok{def}\NormalTok{ brake(}\VariableTok{self}\NormalTok{, decrease):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.speed }\OperatorTok{{-}}\NormalTok{ decrease }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
            \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.speed }\OperatorTok{{-}=}\NormalTok{ decrease}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ ધીમું પડીને }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ km/h પર આવ્યું"}\NormalTok{)}

\CommentTok{\# Car objects બનાવવા}
\NormalTok{car1 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Toyota"}\NormalTok{, }\StringTok{"Corolla"}\NormalTok{, }\DecValTok{2022}\NormalTok{, }\StringTok{"Blue"}\NormalTok{)}
\NormalTok{car2 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Honda"}\NormalTok{, }\StringTok{"Civic"}\NormalTok{, }\DecValTok{2023}\NormalTok{, }\StringTok{"Red"}\NormalTok{)}

\CommentTok{\# Object methods નો ઉપયોગ કરવો}
\NormalTok{car1.accelerate(}\DecValTok{50}\NormalTok{)}
\NormalTok{car2.accelerate(}\DecValTok{60}\NormalTok{)}
\NormalTok{car1.brake(}\DecValTok{20}\NormalTok{)}
\NormalTok{car2.brake(}\DecValTok{30}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

આ ઉદાહરણમાં: 1. \texttt{Car} class car objects માટે blueprint વ્યાખ્યાયિત કરે
છે. 2. તેમાં \texttt{make}, \texttt{model}, \texttt{year}, \texttt{color},
અને \texttt{speed} જેવા attributes છે. 3. તેમાં \texttt{accelerate()} અને
\texttt{brake()} methods પણ છે જે car ની speed ને modify કરે છે. 4. આપણે બે car
objects બનાવીએ છીએ, \texttt{car1} અને \texttt{car2}, દરેક તેના પોતાના
attributes set સાથે. 5. આપણે આ objects પર methods ને call કરી શકીએ છીએ જેથી
તેમની state બદલાય.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class Car \{}
\NormalTok{        +make: string}
\NormalTok{        +model: string}
\NormalTok{        +year: int}
\NormalTok{        +color: string}
\NormalTok{        +speed: int}
\NormalTok{        +accelerate(increase: int)}
\NormalTok{        +brake(decrease: int)}
\NormalTok{    \}}
\NormalTok{    Car \textless{}|{-}{-} car1: instance}
\NormalTok{    Car \textless{}|{-}{-} car2: instance}
    
\NormalTok{    class car1 \{}
\NormalTok{        make = "Toyota"}
\NormalTok{        model = "Corolla"}
\NormalTok{        year = 2022}
\NormalTok{        color = "Blue"}
\NormalTok{    \}}
    
\NormalTok{    class car2 \{}
\NormalTok{        make = "Honda"}
\NormalTok{        model = "Civic"}
\NormalTok{        year = 2023}
\NormalTok{        color = "Red"}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ \texttt{Car} class અને તેના objects વચ્ચેના સંબંધને દર્શાવે છે, જે બતાવે છે કે
કેવી રીતે દરેક object એ class નું instance છે જે તેના પોતાના અનન્ય attributes set
ધરાવે છે.

\hypertarget{question-1cor-explain-instance-method-class-method-and-static-method-with-example.-07-marks}{%
\subsubsection{Question 1(cOR): Explain instance method, class method
and static method with example. (07
marks)}\label{question-1cor-explain-instance-method-class-method-and-static-method-with-example.-07-marks}}

\textbf{Ans 1(cOR):} In object-oriented programming, particularly in
Python, there are three types of methods: instance methods, class
methods, and static methods. Each serves a different purpose and has
unique characteristics.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instance Methods:}

  \begin{itemize}
  \tightlist
  \item
    Operate on instance-specific data
  \item
    First parameter is \texttt{self} (the instance)
  \item
    Can access and modify instance state
  \end{itemize}
\item
  \textbf{Class Methods:}

  \begin{itemize}
  \tightlist
  \item
    Operate on class-level data
  \item
    First parameter is \texttt{cls} (the class)
  \item
    Decorated with \texttt{@classmethod}
  \item
    Can access and modify class state
  \end{itemize}
\item
  \textbf{Static Methods:}

  \begin{itemize}
  \tightlist
  \item
    Don't operate on instance or class data
  \item
    No special first parameter
  \item
    Decorated with \texttt{@staticmethod}
  \item
    Utility functions related to the class
  \end{itemize}
\end{enumerate}

Example demonstrating all three types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ MathOperations:}
\NormalTok{    pi }\OperatorTok{=} \FloatTok{3.14159}  \CommentTok{\# Class variable}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, value):}
        \VariableTok{self}\NormalTok{.value }\OperatorTok{=}\NormalTok{ value  }\CommentTok{\# Instance variable}

    \KeywordTok{def}\NormalTok{ square(}\VariableTok{self}\NormalTok{):  }\CommentTok{\# Instance method}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.value }\OperatorTok{**} \DecValTok{2}

    \AttributeTok{@classmethod}
    \KeywordTok{def}\NormalTok{ circle\_area(cls, radius):  }\CommentTok{\# Class method}
        \ControlFlowTok{return}\NormalTok{ cls.pi }\OperatorTok{*}\NormalTok{ radius }\OperatorTok{**} \DecValTok{2}

    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ add(a, b):  }\CommentTok{\# Static method}
        \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\CommentTok{\# Usage}
\NormalTok{math\_obj }\OperatorTok{=}\NormalTok{ MathOperations(}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(math\_obj.square())  }\CommentTok{\# Instance method call}
\BuiltInTok{print}\NormalTok{(MathOperations.circle\_area(}\DecValTok{3}\NormalTok{))  }\CommentTok{\# Class method call}
\BuiltInTok{print}\NormalTok{(MathOperations.add(}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{))  }\CommentTok{\# Static method call}
\end{Highlighting}
\end{Shaded}

Comparison in tabular form:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2717}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2391}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1848}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Instance Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Static Method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Decorator & None & \texttt{@classmethod} & \texttt{@staticmethod} \\
First Parameter & \texttt{self} (instance) & \texttt{cls} (class) &
None \\
Can Access Instance State & Yes & No & No \\
Can Access Class State & Yes & Yes & No \\
Can Modify Class State & No & Yes & No \\
Called via & Instance & Class or Instance & Class or Instance \\
Use Case & Instance-specific operations & Class-level operations &
Utility functions \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class MathOperations \{}
\NormalTok{        +pi: float}
\NormalTok{        {-}value: float}
\NormalTok{        +\_\_init\_\_(value: float)}
\NormalTok{        +square(): float}
\NormalTok{        +circle\_area(radius: float): float}
\NormalTok{        +add(a: float, b: float): float}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the structure of the \texttt{MathOperations}
class, showing the different types of methods and their parameters.

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa95or-uxa87uxab8uxa9fuxab8-uxaaeuxaa5uxaa1-uxa95uxab2uxab8-uxaaeuxaa5uxaa1-uxa85uxaa8-uxab8uxa9fuxa9fuxa95-uxaaeuxaa5uxaa1-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}{%
\subsubsection{પ્રશ્ન 1(કOR): ઇંસ્ટંસ મેથડ, ક્લાસ મેથડ અને સ્ટેટીક મેથડ ઉદાહરણ સાથે
સમજાવો.
(૦૭)}\label{uxaaauxab0uxab6uxaa8-1uxa95or-uxa87uxab8uxa9fuxab8-uxaaeuxaa5uxaa1-uxa95uxab2uxab8-uxaaeuxaa5uxaa1-uxa85uxaa8-uxab8uxa9fuxa9fuxa95-uxaaeuxaa5uxaa1-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}}

\textbf{જવાબ 1(કOR):} Object-oriented programming માં, ખાસ કરીને Python
માં, ત્રણ પ્રકારની methods હોય છે: instance methods, class methods, અને
static methods. દરેક અલગ હેતુ માટે સેવા આપે છે અને અનન્ય લક્ષણો ધરાવે છે.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instance Methods:}

  \begin{itemize}
  \tightlist
  \item
    Instance-specific data પર કાર્ય કરે છે
  \item
    પ્રથમ parameter \texttt{self} (instance) છે
  \item
    Instance state ને access અને modify કરી શકે છે
  \end{itemize}
\item
  \textbf{Class Methods:}

  \begin{itemize}
  \tightlist
  \item
    Class-level data પર કાર્ય કરે છે
  \item
    પ્રથમ parameter \texttt{cls} (class) છે
  \item
    \texttt{@classmethod} decorator સાથે ડેકોરેટ કરેલ હોય છે
  \item
    Class state ને access અને modify કરી શકે છે
  \end{itemize}
\item
  \textbf{Static Methods:}

  \begin{itemize}
  \tightlist
  \item
    Instance કે class data પર કાર્ય કરતી નથી
  \item
    કોઈ ખાસ પ્રથમ parameter નથી
  \item
    \texttt{@staticmethod} decorator સાથે ડેકોરેટ કરેલ હોય છે
  \item
    Class સાથે સંબંધિત utility functions છે
  \end{itemize}
\end{enumerate}

ત્રણેય પ્રકારને દર્શાવતું ઉદાહરણ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ MathOperations:}
\NormalTok{    pi }\OperatorTok{=} \FloatTok{3.14159}  \CommentTok{\# Class variable}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, value):}
        \VariableTok{self}\NormalTok{.value }\OperatorTok{=}\NormalTok{ value  }\CommentTok{\# Instance variable}

    \KeywordTok{def}\NormalTok{ square(}\VariableTok{self}\NormalTok{):  }\CommentTok{\# Instance method}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.value }\OperatorTok{**} \DecValTok{2}

    \AttributeTok{@classmethod}
    \KeywordTok{def}\NormalTok{ circle\_area(cls, radius):  }\CommentTok{\# Class method}
        \ControlFlowTok{return}\NormalTok{ cls.pi }\OperatorTok{*}\NormalTok{ radius }\OperatorTok{**} \DecValTok{2}

    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ add(a, b):  }\CommentTok{\# Static method}
        \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\CommentTok{\# ઉપયોગ}
\NormalTok{math\_obj }\OperatorTok{=}\NormalTok{ MathOperations(}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(math\_obj.square())  }\CommentTok{\# Instance method call}
\BuiltInTok{print}\NormalTok{(MathOperations.circle\_area(}\DecValTok{3}\NormalTok{))  }\CommentTok{\# Class method call}
\BuiltInTok{print}\NormalTok{(MathOperations.add(}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{))  }\CommentTok{\# Static method call}
\end{Highlighting}
\end{Shaded}

કોષ્ટક સ્વરૂપમાં તુલના:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2887}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2887}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2268}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1959}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Instance Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Static Method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Decorator & કોઈ નહીં & \texttt{@classmethod} & \texttt{@staticmethod} \\
પ્રથમ Parameter & \texttt{self} (instance) & \texttt{cls} (class) & કોઈ
નહીં \\
Instance State Access કરી શકે & હા & ના & ના \\
Class State Access કરી શકે & હા & હા & ના \\
Class State Modify કરી શકે & ના & હા & ના \\
દ્વારા Call થાય & Instance & Class અથવા Instance & Class અથવા Instance \\
ઉપયોગ કેસ & Instance-specific operations & Class-level operations &
Utility functions \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class MathOperations \{}
\NormalTok{        +pi: float}
\NormalTok{        {-}value: float}
\NormalTok{        +\_\_init\_\_(value: float)}
\NormalTok{        +square(): float}
\NormalTok{        +circle\_area(radius: float): float}
\NormalTok{        +add(a: float, b: float): float}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ \texttt{MathOperations} class ની રચનાને દર્શાવે છે, જે વિવિધ પ્રકારની
methods અને તેમના parameters બતાવે છે.

\hypertarget{question-2a-explain-concept-of-recursive-function.-03-marks}{%
\subsubsection{Question 2(a): Explain concept of recursive function. (03
marks)}\label{question-2a-explain-concept-of-recursive-function.-03-marks}}

\textbf{Ans 2(a):} A recursive function is a function that calls itself
during its execution. This technique allows the function to repeat its
behavior until it reaches a specific condition, known as the base case,
which terminates the recursion.

Key points about recursive functions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Base Case:}

  \begin{itemize}
  \tightlist
  \item
    A condition that stops the recursion
  \item
    Prevents infinite recursion
  \item
    Usually the simplest form of the problem
  \end{itemize}
\item
  \textbf{Recursive Case:}

  \begin{itemize}
  \tightlist
  \item
    The part where the function calls itself
  \item
    Breaks down the problem into smaller subproblems
  \end{itemize}
\item
  \textbf{Call Stack:}

  \begin{itemize}
  \tightlist
  \item
    Each recursive call adds a new layer to the call stack
  \item
    The stack unwinds as base cases are reached and functions return
  \end{itemize}
\item
  \textbf{Advantages:}

  \begin{itemize}
  \tightlist
  \item
    Can solve complex problems with elegant and concise code
  \item
    Naturally suited for problems with recursive structures (e.g., tree
    traversal)
  \end{itemize}
\item
  \textbf{Disadvantages:}

  \begin{itemize}
  \tightlist
  \item
    Can be memory-intensive for deep recursions
  \item
    May be less efficient than iterative solutions for simple problems
  \end{itemize}
\end{enumerate}

Example of a recursive function to calculate factorial:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ factorial(n):}
    \CommentTok{\# Base case}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{0} \KeywordTok{or}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{1}
    \CommentTok{\# Recursive case}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Usage}
\BuiltInTok{print}\NormalTok{(factorial(}\DecValTok{5}\NormalTok{))  }\CommentTok{\# Output: 120}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["factorial(5)"] {-}{-}\textgreater{} B["5 * factorial(4)"]}
\NormalTok{    B {-}{-}\textgreater{} C["5 * 4 * factorial(3)"]}
\NormalTok{    C {-}{-}\textgreater{} D["5 * 4 * 3 * factorial(2)"]}
\NormalTok{    D {-}{-}\textgreater{} E["5 * 4 * 3 * 2 * factorial(1)"]}
\NormalTok{    E {-}{-}\textgreater{} F["5 * 4 * 3 * 2 * 1"]}
\NormalTok{    F {-}{-}\textgreater{} G["120"]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates how the recursive function breaks down the
factorial calculation into smaller subproblems until it reaches the base
case.

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa85-uxab0uxa95uxab0uxa9duxab5-uxaabuxa95uxab6uxaa8-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}{%
\subsubsection{પ્રશ્ન 2(અ): રીકર્ઝીવ ફંકશન નો કોંસેપ્ટ સમજાવો.
(૦૩)}\label{uxaaauxab0uxab6uxaa8-2uxa85-uxab0uxa95uxab0uxa9duxab5-uxaabuxa95uxab6uxaa8-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}}

\textbf{જવાબ 2(અ):} રીકર્ઝીવ ફંક્શન એ એવું ફંક્શન છે જે તેના execution દરમિયાન
પોતાને જ કૉલ કરે છે. આ તકનીક ફંક્શનને તેની વર્તણૂકને પુનરાવર્તિત કરવાની મંજૂરી આપે છે
જ્યાં સુધી તે ચોક્કસ શરત, જેને base case કહેવામાં આવે છે, સુધી ન પહોંચે, જે રીકર્શનને
સમાપ્ત કરે છે.

રીકર્ઝીવ ફંક્શન્સ વિશેના મુખ્ય મુદ્દાઓ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Base Case:}

  \begin{itemize}
  \tightlist
  \item
    એક શરત જે રીકર્શનને રોકે છે
  \item
    અનંત રીકર્શનને અટકાવે છે
  \item
    સામાન્ય રીતે સમસ્યાનું સૌથી સરળ સ્વરૂપ
  \end{itemize}
\item
  \textbf{Recursive Case:}

  \begin{itemize}
  \tightlist
  \item
    તે ભાગ જ્યાં ફંક્શન પોતાને કૉલ કરે છે
  \item
    સમસ્યાને નાના ઉપ-સમસ્યાઓમાં વિભાજિત કરે છે
  \end{itemize}
\item
  \textbf{Call Stack:}

  \begin{itemize}
  \tightlist
  \item
    દરેક રીકર્ઝીવ કૉલ call stack માં નવું સ્તર ઉમેરે છે
  \item
    જ્યારે base cases સુધી પહોંચે અને ફંક્શન્સ પરત થાય ત્યારે stack unwind થાય છે
  \end{itemize}
\item
  \textbf{ફાયદાઓ:}

  \begin{itemize}
  \tightlist
  \item
    જટિલ સમસ્યાઓને elegant અને સંક્ષિપ્ત કોડ સાથે ઉકેલી શકે છે
  \item
    રીકર્ઝીવ સ્ટ્રક્ચર્સ (દા.ત., tree traversal) વાળી સમસ્યાઓ માટે કુદરતી રીતે
    અનુકૂળ
  \end{itemize}
\item
  \textbf{ગેરફાયદાઓ:}

  \begin{itemize}
  \tightlist
  \item
    ઊંડા રીકર્શન માટે મેમરી-ઇન્ટેન્સિવ હોઈ શકે છે
  \item
    સરળ સમસ્યાઓ માટે iterative solutions કરતાં ઓછું કાર્યક્ષમ હોઈ શકે છે
  \end{itemize}
\end{enumerate}

Factorial ગણવા માટે રીકર્ઝીવ ફંક્શનનું ઉદાહરણ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ factorial(n):}
    \CommentTok{\# Base case}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{0} \KeywordTok{or}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{1}
    \CommentTok{\# Recursive case}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# ઉપયોગ}
\BuiltInTok{print}\NormalTok{(factorial(}\DecValTok{5}\NormalTok{))  }\CommentTok{\# આઉટપુટ: 120}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["factorial(5)"] {-}{-}\textgreater{} B["5 * factorial(4)"]}
\NormalTok{    B {-}{-}\textgreater{} C["5 * 4 * factorial(3)"]}
\NormalTok{    C {-}{-}\textgreater{} D["5 * 4 * 3 * factorial(2)"]}
\NormalTok{    D {-}{-}\textgreater{} E["5 * 4 * 3 * 2 * factorial(1)"]}
\NormalTok{    E {-}{-}\textgreater{} F["5 * 4 * 3 * 2 * 1"]}
\NormalTok{    F {-}{-}\textgreater{} G["120"]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ દર્શાવે છે કે કેવી રીતે રીકર્ઝીવ ફંક્શન factorial ગણતરીને નાના ઉપ-સમસ્યાઓમાં
વિભાજિત કરે છે જ્યાં સુધી તે base case સુધી ન પહોંચે.

\hypertarget{question-2b-define-stack-and-queue.-04-marks}{%
\subsubsection{Question 2(b): Define stack and queue. (04
marks)}\label{question-2b-define-stack-and-queue.-04-marks}}

\textbf{Ans 2(b):}

\textbf{Stack:} A stack is a linear data structure that follows the
Last-In-First-Out (LIFO) principle. It can be visualized as a stack of
plates where you can only add or remove plates from the top.

Key characteristics of a stack: 1. Elements are added to the top (push
operation) 2. Elements are removed from the top (pop operation) 3. Only
the top element is accessible at any time 4. Follows the LIFO
(Last-In-First-Out) principle

Common operations: - Push: Add an element to the top - Pop: Remove the
top element - Peek or Top: View the top element without removing it -
IsEmpty: Check if the stack is empty

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Stack] {-}{-}\textgreater{} B[Top: 5]}
\NormalTok{    B {-}{-}\textgreater{} C[4]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[2]}
\NormalTok{    E {-}{-}\textgreater{} F[Bottom: 1]}
\end{Highlighting}
\end{Shaded}

\textbf{Queue:} A queue is a linear data structure that follows the
First-In-First-Out (FIFO) principle. It can be visualized as a line of
people waiting for a service, where the first person to join the line is
the first to be served.

Key characteristics of a queue: 1. Elements are added at the rear
(enqueue operation) 2. Elements are removed from the front (dequeue
operation) 3. Follows the FIFO (First-In-First-Out) principle

Common operations: - Enqueue: Add an element to the rear - Dequeue:
Remove the front element - Front: View the front element without
removing it - IsEmpty: Check if the queue is empty

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Front] {-}{-}\textgreater{} B[1]}
\NormalTok{    B {-}{-}\textgreater{} C[2]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[4]}
\NormalTok{    E {-}{-}\textgreater{} F[5]}
\NormalTok{    F {-}{-}\textgreater{} G[Rear]}
\end{Highlighting}
\end{Shaded}

Both stacks and queues are fundamental data structures used in various
algorithms and system designs, each suited for different types of
problems based on their access patterns.

\hypertarget{uxaaauxab0uxab6uxaa8-2uxaac-uxab8uxa9fuxa95-uxa85uxaa8-uxa95uxaaf-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}{%
\subsubsection{પ્રશ્ન 2(બ): સ્ટેક અને ક્યુ વ્યાખ્યાયિત કરો.
(૦૪)}\label{uxaaauxab0uxab6uxaa8-2uxaac-uxab8uxa9fuxa95-uxa85uxaa8-uxa95uxaaf-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}}

\textbf{જવાબ 2(બ):}

\textbf{સ્ટેક:} સ્ટેક એ એક linear data structure છે જે Last-In-First-Out
(LIFO) સિદ્ધાંતને અનુસરે છે. તેને પ્લેટ્સના સ્ટેક તરીકે કલ્પના કરી શકાય છે જ્યાં તમે માત્ર
ટોચથી જ પ્લેટ્સ ઉમેરી અથવા દૂર કરી શકો છો.

સ્ટેકની મુખ્ય લાક્ષણિકતાઓ: 1. Elements ને ટોચ પર ઉમેરવામાં આવે છે (push operation)
2. Elements ને ટોચથી દૂર કરવામાં આવે છે (pop operation) 3. કોઈપણ સમયે માત્ર
ટોચનો element જ accessible હોય છે 4. LIFO (Last-In-First-Out) સિદ્ધાંતને
અનુસરે છે

સામાન્ય operations: - Push: ટોચ પર element ઉમેરવો - Pop: ટોચનો element દૂર
કરવો - Peek અથવા Top: ટોચનો element દૂર કર્યા વગર જોવો - IsEmpty: સ્ટેક ખાલી
છે કે નહીં તે ચકાસવું

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[સ્ટેક] {-}{-}\textgreater{} B[ટોચ: 5]}
\NormalTok{    B {-}{-}\textgreater{} C[4]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[2]}
\NormalTok{    E {-}{-}\textgreater{} F[તળિયું: 1]}
\end{Highlighting}
\end{Shaded}

\textbf{ક્યુ:} ક્યુ એ એક linear data structure છે જે First-In-First-Out (FIFO)
સિદ્ધાંતને અનુસરે છે. તેને સેવા માટે રાહ જોતા લોકોની લાઇન તરીકે કલ્પના કરી શકાય છે,
જ્યાં લાઇનમાં જોડાનાર પ્રથમ વ્યક્તિને પ્રથમ સેવા આપવામાં આવે છે.

ક્યુની મુખ્ય લાક્ષણિકતાઓ: 1. Elements ને પાછળના ભાગમાં ઉમેરવામાં આવે છે (enqueue
operation) 2. Elements ને આગળના ભાગથી દૂર કરવામાં આવે છે (dequeue operation)
3. FIFO (First-In-First-Out) સિદ્ધાંતને અનુસરે છે

સામાન્ય operations: - Enqueue: પાછળના ભાગમાં element ઉમેરવો - Dequeue:
આગળના ભાગનો element દૂર કરવો - Front: આગળના ભાગનો element દૂર કર્યા વગર
જોવો - IsEmpty: ક્યુ ખાલી છે કે નહીં તે ચકાસવું

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[આગળ] {-}{-}\textgreater{} B[1]}
\NormalTok{    B {-}{-}\textgreater{} C[2]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[4]}
\NormalTok{    E {-}{-}\textgreater{} F[5]}
\NormalTok{    F {-}{-}\textgreater{} G[પાછળ]}
\end{Highlighting}
\end{Shaded}

સ્ટેક અને ક્યુ બંને વિવિધ algorithms અને system designs માં ઉપયોગમાં લેવાતા મૂળભૂત
data structures છે, જે તેમના access patterns ના આધારે અલગ-અલગ પ્રકારની સમસ્યાઓ
માટે યોગ્ય છે.

\hypertarget{question-2c-explain-basic-operations-on-stack.-07-marks}{%
\subsubsection{Question 2(c): Explain basic operations on stack. (07
marks)}\label{question-2c-explain-basic-operations-on-stack.-07-marks}}

\textbf{Ans 2(c):} A stack is a fundamental data structure that follows
the Last-In-First-Out (LIFO) principle. The basic operations on a stack
include Push, Pop, Peek (or Top), IsEmpty, and IsFull. Let's explain
each of these operations in detail:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Push Operation:}

  \begin{itemize}
  \tightlist
  \item
    Adds an element to the top of the stack
  \item
    Increases the stack size by 1
  \item
    If the stack is full, it results in a stack overflow condition
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ push(stack, item):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{\textless{}}\NormalTok{ MAX\_SIZE:}
\NormalTok{        stack.append(item)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Stack Overflow"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Pop Operation:}

  \begin{itemize}
  \tightlist
  \item
    Removes the top element from the stack
  \item
    Decreases the stack size by 1
  \item
    If the stack is empty, it results in a stack underflow condition
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pop(stack):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(stack):}
        \ControlFlowTok{return}\NormalTok{ stack.pop()}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Stack Underflow"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Peek (or Top) Operation:}

  \begin{itemize}
  \tightlist
  \item
    Returns the top element of the stack without removing it
  \item
    Does not modify the stack
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ peek(stack):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(stack):}
        \ControlFlowTok{return}\NormalTok{ stack[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Stack is empty"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{IsEmpty Operation:}

  \begin{itemize}
  \tightlist
  \item
    Checks if the stack is empty
  \item
    Returns True if the stack has no elements, False otherwise
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_empty(stack):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==} \DecValTok{0}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{IsFull Operation:}

  \begin{itemize}
  \tightlist
  \item
    Checks if the stack is full (applicable for fixed-size stacks)
  \item
    Returns True if the stack has reached its maximum capacity, False
    otherwise
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_full(stack):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==}\NormalTok{ MAX\_SIZE}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Example usage of these operations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{MAX\_SIZE }\OperatorTok{=} \DecValTok{5}
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}

\NormalTok{push(stack, }\DecValTok{1}\NormalTok{)}
\NormalTok{push(stack, }\DecValTok{2}\NormalTok{)}
\NormalTok{push(stack, }\DecValTok{3}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Top element:"}\NormalTok{, peek(stack))  }\CommentTok{\# Output: 3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Popped element:"}\NormalTok{, pop(stack))  }\CommentTok{\# Output: 3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Is stack empty?"}\NormalTok{, is\_empty(stack))  }\CommentTok{\# Output: False}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Is stack full?"}\NormalTok{, is\_full(stack))  }\CommentTok{\# Output: False}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Stack Operations] {-}{-}\textgreater{} B[Push]}
\NormalTok{    A {-}{-}\textgreater{} C[Pop]}
\NormalTok{    A {-}{-}\textgreater{} D[Peek/Top]}
\NormalTok{    A {-}{-}\textgreater{} E[IsEmpty]}
\NormalTok{    A {-}{-}\textgreater{} F[IsFull]}
\NormalTok{    B {-}{-}\textgreater{} G[Add element to top]}
\NormalTok{    C {-}{-}\textgreater{} H[Remove top element]}
\NormalTok{    D {-}{-}\textgreater{} I[View top element]}
\NormalTok{    E {-}{-}\textgreater{} J[Check if stack is empty]}
\NormalTok{    F {-}{-}\textgreater{} K[Check if stack is full]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the basic operations on a stack and their
primary functions.

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa95-uxab8uxa9fuxa95-uxaa8-uxaacuxa9duxa95-uxa93uxaaauxab0uxab6uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}{%
\subsubsection{પ્રશ્ન 2(ક): સ્ટેક ના બેઝિક ઓપરેશન સમજાવો.
(૦૭)}\label{uxaaauxab0uxab6uxaa8-2uxa95-uxab8uxa9fuxa95-uxaa8-uxaacuxa9duxa95-uxa93uxaaauxab0uxab6uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}}

\textbf{જવાબ 2(ક):} સ્ટેક એ મૂળભૂત ડેટા સ્ટ્રક્ચર છે જે Last-In-First-Out (LIFO)
સિદ્ધાંતને અનુસરે છે. સ્ટેક પરના મૂળભૂત ઓપરેશન્સમાં Push, Pop, Peek (અથવા Top),
IsEmpty, અને IsFull નો સમાવેશ થાય છે. આ દરેક ઓપરેશન્સને વિગતવાર સમજાવીએ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Push ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેકની ટોચ પર એક element ઉમેરે છે
  \item
    સ્ટેકનું કદ 1 વધારે છે
  \item
    જો સ્ટેક ભરેલો હોય, તો તે stack overflow સ્થિતિમાં પરિણમે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ push(stack, item):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{\textless{}}\NormalTok{ MAX\_SIZE:}
\NormalTok{        stack.append(item)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"સ્ટેક ઓવરફ્લો"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Pop ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેકમાંથી ટોચનો element દૂર કરે છે
  \item
    સ્ટેકનું કદ 1 ઘટાડે છે
  \item
    જો સ્ટેક ખાલી હોય, તો તે stack underflow સ્થિતિમાં પરિણમે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pop(stack):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(stack):}
        \ControlFlowTok{return}\NormalTok{ stack.pop()}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"સ્ટેક અંડરફ્લો"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Peek (અથવા Top) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેકના ટોચના element ને દૂર કર્યા વગર પરત કરે છે
  \item
    સ્ટેકમાં કોઈ ફેરફાર કરતું નથી
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ peek(stack):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(stack):}
        \ControlFlowTok{return}\NormalTok{ stack[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"સ્ટેક ખાલી છે"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{IsEmpty ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક ખાલી છે કે નહીં તે ચકાસે છે
  \item
    જો સ્ટેકમાં કોઈ elements ન હોય તો True, અન્યથા False પરત કરે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_empty(stack):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==} \DecValTok{0}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{IsFull ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક ભરેલો છે કે નહીં તે ચકાસે છે (નિશ્ચિત-કદના સ્ટેક્સ માટે લાગુ)
  \item
    જો સ્ટેક તેની મહત્તમ ક્ષમતા સુધી પહોંચ્યો હોય તો True, અન્યથા False પરત કરે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_full(stack):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==}\NormalTok{ MAX\_SIZE}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

આ ઓપરેશન્સનો ઉપયોગનું ઉદાહરણ:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{MAX\_SIZE }\OperatorTok{=} \DecValTok{5}
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}

\NormalTok{push(stack, }\DecValTok{1}\NormalTok{)}
\NormalTok{push(stack, }\DecValTok{2}\NormalTok{)}
\NormalTok{push(stack, }\DecValTok{3}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"ટોચનો element:"}\NormalTok{, peek(stack))  }\CommentTok{\# આઉટપુટ: 3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"દૂર કરેલ element:"}\NormalTok{, pop(stack))  }\CommentTok{\# આઉટપુટ: 3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"શું સ્ટેક ખાલી છે?"}\NormalTok{, is\_empty(stack))  }\CommentTok{\# આઉટપુટ: False}
\BuiltInTok{print}\NormalTok{(}\StringTok{"શું સ્ટેક ભરેલો છે?"}\NormalTok{, is\_full(stack))  }\CommentTok{\# આઉટપુટ: False}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[સ્ટેક ઓપરેશન્સ] {-}{-}\textgreater{} B[Push]}
\NormalTok{    A {-}{-}\textgreater{} C[Pop]}
\NormalTok{    A {-}{-}\textgreater{} D[Peek/Top]}
\NormalTok{    A {-}{-}\textgreater{} E[IsEmpty]}
\NormalTok{    A {-}{-}\textgreater{} F[IsFull]}
\NormalTok{    B {-}{-}\textgreater{} G[ટોચ પર element ઉમેરો]}
\NormalTok{    C {-}{-}\textgreater{} H[ટોચનો element દૂર કરો]}
\NormalTok{    D {-}{-}\textgreater{} I[ટોચનો element જુઓ]}
\NormalTok{    E {-}{-}\textgreater{} J[સ્ટેક ખાલી છે કે નહીં ચકાસો]}
\NormalTok{    F {-}{-}\textgreater{} K[સ્ટેક ભરેલો છે કે નહીં ચકાસો]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ સ્ટેક પરના મૂળભૂત ઓપરેશન્સ અને તેમના મુખ્ય કાર્યોને દર્શાવે છે.

\hypertarget{question-2aor-define-singly-linked-list.-03-marks}{%
\subsubsection{Question 2(aOR): Define singly linked list. (03
marks)}\label{question-2aor-define-singly-linked-list.-03-marks}}

\textbf{Ans 2(aOR):} A singly linked list is a linear data structure in
which elements are stored in nodes. Each node contains two components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Data: The actual value or information stored in the node.
\item
  Next pointer: A reference to the next node in the sequence.
\end{enumerate}

Key characteristics of a singly linked list:

\begin{itemize}
\tightlist
\item
  Each node points only to the next node in the sequence.
\item
  The last node points to NULL, indicating the end of the list.
\item
  The first node is called the head of the list.
\item
  Elements are not stored in contiguous memory locations.
\item
  Dynamic size, allowing for efficient insertion and deletion
  operations.
\end{itemize}

Basic structure of a node in a singly linked list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

Diagrammatic representation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[Node 4]}
\NormalTok{    E {-}{-}\textgreater{} F[NULL]}
\NormalTok{    B {-}{-}data{-}{-}\textgreater{} G[Data 1]}
\NormalTok{    C {-}{-}data{-}{-}\textgreater{} H[Data 2]}
\NormalTok{    D {-}{-}data{-}{-}\textgreater{} I[Data 3]}
\NormalTok{    E {-}{-}data{-}{-}\textgreater{} J[Data 4]}
\end{Highlighting}
\end{Shaded}

This diagram shows a singly linked list with four nodes, where each node
points to the next one, and the last node points to NULL.

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa85or-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxae9}{%
\subsubsection{પ્રશ્ન 2(અOR): સિંગ્લી લિંક્ડ લિસ્ટ વ્યાખ્યાયિત કરો.
(૦૩)}\label{uxaaauxab0uxab6uxaa8-2uxa85or-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxae9}}

\textbf{જવાબ 2(અOR):} સિંગ્લી લિંક્ડ લિસ્ટ એ એક linear data structure છે જેમાં
elements ને nodes માં સંગ્રહિત કરવામાં આવે છે. દરેક node બે ઘટકો ધરાવે છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Data: Node માં સંગ્રહિત વાસ્તવિક મૂલ્ય અથવા માહિતી.
\item
  Next pointer: શ્રેણીમાં આગળના node નો સંદર્ભ.
\end{enumerate}

સિંગ્લી લિંક્ડ લિસ્ટની મુખ્ય લાક્ષણિકતાઓ:

\begin{itemize}
\tightlist
\item
  દરેક node માત્ર શ્રેણીમાં આગળના node તરફ પોઇન્ટ કરે છે.
\item
  છેલ્લો node NULL તરફ પોઇન્ટ કરે છે, જે લિસ્ટના અંતને દર્શાવે છે.
\item
  પ્રથમ node ને લિસ્ટનું head કહેવામાં આવે છે.
\item
  Elements સળંગ મેમરી સ્થાનોમાં સંગ્રહિત થતા નથી.
\item
  Dynamic કદ, જે કાર્યક્ષમ insertion અને deletion operations ની મંજૂરી આપે છે.
\end{itemize}

સિંગ્લી લિંક્ડ લિસ્ટમાં node ની મૂળભૂત રચના:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

આકૃતિ દ્વારા રજૂઆત:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[Node 4]}
\NormalTok{    E {-}{-}\textgreater{} F[NULL]}
\NormalTok{    B {-}{-}data{-}{-}\textgreater{} G[Data 1]}
\NormalTok{    C {-}{-}data{-}{-}\textgreater{} H[Data 2]}
\NormalTok{    D {-}{-}data{-}{-}\textgreater{} I[Data 3]}
\NormalTok{    E {-}{-}data{-}{-}\textgreater{} J[Data 4]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ ચાર nodes વાળી સિંગ્લી લિંક્ડ લિસ્ટ દર્શાવે છે, જ્યાં દરેક node આગળના node
તરફ પોઇન્ટ કરે છે, અને છેલ્લો node NULL તરફ પોઇન્ટ કરે છે.

\hypertarget{question-2bor-explain-enqueue-and-dequeue-operations-on-queue.-04-marks}{%
\subsubsection{Question 2(bOR): Explain Enqueue and Dequeue operations
on Queue. (04
marks)}\label{question-2bor-explain-enqueue-and-dequeue-operations-on-queue.-04-marks}}

\textbf{Ans 2(bOR):}

A queue is a linear data structure that follows the First-In-First-Out
(FIFO) principle. The two primary operations on a queue are Enqueue and
Dequeue.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Enqueue Operation:}

  \begin{itemize}
  \tightlist
  \item
    Adds an element to the rear of the queue
  \item
    Increases the size of the queue by 1
  \item
    If the queue is full, it results in a queue overflow condition
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ enqueue(queue, item):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(queue) }\OperatorTok{\textless{}}\NormalTok{ MAX\_SIZE:}
\NormalTok{        queue.append(item)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue Overflow"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Dequeue Operation:}

  \begin{itemize}
  \tightlist
  \item
    Removes the element from the front of the queue
  \item
    Decreases the size of the queue by 1
  \item
    If the queue is empty, it results in a queue underflow condition
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ dequeue(queue):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(queue):}
        \ControlFlowTok{return}\NormalTok{ queue.pop(}\DecValTok{0}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue Underflow"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Queue Operations] {-}{-}\textgreater{} B[Enqueue]}
\NormalTok{    A {-}{-}\textgreater{} C[Dequeue]}
\NormalTok{    B {-}{-}\textgreater{} D[Add to Rear]}
\NormalTok{    C {-}{-}\textgreater{} E[Remove from Front]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the Enqueue and Dequeue operations on a queue.

\hypertarget{uxaaauxab0uxab6uxaa8-2uxaacor-uxa95uxaaf-uxa89uxaaauxab0-uxa8fuxaa8uxa95uxaaf-uxaa1uxa95uxaaf-uxa93uxaaauxab0uxab6uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}{%
\subsubsection{પ્રશ્ન 2(બOR): ક્યુ ઉપર એનક્યુ ડીક્યુ ઓપરેશન સમજાવો.
(૦૪)}\label{uxaaauxab0uxab6uxaa8-2uxaacor-uxa95uxaaf-uxa89uxaaauxab0-uxa8fuxaa8uxa95uxaaf-uxaa1uxa95uxaaf-uxa93uxaaauxab0uxab6uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}}

\textbf{જવાબ 2(બOR):}

ક્યુ એ એક linear data structure છે જે First-In-First-Out (FIFO) સિદ્ધાંતને અનુસરે
છે. ક્યુ પરના બે મુખ્ય ઓપરેશન્સ એનક્યુ અને ડીક્યુ છે.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{એનક્યુ (Enqueue) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    ક્યુના પાછળના ભાગમાં એક element ઉમેરે છે
  \item
    ક્યુનું કદ 1 વધારે છે
  \item
    જો ક્યુ ભરેલી હોય, તો તે queue overflow સ્થિતિમાં પરિણમે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ enqueue(queue, item):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(queue) }\OperatorTok{\textless{}}\NormalTok{ MAX\_SIZE:}
\NormalTok{        queue.append(item)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુ ઓવરફ્લો"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{ડીક્યુ (Dequeue) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    ક્યુના આગળના ભાગમાંથી element દૂર કરે છે
  \item
    ક્યુનું કદ 1 ઘટાડે છે
  \item
    જો ક્યુ ખાલી હોય, તો તે queue underflow સ્થિતિમાં પરિણમે છે
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ dequeue(queue):}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ is\_empty(queue):}
        \ControlFlowTok{return}\NormalTok{ queue.pop(}\DecValTok{0}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુ અંડરફ્લો"}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[ક્યુ ઓપરેશન્સ] {-}{-}\textgreater{} B[એનક્યુ]}
\NormalTok{    A {-}{-}\textgreater{} C[ડીક્યુ]}
\NormalTok{    B {-}{-}\textgreater{} D[પાછળ ઉમેરો]}
\NormalTok{    C {-}{-}\textgreater{} E[આગળથી દૂર કરો]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ ક્યુ પરના એનક્યુ અને ડીક્યુ ઓપરેશન્સને દર્શાવે છે.

\hypertarget{question-2cor-convert-expression-abcd-to-postfix-and-evaluate-postfix-expression-using-stack-assuming-some-values-for-a-b-c-and-d.-07-marks}{%
\subsubsection{Question 2(cOR): Convert expression A+B/C+D to postfix
and evaluate postfix expression using stack assuming some values for A,
B, C and D. (07
marks)}\label{question-2cor-convert-expression-abcd-to-postfix-and-evaluate-postfix-expression-using-stack-assuming-some-values-for-a-b-c-and-d.-07-marks}}

\textbf{Ans 2(cOR):}

Let's break this down into two parts: converting the infix expression to
postfix, and then evaluating the postfix expression.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Converting A+B/C+D to postfix:
\end{enumerate}

Step 1: Use the following precedence rules: - `+' and `-' have lower
precedence - '*' and `/' have higher precedence - Left to right
associativity for operators with equal precedence

Step 2: Scan the infix expression from left to right: A → output: A + →
push to stack: + B → output: AB / → push to stack: /+ C → output: ABC +
→ pop and output /, pop and output +, push + D → output: ABC/+D

Step 3: Pop remaining operators from the stack: Final postfix
expression: ABC/+D+

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Evaluating the postfix expression:
\end{enumerate}

Let's assume the following values: A = 5, B = 10, C = 2, D = 3

We'll use a stack to evaluate the postfix expression:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ evaluate\_postfix(expression, values):}
\NormalTok{    stack }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ char }\KeywordTok{in}\NormalTok{ expression:}
        \ControlFlowTok{if}\NormalTok{ char }\KeywordTok{in}\NormalTok{ values:}
\NormalTok{            stack.append(values[char])}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            b }\OperatorTok{=}\NormalTok{ stack.pop()}
\NormalTok{            a }\OperatorTok{=}\NormalTok{ stack.pop()}
            \ControlFlowTok{if}\NormalTok{ char }\OperatorTok{==} \StringTok{\textquotesingle{}+\textquotesingle{}}\NormalTok{:}
\NormalTok{                stack.append(a }\OperatorTok{+}\NormalTok{ b)}
            \ControlFlowTok{elif}\NormalTok{ char }\OperatorTok{==} \StringTok{\textquotesingle{}/\textquotesingle{}}\NormalTok{:}
\NormalTok{                stack.append(a }\OperatorTok{/}\NormalTok{ b)}
    \ControlFlowTok{return}\NormalTok{ stack.pop()}

\NormalTok{values }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{: }\DecValTok{5}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{: }\DecValTok{10}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{: }\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{: }\DecValTok{3}\NormalTok{\}}
\NormalTok{postfix }\OperatorTok{=} \StringTok{"ABC/+D+"}
\NormalTok{result }\OperatorTok{=}\NormalTok{ evaluate\_postfix(postfix, values)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Result: }\SpecialCharTok{\{}\NormalTok{result}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Evaluation steps: 1. Push 5 (A) 2. Push 10 (B) 3. Push 2 (C) 4. Pop 2,
Pop 10, Divide: 10/2 = 5, Push 5 5. Pop 5, Pop 5, Add: 5+5 = 10, Push 10
6. Push 3 (D) 7. Pop 3, Pop 10, Add: 10+3 = 13

Final result: 13

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Convert to Postfix]}
\NormalTok{    B {-}{-}\textgreater{} C[ABC/+D+]}
\NormalTok{    C {-}{-}\textgreater{} D[Evaluate Postfix]}
\NormalTok{    D {-}{-}\textgreater{} E[Push 5 A]}
\NormalTok{    E {-}{-}\textgreater{} F[Push 10 B]}
\NormalTok{    F {-}{-}\textgreater{} G[Push 2 C]}
\NormalTok{    G {-}{-}\textgreater{} H[Divide B/C]}
\NormalTok{    H {-}{-}\textgreater{} I[Add A + B/C]}
\NormalTok{    I {-}{-}\textgreater{} J[Push 3 D]}
\NormalTok{    J {-}{-}\textgreater{} K[Add Result + D]}
\NormalTok{    K {-}{-}\textgreater{} L[Final Result: 13]}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa95or-abcd-uxaaauxaa6-uxaa8-uxaaauxab8uxa9fuxaabuxa95uxab7-uxaae-uxaabuxab0uxab5-uxa85uxaa8-uxab8uxa9fuxa95-uxaa8-uxa89uxaaauxaafuxa97-uxa95uxab0uxaa8-abc-uxa85uxaa8-d-uxaa8-uxa95uxa87-uxa95uxaaeuxaa4-uxaa7uxab0uxaa8-uxa8fuxaa8-uxaaeuxab2uxaaf-uxab6uxaa7.-uxae6uxaed}{%
\subsubsection{પ્રશ્ન 2(કOR): A+B/C+D પદ ને પોસ્ટફીક્ષ મા ફેરવો અને સ્ટેક નો
ઉપયોગ કરીને A,B,C અને D ની કોઇ કિમત ધારીને એનુ મુલ્ય શોધો.
(૦૭)}\label{uxaaauxab0uxab6uxaa8-2uxa95or-abcd-uxaaauxaa6-uxaa8-uxaaauxab8uxa9fuxaabuxa95uxab7-uxaae-uxaabuxab0uxab5-uxa85uxaa8-uxab8uxa9fuxa95-uxaa8-uxa89uxaaauxaafuxa97-uxa95uxab0uxaa8-abc-uxa85uxaa8-d-uxaa8-uxa95uxa87-uxa95uxaaeuxaa4-uxaa7uxab0uxaa8-uxa8fuxaa8-uxaaeuxab2uxaaf-uxab6uxaa7.-uxae6uxaed}}

\textbf{જવાબ 2(કOR):}

આ પ્રશ્નને બે ભાગમાં વિભાજિત કરીએ: ઇનફિક્સ અભિવ્યક્તિને પોસ્ટફિક્સમાં રૂપાંતરિત કરવી
અને પછી પોસ્ટફિક્સ અભિવ્યક્તિનું મૂલ્યાંકન કરવું.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A+B/C+D ને પોસ્ટફિક્સમાં રૂપાંતરિત કરવું:
\end{enumerate}

પગલું 1: નીચેના પ્રાધાન્યતા નિયમોનો ઉપયોગ કરો: - `+' અને `-' ને ઓછી પ્રાધાન્યતા -
'*' અને `/' ને ઉચ્ચ પ્રાધાન્યતા - સમાન પ્રાધાન્યતા વાળા ઓપરેટર્સ માટે ડાબેથી જમણે
સંકલન

પગલું 2: ઇનફિક્સ અભિવ્યક્તિને ડાબેથી જમણે સ્કેન કરો: A → આઉટપુટ: A + → સ્ટેકમાં પુશ
કરો: + B → આઉટપુટ: AB / → સ્ટેકમાં પુશ કરો: /+ C → આઉટપુટ: ABC + → પોપ કરો અને
/ આઉટપુટ કરો, પોપ કરો અને + આઉટપુટ કરો, + પુશ કરો D → આઉટપુટ: ABC/+D

પગલું 3: સ્ટેકમાંથી બાકીના ઓપરેટર્સને પોપ કરો: અંતિમ પોસ્ટફિક્સ અભિવ્યક્તિ: ABC/+D+

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  પોસ્ટફિક્સ અભિવ્યક્તિનું મૂલ્યાંકન:
\end{enumerate}

ચાલો નીચેની કિંમતો ધારીએ: A = 5, B = 10, C = 2, D = 3

આપણે પોસ્ટફિક્સ અભિવ્યક્તિનું મૂલ્યાંકન કરવા માટે સ્ટેકનો ઉપયોગ કરીશું:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ evaluate\_postfix(expression, values):}
\NormalTok{    stack }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ char }\KeywordTok{in}\NormalTok{ expression:}
        \ControlFlowTok{if}\NormalTok{ char }\KeywordTok{in}\NormalTok{ values:}
\NormalTok{            stack.append(values[char])}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            b }\OperatorTok{=}\NormalTok{ stack.pop()}
\NormalTok{            a }\OperatorTok{=}\NormalTok{ stack.pop()}
            \ControlFlowTok{if}\NormalTok{ char }\OperatorTok{==} \StringTok{\textquotesingle{}+\textquotesingle{}}\NormalTok{:}
\NormalTok{                stack.append(a }\OperatorTok{+}\NormalTok{ b)}
            \ControlFlowTok{elif}\NormalTok{ char }\OperatorTok{==} \StringTok{\textquotesingle{}/\textquotesingle{}}\NormalTok{:}
\NormalTok{                stack.append(a }\OperatorTok{/}\NormalTok{ b)}
    \ControlFlowTok{return}\NormalTok{ stack.pop()}

\NormalTok{values }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{: }\DecValTok{5}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{: }\DecValTok{10}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{: }\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{: }\DecValTok{3}\NormalTok{\}}
\NormalTok{postfix }\OperatorTok{=} \StringTok{"ABC/+D+"}
\NormalTok{result }\OperatorTok{=}\NormalTok{ evaluate\_postfix(postfix, values)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"પરિણામ: }\SpecialCharTok{\{}\NormalTok{result}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

મૂલ્યાંકન પગલાં: 1. 5 પુશ કરો (A) 2. 10 પુશ કરો (B) 3. 2 પુશ કરો (C) 4. 2 પોપ
કરો, 10 પોપ કરો, ભાગાકાર: 10/2 = 5, 5 પુશ કરો 5. 5 પોપ કરો, 5 પોપ કરો,
સરવાળો: 5+5 = 10, 10 પુશ કરો 6. 3 પુશ કરો (D) 7. 3 પોપ કરો, 10 પોપ કરો,
સરવાળો: 10+3 = 13

અંતિમ પરિણામ: 13

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[પોસ્ટફિક્સમાં રૂપાંતર]}
\NormalTok{    B {-}{-}\textgreater{} C[ABC/+D+]}
\NormalTok{    C {-}{-}\textgreater{} D[પોસ્ટફિક્સનું મૂલ્યાંકન]}
\NormalTok{    D {-}{-}\textgreater{} E[5 પુશ કરો A]}
\NormalTok{    E {-}{-}\textgreater{} F[10 પુશ કરો B]}
\NormalTok{    F {-}{-}\textgreater{} G[2 પુશ કરો C]}
\NormalTok{    G {-}{-}\textgreater{} H[B/C ભાગાકાર]}
\NormalTok{    H {-}{-}\textgreater{} I[A + B/C સરવાળો]}
\NormalTok{    I {-}{-}\textgreater{} J[3 પુશ કરો D]}
\NormalTok{    J {-}{-}\textgreater{} K[પરિણામ + D સરવાળો]}
\NormalTok{    K {-}{-}\textgreater{} L[અંતિમ પરિણામ: 13]}
\end{Highlighting}
\end{Shaded}

\hypertarget{question-3a-enlist-applications-of-linked-list.-03-marks}{%
\subsubsection{Question 3(a): Enlist applications of Linked List. (03
marks)}\label{question-3a-enlist-applications-of-linked-list.-03-marks}}

\textbf{Ans 3(a):} Linked Lists are versatile data structures with
numerous applications in computer science and software development. Here
are some key applications of Linked Lists:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Dynamic Memory Allocation:}

  \begin{itemize}
  \tightlist
  \item
    Used in memory management systems for efficient allocation and
    deallocation of memory blocks.
  \end{itemize}
\item
  \textbf{Implementation of Other Data Structures:}

  \begin{itemize}
  \tightlist
  \item
    Serves as a building block for more complex data structures like:

    \begin{itemize}
    \tightlist
    \item
      Stacks
    \item
      Queues
    \item
      Hash tables (for handling collisions)
    \end{itemize}
  \end{itemize}
\item
  \textbf{Undo Functionality in Applications:}

  \begin{itemize}
  \tightlist
  \item
    Maintains a history of operations in software applications, enabling
    undo/redo features.
  \end{itemize}
\item
  \textbf{Symbol Table Management in Compiler Design:}

  \begin{itemize}
  \tightlist
  \item
    Stores and manages symbol information during the compilation
    process.
  \end{itemize}
\item
  \textbf{Polynomial Arithmetic:}

  \begin{itemize}
  \tightlist
  \item
    Represents and manipulates polynomials in mathematical software.
  \end{itemize}
\item
  \textbf{Image Viewer Applications:}

  \begin{itemize}
  \tightlist
  \item
    Implements image galleries with efficient navigation between images.
  \end{itemize}
\item
  \textbf{Music Player Playlists:}

  \begin{itemize}
  \tightlist
  \item
    Manages and navigates through song lists in media players.
  \end{itemize}
\item
  \textbf{Browser History:}

  \begin{itemize}
  \tightlist
  \item
    Implements forward and backward navigation in web browsers.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Linked List Applications] {-}{-}\textgreater{} B[Dynamic Memory Allocation]}
\NormalTok{    A {-}{-}\textgreater{} C[Implementation of Other Data Structures]}
\NormalTok{    A {-}{-}\textgreater{} D[Undo Functionality]}
\NormalTok{    A {-}{-}\textgreater{} E[Symbol Table Management]}
\NormalTok{    A {-}{-}\textgreater{} F[Polynomial Arithmetic]}
\NormalTok{    A {-}{-}\textgreater{} G[Image Viewer Applications]}
\NormalTok{    A {-}{-}\textgreater{} H[Music Player Playlists]}
\NormalTok{    A {-}{-}\textgreater{} I[Browser History]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the various applications of Linked Lists across
different domains in computer science and software development.

\hypertarget{uxaaauxab0uxab6uxaa8-3uxa85-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa89uxaaauxaafuxa97-uxab2uxa96.-uxae6uxae9}{%
\subsubsection{પ્રશ્ન 3(અ): લિંક્ડ લિસ્ટ ના ઉપયોગો લખો.
(૦૩)}\label{uxaaauxab0uxab6uxaa8-3uxa85-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa89uxaaauxaafuxa97-uxab2uxa96.-uxae6uxae9}}

\textbf{જવાબ 3(અ):} લિંક્ડ લિસ્ટ્સ એ કમ્પ્યુટર સાયન્સ અને સોફ્ટવેર ડેવલપમેન્ટમાં અનેક
ઉપયોગો ધરાવતા બહુમુખી ડેટા સ્ટ્રક્ચર્સ છે. અહીં લિંક્ડ લિસ્ટ્સના કેટલાક મુખ્ય ઉપયોગો
આપેલા છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{ડાયનેમિક મેમરી એલોકેશન:}

  \begin{itemize}
  \tightlist
  \item
    મેમરી બ્લોક્સના કાર્યક્ષમ એલોકેશન અને ડિએલોકેશન માટે મેમરી મેનેજમેન્ટ સિસ્ટમ્સમાં
    ઉપયોગમાં લેવાય છે.
  \end{itemize}
\item
  \textbf{અન્ય ડેટા સ્ટ્રક્ચર્સનું અમલીકરણ:}

  \begin{itemize}
  \tightlist
  \item
    વધુ જટિલ ડેટા સ્ટ્રક્ચર્સ માટે બિલ્ડિંગ બ્લોક તરીકે સેવા આપે છે, જેમ કે:

    \begin{itemize}
    \tightlist
    \item
      સ્ટેક્સ
    \item
      ક્યૂઝ
    \item
      હેશ ટેબલ્સ (કોલિઝન્સ હેન્ડલ કરવા માટે)
    \end{itemize}
  \end{itemize}
\item
  \textbf{એપ્લિકેશન્સમાં અનડુ ફંક્શનાલિટી:}

  \begin{itemize}
  \tightlist
  \item
    સોફ્ટવેર એપ્લિકેશન્સમાં ઓપરેશન્સનો ઇતિહાસ જાળવે છે, જે અનડુ/રીડુ સુવિધાઓને સક્ષમ કરે
    છે.
  \end{itemize}
\item
  \textbf{કમ્પાઇલર ડિઝાઇનમાં સિમ્બોલ ટેબલ મેનેજમેન્ટ:}

  \begin{itemize}
  \tightlist
  \item
    કમ્પાઇલેશન પ્રક્રિયા દરમિયાન સિમ્બોલ માહિતીને સંગ્રહિત અને સંચાલિત કરે છે.
  \end{itemize}
\item
  \textbf{પોલિનોમિયલ અંકગણિત:}

  \begin{itemize}
  \tightlist
  \item
    ગણિતશાસ્ત્ર સોફ્ટવેરમાં પોલિનોમિયલ્સનું પ્રતિનિધિત્વ અને અમલીકરણ કરે છે.
  \end{itemize}
\item
  \textbf{ઇમેજ વ્યૂઅર એપ્લિકેશન્સ:}

  \begin{itemize}
  \tightlist
  \item
    ઇમેજ ગેલેરીઓને કાર્યક્ષમ નેવિગેશન સાથે અમલમાં મૂકે છે.
  \end{itemize}
\item
  \textbf{મ્યુઝિક પ્લેયર પ્લેલિસ્ટ્સ:}

  \begin{itemize}
  \tightlist
  \item
    મીડિયા પ્લેયર્સમાં ગીતોની યાદીઓનું સંચાલન અને નેવિગેશન કરે છે.
  \end{itemize}
\item
  \textbf{બ્રાઉઝર હિસ્ટ્રી:}

  \begin{itemize}
  \tightlist
  \item
    વેબ બ્રાઉઝર્સમાં આગળ અને પાછળ નેવિગેશનનો અમલ કરે છે.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[લિંક્ડ લિસ્ટ ઉપયોગો] {-}{-}\textgreater{} B[ડાયનેમિક મેમરી એલોકેશન]}
\NormalTok{    A {-}{-}\textgreater{} C[અન્ય ડેટા સ્ટ્રક્ચર્સનું અમલીકરણ]}
\NormalTok{    A {-}{-}\textgreater{} D[અનડુ ફંક્શનાલિટી]}
\NormalTok{    A {-}{-}\textgreater{} E[સિમ્બોલ ટેબલ મેનેજમેન્ટ]}
\NormalTok{    A {-}{-}\textgreater{} F[પોલિનોમિયલ અંકગણિત]}
\NormalTok{    A {-}{-}\textgreater{} G[ઇમેજ વ્યૂઅર એપ્લિકેશન્સ]}
\NormalTok{    A {-}{-}\textgreater{} H[મ્યુઝિક પ્લેયર પ્લેલિસ્ટ્સ]}
\NormalTok{    A {-}{-}\textgreater{} I[બ્રાઉઝર હિસ્ટ્રી]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ કમ્પ્યુટર સાયન્સ અને સોફ્ટવેર ડેવલપમેન્ટના વિવિધ ક્ષેત્રોમાં લિંક્ડ લિસ્ટ્સના વિવિધ
ઉપયોગોને દર્શાવે છે.

\hypertarget{question-3b-explain-creation-of-singly-linked-list-in-python.-04-marks}{%
\subsubsection{Question 3(b): Explain creation of singly linked list in
Python. (04
marks)}\label{question-3b-explain-creation-of-singly-linked-list-in-python.-04-marks}}

\textbf{Ans 3(b):} Creating a singly linked list in Python involves
defining two main components: a Node class and a LinkedList class.
Here's a step-by-step explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define the Node class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

  This class represents individual nodes in the list, containing data
  and a reference to the next node.
\item
  Define the LinkedList class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

  This class represents the linked list itself, with a head pointer to
  the first node.
\item
  Implement methods to add nodes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ append(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}
        \ControlFlowTok{return}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}
\end{Highlighting}
\end{Shaded}

  This method adds a new node to the end of the list.
\item
  Implement a method to display the list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current:}
        \BuiltInTok{print}\NormalTok{(current.data, end}\OperatorTok{=}\StringTok{" {-}\textgreater{} "}\NormalTok{)}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"None"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  This method prints the contents of the list.
\end{enumerate}

Example usage:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Create a linked list}
\NormalTok{my\_list }\OperatorTok{=}\NormalTok{ LinkedList()}

\CommentTok{\# Add elements}
\NormalTok{my\_list.append(}\DecValTok{1}\NormalTok{)}
\NormalTok{my\_list.append(}\DecValTok{2}\NormalTok{)}
\NormalTok{my\_list.append(}\DecValTok{3}\NormalTok{)}

\CommentTok{\# Display the list}
\NormalTok{my\_list.display()  }\CommentTok{\# Output: 1 {-}\textgreater{} 2 {-}\textgreater{} 3 {-}\textgreater{} None}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[None]}
\NormalTok{    B {-}{-}data{-}{-}\textgreater{} F[1]}
\NormalTok{    C {-}{-}data{-}{-}\textgreater{} G[2]}
\NormalTok{    D {-}{-}data{-}{-}\textgreater{} H[3]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the structure of the created singly linked
list.

\hypertarget{uxaaauxab0uxab6uxaa8-3uxaac-uxaaauxaafuxaa5uxaa8uxaae-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxa95uxab5-uxab0uxaa4-uxaacuxaa8uxab5-uxab6uxa95uxaaf-uxa8f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}{%
\subsubsection{પ્રશ્ન 3(બ): પાયથનમા સિંગ્લી લિંક્ડ લિસ્ટ કેવી રીતે બનાવી શકાય એ
સમજાવો.
(૦૪)}\label{uxaaauxab0uxab6uxaa8-3uxaac-uxaaauxaafuxaa5uxaa8uxaae-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxa95uxab5-uxab0uxaa4-uxaacuxaa8uxab5-uxab6uxa95uxaaf-uxa8f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}}

\textbf{જવાબ 3(બ):} પાયથનમાં સિંગ્લી લિંક્ડ લિસ્ટ બનાવવા માટે બે મુખ્ય ઘટકો
વ્યાખ્યાયિત કરવાની જરૂર પડે છે: Node ક્લાસ અને LinkedList ક્લાસ. અહીં પગલાવાર
સમજૂતી આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Node ક્લાસ વ્યાખ્યાયિત કરો:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

  આ ક્લાસ લિસ્ટમાં વ્યક્તિગત નોડ્સનું પ્રતિનિધિત્વ કરે છે, જેમાં ડેટા અને આગળના નોડનો
  સંદર્ભ હોય છે.
\item
  LinkedList ક્લાસ વ્યાખ્યાયિત કરો:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

  આ ક્લાસ લિંક્ડ લિસ્ટ પોતેનું પ્રતિનિધિત્વ કરે છે, જેમાં પ્રથમ નોડ તરફ પોઇન્ટ કરતું head
  પોઇન્ટર હોય છે.
\item
  નોડ્સ ઉમેરવા માટેની પદ્ધતિઓ અમલમાં મૂકો:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ append(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}
        \ControlFlowTok{return}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}
\end{Highlighting}
\end{Shaded}

  આ પદ્ધતિ લિસ્ટના અંતે નવો નોડ ઉમેરે છે.
\item
  લિસ્ટ પ્રદર્શિત કરવા માટેની પદ્ધતિ અમલમાં મૂકો:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current:}
        \BuiltInTok{print}\NormalTok{(current.data, end}\OperatorTok{=}\StringTok{" {-}\textgreater{} "}\NormalTok{)}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"None"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  આ પદ્ધતિ લિસ્ટની સામગ્રી પ્રિન્ટ કરે છે.
\end{enumerate}

ઉપયોગનું ઉદાહરણ:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# લિંક્ડ લિસ્ટ બનાવો}
\NormalTok{my\_list }\OperatorTok{=}\NormalTok{ LinkedList()}

\CommentTok{\# તત્વો ઉમેરો}
\NormalTok{my\_list.append(}\DecValTok{1}\NormalTok{)}
\NormalTok{my\_list.append(}\DecValTok{2}\NormalTok{)}
\NormalTok{my\_list.append(}\DecValTok{3}\NormalTok{)}

\CommentTok{\# લિસ્ટ પ્રદર્શિત કરો}
\NormalTok{my\_list.display()  }\CommentTok{\# આઉટપુટ: 1 {-}\textgreater{} 2 {-}\textgreater{} 3 {-}\textgreater{} None}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[None]}
\NormalTok{    B {-}{-}data{-}{-}\textgreater{} F[1]}
\NormalTok{    C {-}{-}data{-}{-}\textgreater{} G[2]}
\NormalTok{    D {-}{-}data{-}{-}\textgreater{} H[3]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બનાવેલ સિંગ્લી લિંક્ડ લિસ્ટની રચનાને દર્શાવે છે.

\hypertarget{question-3c-write-a-code-to-insert-a-new-node-at-the-beginning-and-end-of-singly-linked-list.-07-marks}{%
\subsubsection{Question 3(c): Write a code to insert a new node at the
beginning and end of singly linked list. (07
marks)}\label{question-3c-write-a-code-to-insert-a-new-node-at-the-beginning-and-end-of-singly-linked-list.-07-marks}}

\textbf{Ans 3(c):} Let's create a Python implementation of a singly
linked list with methods to insert nodes at the beginning and end of the
list.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ insert\_at\_beginning(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{        new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
\NormalTok{        new\_node.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}

    \KeywordTok{def}\NormalTok{ insert\_at\_end(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{        new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
        \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
            \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}
            \ControlFlowTok{return}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{        current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}

    \KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current:}
            \BuiltInTok{print}\NormalTok{(current.data, end}\OperatorTok{=}\StringTok{" {-}\textgreater{} "}\NormalTok{)}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"None"}\NormalTok{)}

\CommentTok{\# Example usage}
\NormalTok{linked\_list }\OperatorTok{=}\NormalTok{ LinkedList()}

\CommentTok{\# Insert at the beginning}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{3}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{2}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{1}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"After inserting at the beginning:"}\NormalTok{)}
\NormalTok{linked\_list.display()}

\CommentTok{\# Insert at the end}
\NormalTok{linked\_list.insert\_at\_end(}\DecValTok{4}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_end(}\DecValTok{5}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"After inserting at the end:"}\NormalTok{)}
\NormalTok{linked\_list.display()}
\end{Highlighting}
\end{Shaded}

Explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Node} class: Represents a single node in the linked list.
\item
  \texttt{LinkedList} class: Represents the entire linked list.
\item
  \texttt{insert\_at\_beginning} method:

  \begin{itemize}
  \tightlist
  \item
    Creates a new node
  \item
    Sets the new node's next pointer to the current head
  \item
    Updates the head to point to the new node
  \end{itemize}
\item
  \texttt{insert\_at\_end} method:

  \begin{itemize}
  \tightlist
  \item
    Creates a new node
  \item
    If the list is empty, sets the head to the new node
  \item
    Otherwise, traverses to the end of the list and adds the new node
  \end{itemize}
\item
  \texttt{display} method: Prints the entire list.
\end{enumerate}

Output:

\begin{verbatim}
After inserting at the beginning:
1 -> 2 -> 3 -> None
After inserting at the end:
1 -> 2 -> 3 -> 4 -> 5 -> None
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[1]}
\NormalTok{    B {-}{-}\textgreater{} C[2]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[4]}
\NormalTok{    E {-}{-}\textgreater{} F[5]}
\NormalTok{    F {-}{-}\textgreater{} G[None]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the final state of the linked list after
insertions at both the beginning and end.

\hypertarget{uxaaauxab0uxab6uxaa8-3uxa95-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxab6uxab0uxa86uxaa4uxaae-uxa85uxaa8-uxa85uxaa4uxaae-uxaa8uxab5-uxaa8uxaa1-uxa89uxaaeuxab0uxab5uxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxaed}{%
\subsubsection{પ્રશ્ન 3(ક): સિંગ્લી લિંક્ડ લિસ્ટ ની શરૂઆતમાં અને અંતમાં નવા નોડ
ઉમેરવાનો કોડ લખો.
(૦૭)}\label{uxaaauxab0uxab6uxaa8-3uxa95-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxab6uxab0uxa86uxaa4uxaae-uxa85uxaa8-uxa85uxaa4uxaae-uxaa8uxab5-uxaa8uxaa1-uxa89uxaaeuxab0uxab5uxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxaed}}

\textbf{જવાબ 3(ક):} ચાલો સિંગ્લી લિંક્ડ લિસ્ટનું પાયથન અમલીકરણ બનાવીએ જેમાં
લિસ્ટની શરૂઆત અને અંતમાં નોડ્સ ઉમેરવાની પદ્ધતિઓ હોય.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ insert\_at\_beginning(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{        new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
\NormalTok{        new\_node.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}

    \KeywordTok{def}\NormalTok{ insert\_at\_end(}\VariableTok{self}\NormalTok{, data):}
\NormalTok{        new\_node }\OperatorTok{=}\NormalTok{ Node(data)}
        \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
            \VariableTok{self}\NormalTok{.head }\OperatorTok{=}\NormalTok{ new\_node}
            \ControlFlowTok{return}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{        current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}

    \KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current:}
            \BuiltInTok{print}\NormalTok{(current.data, end}\OperatorTok{=}\StringTok{" {-}\textgreater{} "}\NormalTok{)}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"None"}\NormalTok{)}

\CommentTok{\# ઉપયોગનું ઉદાહરણ}
\NormalTok{linked\_list }\OperatorTok{=}\NormalTok{ LinkedList()}

\CommentTok{\# શરૂઆતમાં ઉમેરો}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{3}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{2}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_beginning(}\DecValTok{1}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"શરૂઆતમાં ઉમેર્યા પછી:"}\NormalTok{)}
\NormalTok{linked\_list.display()}

\CommentTok{\# અંતમાં ઉમેરો}
\NormalTok{linked\_list.insert\_at\_end(}\DecValTok{4}\NormalTok{)}
\NormalTok{linked\_list.insert\_at\_end(}\DecValTok{5}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"અંતમાં ઉમેર્યા પછી:"}\NormalTok{)}
\NormalTok{linked\_list.display()}
\end{Highlighting}
\end{Shaded}

સમજૂતી:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Node} ક્લાસ: લિંક્ડ લિસ્ટમાં એક નોડનું પ્રતિનિધિત્વ કરે છે.
\item
  \texttt{LinkedList} ક્લાસ: સમગ્ર લિંક્ડ લિસ્ટનું પ્રતિનિધિત્વ કરે છે.
\item
  \texttt{insert\_at\_beginning} પદ્ધતિ:

  \begin{itemize}
  \tightlist
  \item
    નવો નોડ બનાવે છે
  \item
    નવા નોડના next પોઇન્ટરને વર્તમાન head પર સેટ કરે છે
  \item
    head ને અપડેટ કરીને નવા નોડ તરફ પોઇન્ટ કરાવે છે
  \end{itemize}
\item
  \texttt{insert\_at\_end} પદ્ધતિ:

  \begin{itemize}
  \tightlist
  \item
    નવો નોડ બનાવે છે
  \item
    જો લિસ્ટ ખાલી હોય, તો head ને નવા નોડ પર સેટ કરે છે
  \item
    અન્યથા, લિસ્ટના અંત સુધી જાય છે અને નવો નોડ ઉમેરે છે
  \end{itemize}
\item
  \texttt{display} પદ્ધતિ: સમગ્ર લિસ્ટને પ્રિન્ટ કરે છે.
\end{enumerate}

આઉટપુટ:

\begin{verbatim}
શરૂઆતમાં ઉમેર્યા પછી:
1 -> 2 -> 3 -> None
અંતમાં ઉમેર્યા પછી:
1 -> 2 -> 3 -> 4 -> 5 -> None
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[1]}
\NormalTok{    B {-}{-}\textgreater{} C[2]}
\NormalTok{    C {-}{-}\textgreater{} D[3]}
\NormalTok{    D {-}{-}\textgreater{} E[4]}
\NormalTok{    E {-}{-}\textgreater{} F[5]}
\NormalTok{    F {-}{-}\textgreater{} G[None]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ શરૂઆત અને અંત બંને પર ઉમેરણી પછી લિંક્ડ લિસ્ટની અંતિમ સ્થિતિને દર્શાવે છે.

\hypertarget{question-3aor-write-a-code-to-count-the-number-of-nodes-in-singly-linked-list.-03-marks}{%
\subsubsection{Question 3(aOR): Write a code to count the number of
nodes in singly linked list. (03
marks)}\label{question-3aor-write-a-code-to-count-the-number-of-nodes-in-singly-linked-list.-03-marks}}

\textbf{Ans 3(aOR):} Here's a Python implementation to count the number
of nodes in a singly linked list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ count\_nodes(}\VariableTok{self}\NormalTok{):}
\NormalTok{        count }\OperatorTok{=} \DecValTok{0}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current:}
\NormalTok{            count }\OperatorTok{+=} \DecValTok{1}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
        \ControlFlowTok{return}\NormalTok{ count}

\CommentTok{\# Example usage}
\NormalTok{linked\_list }\OperatorTok{=}\NormalTok{ LinkedList()}
\NormalTok{linked\_list.head }\OperatorTok{=}\NormalTok{ Node(}\DecValTok{1}\NormalTok{)}
\NormalTok{linked\_list.head.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ Node(}\DecValTok{2}\NormalTok{)}
\NormalTok{linked\_list.head.}\BuiltInTok{next}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ Node(}\DecValTok{3}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Number of nodes:"}\NormalTok{, linked\_list.count\_nodes())}
\end{Highlighting}
\end{Shaded}

Explanation: 1. We define a \texttt{Node} class to represent individual
nodes. 2. The \texttt{LinkedList} class has a \texttt{count\_nodes}
method that: - Initializes a counter to 0. - Traverses the list from the
head. - Increments the counter for each node. - Returns the final count.

Output:

\begin{verbatim}
Number of nodes: 3
\end{verbatim}

\hypertarget{uxaaauxab0uxab6uxaa8-3uxa85or-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxaae-uxab0uxab9uxab2-uxaa8uxaa1-uxaa8-uxab8uxa96uxaaf-uxa97uxaa3uxab5-uxaaeuxa9fuxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxae9}{%
\subsubsection{પ્રશ્ન 3(અOR): સિંગ્લી લિંક્ડ મા રહેલ નોડ ની સંખ્યા ગણવા માટેનો કોડ
લખો.
(૦૩)}\label{uxaaauxab0uxab6uxaa8-3uxa85or-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxaae-uxab0uxab9uxab2-uxaa8uxaa1-uxaa8-uxab8uxa96uxaaf-uxa97uxaa3uxab5-uxaaeuxa9fuxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxae9}}

\textbf{જવાબ 3(અOR):} અહીં સિંગ્લી લિંક્ડ લિસ્ટમાં નોડની સંખ્યા ગણવા માટેનું પાયથન
અમલીકરણ આપેલું છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ LinkedList:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ count\_nodes(}\VariableTok{self}\NormalTok{):}
\NormalTok{        count }\OperatorTok{=} \DecValTok{0}
\NormalTok{        current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \ControlFlowTok{while}\NormalTok{ current:}
\NormalTok{            count }\OperatorTok{+=} \DecValTok{1}
\NormalTok{            current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
        \ControlFlowTok{return}\NormalTok{ count}

\CommentTok{\# ઉપયોગનું ઉદાહરણ}
\NormalTok{linked\_list }\OperatorTok{=}\NormalTok{ LinkedList()}
\NormalTok{linked\_list.head }\OperatorTok{=}\NormalTok{ Node(}\DecValTok{1}\NormalTok{)}
\NormalTok{linked\_list.head.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ Node(}\DecValTok{2}\NormalTok{)}
\NormalTok{linked\_list.head.}\BuiltInTok{next}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ Node(}\DecValTok{3}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"નોડની સંખ્યા:"}\NormalTok{, linked\_list.count\_nodes())}
\end{Highlighting}
\end{Shaded}

સમજૂતી: 1. આપણે વ્યક્તિગત નોડ્સનું પ્રતિનિધિત્વ કરવા માટે \texttt{Node} ક્લાસ
વ્યાખ્યાયિત કરીએ છીએ. 2. \texttt{LinkedList} ક્લાસમાં \texttt{count\_nodes}
પદ્ધતિ છે જે: - કાઉન્ટરને 0થી શરૂ કરે છે. - હેડથી શરૂ કરીને લિસ્ટને ટ્રાવર્સ કરે છે. -
દરેક નોડ માટે કાઉન્ટરને વધારે છે. - અંતિમ ગણતરી પરત કરે છે.

આઉટપુટ:

\begin{verbatim}
નોડની સંખ્યા: 3
\end{verbatim}

Here are the correct matches for both the English and Gujarati versions
of the question:

\hypertarget{question-3bor-match-appropriate-options-from-column-a-and-b-04-marks}{%
\subsubsection{Question 3(bOR): Match appropriate options from column A
and B (04
marks)}\label{question-3bor-match-appropriate-options-from-column-a-and-b-04-marks}}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7143}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Column A
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Column B
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Singly Linked List & a. Basic unit containing data and references \\
2. Doubly Linked List & b. Nodes form a loop where the last node points
to the first node \\
3. Circular Linked List & c.~Nodes contain data and a reference to the
next node \\
4. Node in a Linked List & d.~Nodes contain data and references to both
the next and previous nodes \\
\end{longtable}

\textbf{Ans 3(bOR):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Singly Linked List - c.~Nodes contain data and a reference to the next
  node
\item
  Doubly Linked List - d.~Nodes contain data and references to both the
  next and previous nodes
\item
  Circular Linked List - b. Nodes form a loop where the last node points
  to the first node
\item
  Node in a Linked List - a. Basic unit containing data and references
\end{enumerate}

\hypertarget{uxaaauxab0uxab6uxaa8-3uxaacor-uxa95uxab2uxaae-uxa8f-uxa85uxaa8-uxa95uxab2uxaae-uxaac-uxaa8-uxaafuxa97uxaaf-uxab5uxa95uxab2uxaaa-uxa9cuxaa1.-uxae6uxaea}{%
\subsubsection{પ્રશ્ન 3(બOR): કોલમ એ અને કોલમ બી ના યોગ્ય વિકલ્પ જોડો.
(૦૪)}\label{uxaaauxab0uxab6uxaa8-3uxaacor-uxa95uxab2uxaae-uxa8f-uxa85uxaa8-uxa95uxab2uxaae-uxaac-uxaa8-uxaafuxa97uxaaf-uxab5uxa95uxab2uxaaa-uxa9cuxaa1.-uxae6uxaea}}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2895}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7105}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોલમ એ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
કોલમ બી
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. સિંગ્લી લિંક્ડ લિસ્ટ & a. મુળભુત એકમ કે જેમા ડેટા અને સંદર્ભ હોય. \\
2. ડબ્લી લિંક્ડ લિસ્ટ & b. નોડ્સ એક લૂપ બનાવે જેમા છેલ્લો નોડ પ્રથમ નોડ તરફ નિર્દેશ
કરે. \\
3. સર્ક્યુલર લિંક્ડ લિસ્ટ & c.~નોડ્સમાં ડેટા અને આગામી નોડનો સંદર્ભ હોય છે \\
4. લિંક્ડ લિસ્ટ નો એક નોડ & d.~નોડ્સમાં આગામી અને પાછલા બંને નોડ્સનો ડેટા અને સંદર્ભો
હોય છે \\
\end{longtable}

\textbf{જવાબ 3(bOR):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  સિંગ્લી લિંક્ડ લિસ્ટ - c.~નોડ્સમાં ડેટા અને આગામી નોડનો સંદર્ભ હોય છે
\item
  ડબ્લી લિંક્ડ લિસ્ટ - d.~નોડ્સમાં આગામી અને પાછલા બંને નોડ્સનો ડેટા અને સંદર્ભો હોય છે
\item
  સર્ક્યુલર લિંક્ડ લિસ્ટ - b. નોડ્સ એક લૂપ બનાવે જેમા છેલ્લો નોડ પ્રથમ નોડ તરફ નિર્દેશ
  કરે.
\item
  લિંક્ડ લિસ્ટ નો એક નોડ - a. મુળભુત એકમ કે જેમા ડેટા અને સંદર્ભ હોય.
\end{enumerate}

These matches correctly associate each type of linked list or component
with its defining characteristic.

\hypertarget{q3cor-explain-the-deletion-of-the-first-and-last-node-in-the-singly-linked-list.-07-marks}{%
\subsubsection{\texorpdfstring{Q3cOR: Explain the deletion of the first
and last node in the singly linked list. (\textbf{07
marks})}{Q3cOR: Explain the deletion of the first and last node in the singly linked list. (07 marks)}}\label{q3cor-explain-the-deletion-of-the-first-and-last-node-in-the-singly-linked-list.-07-marks}}

\textbf{Answer Q3cOR:}

In a singly linked list, deleting the first and last nodes requires
different approaches due to the list's structure. Let's examine both
cases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Deleting the First Node:

  \begin{itemize}
  \tightlist
  \item
    Set a temporary pointer to the current head.
  \item
    Move the head to point to the second node (head.next).
  \item
    Delete the temporary pointer to free memory.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ delete\_first\_node(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{if} \VariableTok{self}\NormalTok{.head:}
\NormalTok{        temp }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{self}\NormalTok{.head.}\BuiltInTok{next}
        \KeywordTok{del}\NormalTok{ temp}
\end{Highlighting}
\end{Shaded}
\item
  Deleting the Last Node:

  \begin{itemize}
  \tightlist
  \item
    If the list is empty or has only one node, set head to None.
  \item
    Otherwise, traverse the list until the second-to-last node.
  \item
    Set the next of the second-to-last node to None.
  \item
    Delete the last node to free memory.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ delete\_last\_node(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
        \ControlFlowTok{return}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head.}\BuiltInTok{next}\NormalTok{:}
        \KeywordTok{del} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}
        \ControlFlowTok{return}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    \KeywordTok{del}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Key points: - Deleting the first node is O(1) time complexity. -
Deleting the last node is O(n) time complexity, where n is the number of
nodes. - Always handle edge cases like empty lists or lists with only
one node. - Proper memory management is crucial to avoid memory leaks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Delete Node] {-}{-}\textgreater{} B\{First or Last?\}}
\NormalTok{    B {-}{-}\textgreater{}|First| C[Set temp to head]}
\NormalTok{    C {-}{-}\textgreater{} D[Move head to next node]}
\NormalTok{    D {-}{-}\textgreater{} E[Delete temp]}
\NormalTok{    B {-}{-}\textgreater{}|Last| F\{Empty list?\}}
\NormalTok{    F {-}{-}\textgreater{}|Yes| G[Return]}
\NormalTok{    F {-}{-}\textgreater{}|No| H\{Only one node?\}}
\NormalTok{    H {-}{-}\textgreater{}|Yes| I[Delete head, set to None]}
\NormalTok{    H {-}{-}\textgreater{}|No| J[Traverse to second{-}to{-}last]}
\NormalTok{    J {-}{-}\textgreater{} K[Set next to None]}
\NormalTok{    K {-}{-}\textgreater{} L[Delete last node]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the decision process and steps involved in
deleting the first and last nodes of a singly linked list.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{q3cor-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaae-uxaaauxab0uxaa5uxaae-uxa85uxaa8-uxa9buxab2uxab2-uxaa8uxaa1-uxaa8-uxa95uxaa2-uxaa8uxa96uxab5uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}{%
\subsubsection{\texorpdfstring{Q3cOR: સિંગ્લી લિંક્ડ લિસ્ટ મા પ્રથમ અને છેલ્લો
નોડ ને કાઢી નાખવાનુ સમજાવો.
(\textbf{૦૭})}{Q3cOR: સિંગ્લી લિંક્ડ લિસ્ટ મા પ્રથમ અને છેલ્લો નોડ ને કાઢી નાખવાનુ સમજાવો. (૦૭)}}\label{q3cor-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaae-uxaaauxab0uxaa5uxaae-uxa85uxaa8-uxa9buxab2uxab2-uxaa8uxaa1-uxaa8-uxa95uxaa2-uxaa8uxa96uxab5uxaa8-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}}

\textbf{જવાબ Q3cOR:}

સિંગ્લી લિંક્ડ લિસ્ટમાં પ્રથમ અને છેલ્લા નોડને કાઢી નાખવા માટે અલગ-અલગ પદ્ધતિઓની જરૂર
પડે છે. ચાલો બંને કેસ જોઈએ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  પ્રથમ નોડ કાઢી નાખવો:

  \begin{itemize}
  \tightlist
  \item
    વર્તમાન head માટે એક અસ્થાયી પોઈન્ટર સેટ કરો.
  \item
    head ને બીજા નોડ (head.next) પર પોઈન્ટ કરાવો.
  \item
    મેમરી મુક્ત કરવા માટે અસ્થાયી પોઈન્ટરને કાઢી નાખો.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ delete\_first\_node(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{if} \VariableTok{self}\NormalTok{.head:}
\NormalTok{        temp }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{self}\NormalTok{.head.}\BuiltInTok{next}
        \KeywordTok{del}\NormalTok{ temp}
\end{Highlighting}
\end{Shaded}
\item
  છેલ્લો નોડ કાઢી નાખવો:

  \begin{itemize}
  \tightlist
  \item
    જો લિસ્ટ ખાલી હોય અથવા માત્ર એક નોડ હોય, તો head ને None સેટ કરો.
  \item
    અન્યથા, છેલ્લાથી બીજા નોડ સુધી લિસ્ટને ટ્રેવર્સ કરો.
  \item
    છેલ્લાથી બીજા નોડના next ને None સેટ કરો.
  \item
    મેમરી મુક્ત કરવા માટે છેલ્લા નોડને કાઢી નાખો.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ delete\_last\_node(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head:}
        \ControlFlowTok{return}
    \ControlFlowTok{if} \KeywordTok{not} \VariableTok{self}\NormalTok{.head.}\BuiltInTok{next}\NormalTok{:}
        \KeywordTok{del} \VariableTok{self}\NormalTok{.head}
        \VariableTok{self}\NormalTok{.head }\OperatorTok{=} \VariableTok{None}
        \ControlFlowTok{return}
\NormalTok{    current }\OperatorTok{=} \VariableTok{self}\NormalTok{.head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    \KeywordTok{del}\NormalTok{ current.}\BuiltInTok{next}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

મુખ્ય મુદ્દાઓ: - પ્રથમ નોડ કાઢી નાખવાની સમય જટિલતા O(1) છે. - છેલ્લો નોડ કાઢી
નાખવાની સમય જટિલતા O(n) છે, જ્યાં n નોડ્સની સંખ્યા છે. - ખાલી લિસ્ટ અથવા માત્ર એક
નોડવાળી લિસ્ટ જેવા કિસ્સાઓને હંમેશા સંભાળવા જોઈએ. - મેમરી લીક ટાળવા માટે યોગ્ય
મેમરી મેનેજમેન્ટ મહત્વપૂર્ણ છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[નોડ કાઢી નાખો] {-}{-}\textgreater{} B\{પ્રથમ કે છેલ્લો?\}}
\NormalTok{    B {-}{-}\textgreater{}|પ્રથમ| C[temp ને head પર સેટ કરો]}
\NormalTok{    C {-}{-}\textgreater{} D[head ને આગળના નોડ પર ખસેડો]}
\NormalTok{    D {-}{-}\textgreater{} E[temp ને કાઢી નાખો]}
\NormalTok{    B {-}{-}\textgreater{}|છેલ્લો| F\{લિસ્ટ ખાલી છે?\}}
\NormalTok{    F {-}{-}\textgreater{}|હા| G[પાછા ફરો]}
\NormalTok{    F {-}{-}\textgreater{}|ના| H\{માત્ર એક નોડ છે?\}}
\NormalTok{    H {-}{-}\textgreater{}|હા| I[head કાઢી નાખો, None સેટ કરો]}
\NormalTok{    H {-}{-}\textgreater{}|ના| J[છેલ્લાથી બીજા સુધી જાઓ]}
\NormalTok{    J {-}{-}\textgreater{} K[next ને None સેટ કરો]}
\NormalTok{    K {-}{-}\textgreater{} L[છેલ્લો નોડ કાઢી નાખો]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ સિંગ્લી લિંક્ડ લિસ્ટમાં પ્રથમ અને છેલ્લા નોડને કાઢી નાખવાની પ્રક્રિયા અને
પગલાંઓને દર્શાવે છે.

\hypertarget{q4a-explain-concept-of-doubly-linked-list.-03-marks}{%
\subsubsection{Q4a: Explain concept of doubly linked list. (03
marks)}\label{q4a-explain-concept-of-doubly-linked-list.-03-marks}}

A doubly linked list is a type of linear data structure where each node
contains three components: 1. Data: Stores the actual value. 2. Next
pointer: Points to the next node in the sequence. 3. Previous pointer:
Points to the previous node in the sequence.

Key features: - Bidirectional traversal: Can be traversed both forward
and backward. - Dynamic size: Can grow or shrink at runtime. - Efficient
insertion/deletion: O(1) time complexity at both ends.

Structure of a node in Python:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.prev }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

Advantages: - Easy reversal of list - Efficient deletion of nodes - Can
be used to implement stacks and queues

Disadvantages: - More memory usage due to extra pointer - Slightly more
complex implementation

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Node 1] \textless{}{-}{-}\textgreater{} B[Node 2]}
\NormalTok{    B \textless{}{-}{-}\textgreater{} C[Node 3]}
\NormalTok{    C \textless{}{-}{-}\textgreater{} D[...]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the bidirectional nature of a doubly linked
list, showing how nodes are connected in both directions.

\hypertarget{q4a-uxaa1uxaacuxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}{%
\subsubsection{Q4a: ડબ્લી લિંક્ડ લિસ્ટ નો કોંસેપ્ટ સમજાવો.
(૦૩)}\label{q4a-uxaa1uxaacuxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}}

ડબલી લિંક્ડ લિસ્ટ એ એક પ્રકારનું લીનીયર ડેટા સ્ટ્રક્ચર છે જેમાં દરેક નોડમાં ત્રણ ઘટકો
હોય છે: 1. ડેટા: વાસ્તવિક મૂલ્ય સંગ્રહિત કરે છે. 2. આગળનો પોઇન્ટર: ક્રમમાં આગળના
નોડને નિર્દેશ કરે છે. 3. પાછળનો પોઇન્ટર: ક્રમમાં પાછલા નોડને નિર્દેશ કરે છે.

મુખ્ય લક્ષણો: - દ્વિદિશ ટ્રાવર્સલ: આગળ અને પાછળ બંને દિશામાં ટ્રાવર્સ કરી શકાય છે. -
ડાયનેમિક સાઇઝ: રનટાઇમ પર વધી અથવા ઘટી શકે છે. - કાર્યક્ષમ ઇન્સર્શન/ડિલીશન: બંને
છેડે O(1) સમય જટિલતા.

પાયથોનમાં નોડની રચના:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.prev }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

ફાયદાઓ: - લિસ્ટને સરળતાથી ઉલટાવી શકાય છે - નોડ્સનું કાર્યક્ષમ ડિલીશન - સ્ટેક્સ અને
ક્યૂઝ implement કરવા માટે વાપરી શકાય છે

ગેરફાયદાઓ: - વધારાના પોઇન્ટરને કારણે વધુ મેમરી વપરાશ - થોડું વધુ જટિલ અમલીકરણ

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[નોડ 1] \textless{}{-}{-}\textgreater{} B[નોડ 2]}
\NormalTok{    B \textless{}{-}{-}\textgreater{} C[નોડ 3]}
\NormalTok{    C \textless{}{-}{-}\textgreater{} D[...]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ ડબલી લિંક્ડ લિસ્ટની દ્વિદિશ પ્રકૃતિને દર્શાવે છે, જે બતાવે છે કે નોડ્સ બંને
દિશાઓમાં કેવી રીતે જોડાયેલા છે.

\hypertarget{q4b-explain-concept-of-linear-search.-04-marks}{%
\subsubsection{Q4b: Explain concept of linear search. (04
marks)}\label{q4b-explain-concept-of-linear-search.-04-marks}}

Linear search, also known as sequential search, is a simple searching
algorithm used to find a specific element in a list or array. Here's an
explanation of the concept:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Working Principle:

  \begin{itemize}
  \tightlist
  \item
    The algorithm checks each element in the list sequentially.
  \item
    It compares each element with the target value until a match is
    found or the end of the list is reached.
  \end{itemize}
\item
  Algorithm Steps:

  \begin{itemize}
  \tightlist
  \item
    Start from the first element of the list.
  \item
    Compare the current element with the target value.
  \item
    If they match, return the index of the current element.
  \item
    If not, move to the next element and repeat steps 2-3.
  \item
    If the end of the list is reached without finding a match, return -1
    or indicate the element is not found.
  \end{itemize}
\item
  Time Complexity:

  \begin{itemize}
  \tightlist
  \item
    Best Case: O(1) - when the target is the first element.
  \item
    Worst Case: O(n) - when the target is the last element or not in the
    list.
  \item
    Average Case: O(n) - on average, half the elements are checked.
  \end{itemize}
\item
  Implementation in Python:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ linear\_search(arr, target):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(arr)):}
        \ControlFlowTok{if}\NormalTok{ arr[i] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}
\item
  Advantages and Disadvantages:

  \begin{itemize}
  \tightlist
  \item
    Advantages: Simple to implement, works on unsorted lists.
  \item
    Disadvantages: Inefficient for large datasets.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Check Element]}
\NormalTok{    B {-}{-}\textgreater{} C\{Match?\}}
\NormalTok{    C {-}{-}\textgreater{}|Yes| D[Return Index]}
\NormalTok{    C {-}{-}\textgreater{}|No| E\{End of List?\}}
\NormalTok{    E {-}{-}\textgreater{}|No| F[Move to Next]}
\NormalTok{    F {-}{-}\textgreater{} B}
\NormalTok{    E {-}{-}\textgreater{}|Yes| G[Not Found]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the linear search process, showing the
step-by-step flow of checking elements until a match is found or the end
of the list is reached.

\hypertarget{q4b-uxab2uxaa8uxaafuxab0-uxab8uxab0uxa9a-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}{%
\subsubsection{Q4b: લિનિયર સર્ચ નો કોંસેપ્ટ સમજાવો.
(૦૪)}\label{q4b-uxab2uxaa8uxaafuxab0-uxab8uxab0uxa9a-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}}

લિનિયર સર્ચ, જેને સિક્વેન્શિયલ સર્ચ પણ કહેવાય છે, એ એક સરળ શોધ એલ્ગોરિધમ છે જે લિસ્ટ
અથવા એરેમાં કોઈ ચોક્કસ તત્વને શોધવા માટે વપરાય છે. અહીં કોન્સેપ્ટની સમજૂતી આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  કાર્ય સિદ્ધાંત:

  \begin{itemize}
  \tightlist
  \item
    એલ્ગોરિધમ લિસ્ટમાં દરેક તત્વને ક્રમશઃ ચકાસે છે.
  \item
    તે દરેક તત્વને લક્ષ્ય મૂલ્ય સાથે સરખાવે છે જ્યાં સુધી મેળ ન મળે અથવા લિસ્ટનો અંત ન આવે.
  \end{itemize}
\item
  એલ્ગોરિધમના પગલાં:

  \begin{itemize}
  \tightlist
  \item
    લિસ્ટના પ્રથમ તત્વથી શરૂ કરો.
  \item
    વર્તમાન તત્વને લક્ષ્ય મૂલ્ય સાથે સરખાવો.
  \item
    જો તેઓ મેળ ખાય, તો વર્તમાન તત્વનો ઇન્ડેક્સ પરત કરો.
  \item
    જો નહીં, તો આગળના તત્વ પર જાઓ અને પગલાં 2-3 પુનરાવર્તિત કરો.
  \item
    જો મેળ મળ્યા વિના લિસ્ટનો અંત આવે, તો -1 પરત કરો અથવા તત્વ મળ્યું નથી એમ
    સૂચવો.
  \end{itemize}
\item
  સમય જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    શ્રેષ્ઠ કેસ: O(1) - જ્યારે લક્ષ્ય પ્રથમ તત્વ હોય.
  \item
    સૌથી ખરાબ કેસ: O(n) - જ્યારે લક્ષ્ય છેલ્લું તત્વ હોય અથવા લિસ્ટમાં ન હોય.
  \item
    સરેરાશ કેસ: O(n) - સરેરાશ રીતે, અડધા તત્વો ચકાસવામાં આવે છે.
  \end{itemize}
\item
  પાયથોનમાં અમલીકરણ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ linear\_search(arr, target):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(arr)):}
        \ControlFlowTok{if}\NormalTok{ arr[i] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}
\item
  ફાયદા અને ગેરફાયદા:

  \begin{itemize}
  \tightlist
  \item
    ફાયદા: અમલ કરવામાં સરળ, અવ્યવસ્થિત લિસ્ટ પર કામ કરે છે.
  \item
    ગેરફાયદા: મોટા ડેટાસેટ માટે અકાર્યક્ષમ.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[તત્વ ચકાસો]}
\NormalTok{    B {-}{-}\textgreater{} C\{મેળ?\}}
\NormalTok{    C {-}{-}\textgreater{}|હા| D[ઇન્ડેક્સ પરત કરો]}
\NormalTok{    C {-}{-}\textgreater{}|ના| E\{લિસ્ટનો અંત?\}}
\NormalTok{    E {-}{-}\textgreater{}|ના| F[આગળના પર જાઓ]}
\NormalTok{    F {-}{-}\textgreater{} B}
\NormalTok{    E {-}{-}\textgreater{}|હા| G[મળ્યું નથી]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ લિનિયર સર્ચની પ્રક્રિયાને દર્શાવે છે, જે મેળ મળે અથવા લિસ્ટનો અંત આવે ત્યાં સુધી
તત્વોની તપાસનો પગલે પગલે પ્રવાહ બતાવે છે.

\hypertarget{q4c-write-a-code-to-implement-binary-search-algorithm.-07-marks}{%
\subsubsection{Q4c: Write a code to implement binary search algorithm.
(07
marks)}\label{q4c-write-a-code-to-implement-binary-search-algorithm.-07-marks}}

Binary search is an efficient algorithm for searching a sorted array by
repeatedly dividing the search interval in half. Here's an
implementation of the binary search algorithm in Python:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ binary\_search(arr, target):}
\NormalTok{    left }\OperatorTok{=} \DecValTok{0}
\NormalTok{    right }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr) }\OperatorTok{{-}} \DecValTok{1}

    \ControlFlowTok{while}\NormalTok{ left }\OperatorTok{\textless{}=}\NormalTok{ right:}
\NormalTok{        mid }\OperatorTok{=}\NormalTok{ (left }\OperatorTok{+}\NormalTok{ right) }\OperatorTok{//} \DecValTok{2}
        
        \ControlFlowTok{if}\NormalTok{ arr[mid] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ mid  }\CommentTok{\# Target found, return its index}
        \ControlFlowTok{elif}\NormalTok{ arr[mid] }\OperatorTok{\textless{}}\NormalTok{ target:}
\NormalTok{            left }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{+} \DecValTok{1}  \CommentTok{\# Target is in the right half}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            right }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{{-}} \DecValTok{1}  \CommentTok{\# Target is in the left half}

    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}  \CommentTok{\# Target not found in the array}

\CommentTok{\# Example usage}
\NormalTok{sorted\_array }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{17}\NormalTok{]}
\NormalTok{target }\OperatorTok{=} \DecValTok{7}
\NormalTok{result }\OperatorTok{=}\NormalTok{ binary\_search(sorted\_array, target)}

\ControlFlowTok{if}\NormalTok{ result }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Element }\SpecialCharTok{\{}\NormalTok{target}\SpecialCharTok{\}}\SpecialStringTok{ found at index }\SpecialCharTok{\{}\NormalTok{result}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Element }\SpecialCharTok{\{}\NormalTok{target}\SpecialCharTok{\}}\SpecialStringTok{ not found in the array"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Key points of the implementation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The function takes a sorted array and a target value as input.
\item
  It initializes two pointers, \texttt{left} and \texttt{right}, to the
  start and end of the array.
\item
  In each iteration, it calculates the middle index \texttt{mid}.
\item
  It compares the middle element with the target:

  \begin{itemize}
  \tightlist
  \item
    If equal, the target is found.
  \item
    If the target is greater, search the right half.
  \item
    If the target is smaller, search the left half.
  \end{itemize}
\item
  The process continues until the target is found or the search space is
  exhausted.
\item
  If the target is not found, it returns -1.
\end{enumerate}

Time Complexity: O(log n), where n is the number of elements in the
array. Space Complexity: O(1) as it uses only a constant amount of extra
space.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Initialize pointers]}
\NormalTok{    B {-}{-}\textgreater{} C\{Search condition met?\}}
\NormalTok{    C {-}{-}\textgreater{}|Yes| D[Calculate mid]}
\NormalTok{    D {-}{-}\textgreater{} E\{Compare mid element\}}
\NormalTok{    E {-}{-}\textgreater{}|Equal| F[Return mid]}
\NormalTok{    E {-}{-}\textgreater{}|Less than| G[Update left pointer]}
\NormalTok{    E {-}{-}\textgreater{}|Greater than| H[Update right pointer]}
\NormalTok{    G {-}{-}\textgreater{} C}
\NormalTok{    H {-}{-}\textgreater{} C}
\NormalTok{    C {-}{-}\textgreater{}|No| I[Return not found]}
\NormalTok{    F {-}{-}\textgreater{} J[End]}
\NormalTok{    I {-}{-}\textgreater{} J}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the flow of the binary search algorithm,
showing the decision process and how the search space is narrowed down
in each iteration.

\hypertarget{q4c-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa85uxab2uxa97uxab0uxaa7uxaae-uxa87uxaaeuxaaauxab2uxaaeuxa9f-uxa95uxab0uxab5-uxaaeuxa9fuxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxaed}{%
\subsubsection{Q4c: બાયનરી સર્ચ અલ્ગોરિધમ ઇમ્પ્લીમેંટ કરવા માટેનો કોડ લખો.
(૦૭)}\label{q4c-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa85uxab2uxa97uxab0uxaa7uxaae-uxa87uxaaeuxaaauxab2uxaaeuxa9f-uxa95uxab0uxab5-uxaaeuxa9fuxaa8-uxa95uxaa1-uxab2uxa96.-uxae6uxaed}}

બાયનરી સર્ચ એ એક કાર્યક્ષમ અલ્ગોરિધમ છે જે સોર્ટેડ એરેમાં શોધ અંતરાલને વારંવાર અડધામાં
વિભાજિત કરીને શોધે છે. અહીં પાયથોનમાં બાયનરી સર્ચ અલ્ગોરિધમનું અમલીકરણ આપ્યું છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ binary\_search(arr, target):}
\NormalTok{    left }\OperatorTok{=} \DecValTok{0}
\NormalTok{    right }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr) }\OperatorTok{{-}} \DecValTok{1}

    \ControlFlowTok{while}\NormalTok{ left }\OperatorTok{\textless{}=}\NormalTok{ right:}
\NormalTok{        mid }\OperatorTok{=}\NormalTok{ (left }\OperatorTok{+}\NormalTok{ right) }\OperatorTok{//} \DecValTok{2}
        
        \ControlFlowTok{if}\NormalTok{ arr[mid] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ mid  }\CommentTok{\# લક્ષ્ય મળ્યું, તેનો ઇન્ડેક્સ પરત કરો}
        \ControlFlowTok{elif}\NormalTok{ arr[mid] }\OperatorTok{\textless{}}\NormalTok{ target:}
\NormalTok{            left }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{+} \DecValTok{1}  \CommentTok{\# લક્ષ્ય જમણી બાજુના અર્ધભાગમાં છે}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            right }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{{-}} \DecValTok{1}  \CommentTok{\# લક્ષ્ય ડાબી બાજુના અર્ધભાગમાં છે}

    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}  \CommentTok{\# લક્ષ્ય એરેમાં મળ્યું નથી}

\CommentTok{\# ઉપયોગનું ઉદાહરણ}
\NormalTok{sorted\_array }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{17}\NormalTok{]}
\NormalTok{target }\OperatorTok{=} \DecValTok{7}
\NormalTok{result }\OperatorTok{=}\NormalTok{ binary\_search(sorted\_array, target)}

\ControlFlowTok{if}\NormalTok{ result }\OperatorTok{!=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"તત્વ }\SpecialCharTok{\{}\NormalTok{target}\SpecialCharTok{\}}\SpecialStringTok{ ઇન્ડેક્સ }\SpecialCharTok{\{}\NormalTok{result}\SpecialCharTok{\}}\SpecialStringTok{ પર મળ્યું"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"તત્વ }\SpecialCharTok{\{}\NormalTok{target}\SpecialCharTok{\}}\SpecialStringTok{ એરેમાં મળ્યું નથી"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

અમલીકરણના મુખ્ય મુદ્દાઓ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ફંક્શન સોર્ટેડ એરે અને લક્ષ્ય મૂલ્યને ઇનપુટ તરીકે લે છે.
\item
  તે \texttt{left} અને \texttt{right} નામના બે પોઇન્ટર્સને એરેની શરૂઆત અને અંત પર
  આરંભ કરે છે.
\item
  દરેક પુનરાવર્તનમાં, તે મધ્ય ઇન્ડેક્સ \texttt{mid} ની ગણતરી કરે છે.
\item
  તે મધ્ય તત્વને લક્ષ્ય સાથે સરખાવે છે:

  \begin{itemize}
  \tightlist
  \item
    જો સમાન હોય, તો લક્ષ્ય મળી ગયું છે.
  \item
    જો લક્ષ્ય મોટું હોય, તો જમણી બાજુના અર્ધભાગમાં શોધો.
  \item
    જો લક્ષ્ય નાનું હોય, તો ડાબી બાજુના અર્ધભાગમાં શોધો.
  \end{itemize}
\item
  લક્ષ્ય મળે અથવા શોધ અવકાશ સમાપ્ત થાય ત્યાં સુધી પ્રક્રિયા ચાલુ રહે છે.
\item
  જો લક્ષ્ય ન મળે, તો તે -1 પરત કરે છે.
\end{enumerate}

સમય જટિલતા: O(log n), જ્યાં n એરેમાં તત્વોની સંખ્યા છે. સ્પેસ જટિલતા: O(1) કારણ કે
તે માત્ર સ્થિર જગ્યાનો ઉપયોગ કરે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[પોઇન્ટર્સ આરંભ કરો]}
\NormalTok{    B {-}{-}\textgreater{} C\{શોધ ચાલુ?\}}
\NormalTok{    C {-}{-}\textgreater{}|હા| D[mid ગણો]}
\NormalTok{    D {-}{-}\textgreater{} E\{mid ચકાસો\}}
\NormalTok{    E {-}{-}\textgreater{}|સમાન| F[mid આપો]}
\NormalTok{    E {-}{-}\textgreater{}|નાનું| G[left અપડેટ કરો]}
\NormalTok{    E {-}{-}\textgreater{}|મોટું| H[right અપડેટ કરો]}
\NormalTok{    G {-}{-}\textgreater{} C}
\NormalTok{    H {-}{-}\textgreater{} C}
\NormalTok{    C {-}{-}\textgreater{}|ના| I[ના મળ્યું]}
\NormalTok{    F {-}{-}\textgreater{} K[સમાપ્ત]}
\NormalTok{    I {-}{-}\textgreater{} K}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બાયનરી સર્ચ અલ્ગોરિધમના પ્રવાહને દર્શાવે છે, જે નિર્ણય પ્રક્રિયા અને દરેક
પુનરાવર્તનમાં શોધ અવકાશ કેવી રીતે સાંકડો થાય છે તે બતાવે છે.

\hypertarget{q4aor-explain-concept-of-selection-sort-algorithm.-03-marks}{%
\subsubsection{Q4aOR: Explain concept of selection sort algorithm. (03
marks)}\label{q4aor-explain-concept-of-selection-sort-algorithm.-03-marks}}

Selection sort is a simple comparison-based sorting algorithm. The main
concept behind selection sort is as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Basic Idea:

  \begin{itemize}
  \tightlist
  \item
    The algorithm divides the input list into two parts: a sorted
    portion and an unsorted portion.
  \item
    It repeatedly selects the smallest (or largest) element from the
    unsorted portion and moves it to the end of the sorted portion.
  \end{itemize}
\item
  Algorithm Steps:

  \begin{itemize}
  \tightlist
  \item
    Find the minimum element in the unsorted array
  \item
    Swap it with the first element of the unsorted part
  \item
    Move the boundary of the sorted array one element to the right
  \end{itemize}
\item
  Time Complexity:

  \begin{itemize}
  \tightlist
  \item
    Best Case: O(n\^{}2)
  \item
    Average Case: O(n\^{}2)
  \item
    Worst Case: O(n\^{}2)
  \end{itemize}
\item
  Space Complexity:

  \begin{itemize}
  \tightlist
  \item
    O(1) as it sorts in-place
  \end{itemize}
\item
  Key Characteristics:

  \begin{itemize}
  \tightlist
  \item
    Simple implementation
  \item
    Performs well on small lists
  \item
    Inefficient on large lists
  \item
    Unstable sort (may change the relative order of equal elements)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Set minimum to first element]}
\NormalTok{    B {-}{-}\textgreater{} C[Compare with next element]}
\NormalTok{    C {-}{-}\textgreater{} D\{Smaller?\}}
\NormalTok{    D {-}{-}\textgreater{}|Yes| E[Update minimum]}
\NormalTok{    D {-}{-}\textgreater{}|No| F[Move to next element]}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{} G\{End of array?\}}
\NormalTok{    G {-}{-}\textgreater{}|No| C}
\NormalTok{    G {-}{-}\textgreater{}|Yes| H[Swap minimum with first unsorted element]}
\NormalTok{    H {-}{-}\textgreater{} I\{Whole array sorted?\}}
\NormalTok{    I {-}{-}\textgreater{}|No| B}
\NormalTok{    I {-}{-}\textgreater{}|Yes| J[End]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the process of selection sort, showing how the
algorithm repeatedly finds the minimum element and places it in the
sorted portion of the array.

\hypertarget{q4aor-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}{%
\subsubsection{Q4aOR: સિલેક્શન સોર્ટ અલ્ગોરીધમ નો કોંસેપ્ટ સમજાવો.
(૦૩)}\label{q4aor-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxaa8-uxa95uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}}

સિલેક્શન સોર્ટ એક સરળ તુલના-આધારિત સોર્ટિંગ અલ્ગોરિધમ છે. સિલેક્શન સોર્ટની પાછળનો
મુખ્ય વિચાર આ મુજબ છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  મૂળભૂત વિચાર:

  \begin{itemize}
  \tightlist
  \item
    અલ્ગોરિધમ ઇનપુટ લિસ્ટને બે ભાગમાં વિભાજિત કરે છે: સોર્ટેડ ભાગ અને અનસોર્ટેડ ભાગ.
  \item
    તે વારંવાર અનસોર્ટેડ ભાગમાંથી સૌથી નાના (અથવા મોટા) તત્વને પસંદ કરે છે અને તેને
    સોર્ટેડ ભાગના અંતે ખસેડે છે.
  \end{itemize}
\item
  અલ્ગોરિધમના પગલાં:

  \begin{itemize}
  \tightlist
  \item
    અનસોર્ટેડ એરેમાં લઘુત્તમ તત્વ શોધો
  \item
    તેને અનસોર્ટેડ ભાગના પ્રથમ તત્વ સાથે સ્વેપ કરો
  \item
    સોર્ટેડ એરેની સીમાને એક તત્વ જમણી તરફ ખસેડો
  \end{itemize}
\item
  સમય જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    શ્રેષ્ઠ કેસ: O(n\^{}2)
  \item
    સરેરાશ કેસ: O(n\^{}2)
  \item
    સૌથી ખરાબ કેસ: O(n\^{}2)
  \end{itemize}
\item
  સ્પેસ જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    O(1) કારણ કે તે ઇન-પ્લેસ સોર્ટ કરે છે
  \end{itemize}
\item
  મુખ્ય લક્ષણો:

  \begin{itemize}
  \tightlist
  \item
    સરળ અમલીકરણ
  \item
    નાની યાદીઓ પર સારું પ્રદર્શન કરે છે
  \item
    મોટી યાદીઓ પર અકાર્યક્ષમ
  \item
    અસ્થિર સોર્ટ (સમાન તત્વોનો સાપેક્ષ ક્રમ બદલી શકે છે)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[પ્રથમ તત્વને ન્યૂનતમ તરીકે સેટ કરો]}
\NormalTok{    B {-}{-}\textgreater{} C[આગળના તત્વ સાથે સરખાવો]}
\NormalTok{    C {-}{-}\textgreater{} D\{નાનું?\}}
\NormalTok{    D {-}{-}\textgreater{}|હા| E[ન્યૂનતમ અપડેટ કરો]}
\NormalTok{    D {-}{-}\textgreater{}|ના| F[આગળના તત્વ પર જાઓ]}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{} G\{એરેનો અંત?\}}
\NormalTok{    G {-}{-}\textgreater{}|ના| C}
\NormalTok{    G {-}{-}\textgreater{}|હા| H[ન્યૂનતમને પ્રથમ અનસોર્ટેડ તત્વ સાથે સ્વેપ કરો]}
\NormalTok{    H {-}{-}\textgreater{} I\{આખો એરે સોર્ટેડ?\}}
\NormalTok{    I {-}{-}\textgreater{}|ના| B}
\NormalTok{    I {-}{-}\textgreater{}|હા| J[સમાપ્ત]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ સિલેક્શન સોર્ટની પ્રક્રિયાને દર્શાવે છે, જે બતાવે છે કે અલ્ગોરિધમ કેવી રીતે
વારંવાર ન્યૂનતમ તત્વ શોધે છે અને તેને એરેના સોર્ટેડ ભાગમાં મૂકે છે.

\hypertarget{q4bor-explain-bubble-sort-method.-04-marks}{%
\subsubsection{Q4bOR: Explain bubble sort method. (04
marks)}\label{q4bor-explain-bubble-sort-method.-04-marks}}

Bubble sort is a simple sorting algorithm that repeatedly steps through
the list, compares adjacent elements and swaps them if they are in the
wrong order. The pass through the list is repeated until the list is
sorted. Here's a detailed explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Working Principle:

  \begin{itemize}
  \tightlist
  \item
    The algorithm compares adjacent elements in the array.
  \item
    If the first element is greater than the second, it swaps them.
  \item
    This process continues for the entire array, causing larger elements
    to ``bubble up'' to the end of the list.
  \end{itemize}
\item
  Algorithm Steps:

  \begin{itemize}
  \tightlist
  \item
    Start with the first element of the array.
  \item
    Compare it with the next element.
  \item
    If it's larger, swap them.
  \item
    Move to the next pair of adjacent elements and repeat steps 2-3.
  \item
    After each pass, the largest unsorted element moves to its correct
    position at the end.
  \item
    Repeat the process for n-1 passes, where n is the number of
    elements.
  \end{itemize}
\item
  Time Complexity:

  \begin{itemize}
  \tightlist
  \item
    Best Case: O(n) when the array is already sorted
  \item
    Average and Worst Case: O(n\^{}2)
  \end{itemize}
\item
  Space Complexity: O(1) as it sorts in-place
\item
  Advantages and Disadvantages:

  \begin{itemize}
  \tightlist
  \item
    Advantages: Simple to understand and implement
  \item
    Disadvantages: Inefficient for large datasets
  \end{itemize}
\item
  Optimization:

  \begin{itemize}
  \tightlist
  \item
    Can be optimized by stopping the algorithm if no swaps occur in a
    pass
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Outer loop]}
\NormalTok{    B {-}{-}\textgreater{} C[Inner loop]}
\NormalTok{    C {-}{-}\textgreater{} D\{Compare adjacent elements\}}
\NormalTok{    D {-}{-}\textgreater{}|Greater| E[Swap elements]}
\NormalTok{    D {-}{-}\textgreater{}|Not Greater| F[Move to next pair]}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{} G\{Inner loop complete?\}}
\NormalTok{    G {-}{-}\textgreater{}|No| C}
\NormalTok{    G {-}{-}\textgreater{}|Yes| H\{Outer loop complete?\}}
\NormalTok{    H {-}{-}\textgreater{}|No| B}
\NormalTok{    H {-}{-}\textgreater{}|Yes| I[End]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the nested loop structure of the bubble sort
algorithm, showing how elements are compared and swapped in each pass.

\hypertarget{q4bor-uxaacuxaacuxab2-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}{%
\subsubsection{Q4bOR: બબલ સોર્ટ મેથડ સમજાવો.
(૦૪)}\label{q4bor-uxaacuxaacuxab2-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}}

બબલ સોર્ટ એક સરળ સોર્ટિંગ અલ્ગોરિધમ છે જે વારંવાર યાદીમાંથી પસાર થાય છે, બાજુના
તત્વોની તુલના કરે છે અને જો તેઓ ખોટા ક્રમમાં હોય તો તેમને સ્વેપ કરે છે. યાદી સોર્ટ થાય
ત્યાં સુધી યાદીમાંથી પસાર થવાનું પુનરાવર્તન થાય છે. અહીં વિગતવાર સમજૂતી આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  કાર્ય સિદ્ધાંત:

  \begin{itemize}
  \tightlist
  \item
    અલ્ગોરિધમ એરેમાં બાજુના તત્વોની તુલના કરે છે.
  \item
    જો પ્રથમ તત્વ બીજા કરતાં મોટું હોય, તો તે તેમને સ્વેપ કરે છે.
  \item
    આ પ્રક્રિયા આખા એરે માટે ચાલુ રહે છે, જેના કારણે મોટા તત્વો યાદીના અંત તરફ
    ``બબલ અપ'' થાય છે.
  \end{itemize}
\item
  અલ્ગોરિધમના પગલાં:

  \begin{itemize}
  \tightlist
  \item
    એરેના પ્રથમ તત્વથી શરૂ કરો.
  \item
    તેને આગળના તત્વ સાથે સરખાવો.
  \item
    જો તે મોટું હોય, તો તેમને સ્વેપ કરો.
  \item
    બાજુના તત્વોની આગળની જોડી પર જાઓ અને પગલાં 2-3 પુનરાવર્તિત કરો.
  \item
    દરેક પાસ પછી, સૌથી મોટું અનસોર્ટેડ તત્વ અંતે તેના સાચા સ્થાને ખસે છે.
  \item
    n-1 પાસ માટે પ્રક્રિયાનું પુનરાવર્તન કરો, જ્યાં n તત્વોની સંખ્યા છે.
  \end{itemize}
\item
  સમય જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    શ્રેષ્ઠ કેસ: O(n) જ્યારે એરે પહેલેથી જ સોર્ટેડ હોય
  \item
    સરેરાશ અને સૌથી ખરાબ કેસ: O(n\^{}2)
  \end{itemize}
\item
  સ્પેસ જટિલતા: O(1) કારણ કે તે ઇન-પ્લેસ સોર્ટ કરે છે
\item
  ફાયદા અને ગેરફાયદા:

  \begin{itemize}
  \tightlist
  \item
    ફાયદા: સમજવામાં અને અમલ કરવામાં સરળ
  \item
    ગેરફાયદા: મોટા ડેટાસેટ્સ માટે અકાર્યક્ષમ
  \end{itemize}
\item
  ઓપ્ટિમાઇઝેશન:

  \begin{itemize}
  \tightlist
  \item
    જો કોઈ પાસમાં કોઈ સ્વેપ ન થાય તો અલ્ગોરિધમને રોકીને ઓપ્ટિમાઇઝ કરી શકાય છે
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[બાહ્ય લૂપ]}
\NormalTok{    B {-}{-}\textgreater{} C[આંતરિક લૂપ]}
\NormalTok{    C {-}{-}\textgreater{} D\{બાજુના તત્વોની તુલના\}}
\NormalTok{    D {-}{-}\textgreater{}|મોટું| E[તત્વો સ્વેપ કરો]}
\NormalTok{    D {-}{-}\textgreater{}|નાનું/સમાન| F[આગળની જોડી]}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{} G\{આંતરિક લૂપ પૂર્ણ?\}}
\NormalTok{    G {-}{-}\textgreater{}|ના| C}
\NormalTok{    G {-}{-}\textgreater{}|હા| H\{બાહ્ય લૂપ પૂર્ણ?\}}
\NormalTok{    H {-}{-}\textgreater{}|ના| B}
\NormalTok{    H {-}{-}\textgreater{}|હા| I[સમાપ્ત]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બબલ સોર્ટ અલ્ગોરિધમની નેસ્ટેડ લૂપ સ્ટ્રક્ચરને દર્શાવે છે, જે બતાવે છે કે દરેક પાસમાં
તત્વોની કેવી રીતે તુલના કરવામાં આવે છે અને સ્વેપ કરવામાં આવે છે.

\hypertarget{q4cor-explain-the-working-of-quick-sort-method-with-example.-07-marks}{%
\subsubsection{Q4cOR: Explain the working of quick sort method with
example. (07
marks)}\label{q4cor-explain-the-working-of-quick-sort-method-with-example.-07-marks}}

Quick sort is an efficient, divide-and-conquer sorting algorithm. Here's
an explanation of its working with an example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Basic Principle:

  \begin{itemize}
  \tightlist
  \item
    Choose a `pivot' element from the array.
  \item
    Partition the other elements into two sub-arrays, according to
    whether they are less than or greater than the pivot.
  \item
    Recursively sort the sub-arrays.
  \end{itemize}
\item
  Algorithm Steps:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Select a pivot (usually the last element).
  \item
    Partition the array:

    \begin{itemize}
    \tightlist
    \item
      Move elements smaller than the pivot to the left.
    \item
      Move elements larger than the pivot to the right.
    \end{itemize}
  \item
    Recursively apply the above steps to the sub-arrays.
  \end{enumerate}
\item
  Example: Let's sort the array: {[}8, 3, 2, 5, 1, 7, 6, 4{]}

  Step 1: Choose last element (4) as pivot {[}8, 3, 2, 5, 1, 7, 6, 4{]}
  \^{} Step 2: Partition {[}3, 2, 1, 4, 8, 7, 6, 5{]} \^{} Step 3:
  Recursively sort left and right sub-arrays Left: {[}3, 2, 1{]} Right:
  {[}8, 7, 6, 5{]}

  Continuing this process: {[}1, 2, 3, 4, 5, 6, 7, 8{]}
\item
  Time Complexity:

  \begin{itemize}
  \tightlist
  \item
    Average case: O(n log n)
  \item
    Worst case: O(n\^{}2) (rare, occurs when the pivot is always the
    smallest or largest element)
  \end{itemize}
\item
  Space Complexity: O(log n) due to the recursive call stack
\item
  Advantages:

  \begin{itemize}
  \tightlist
  \item
    Generally faster in practice compared to other O(n log n) algorithms
  \item
    In-place sorting (doesn't require much additional memory)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Choose Pivot]}
\NormalTok{    B {-}{-}\textgreater{} C[Partition Array]}
\NormalTok{    C {-}{-}\textgreater{} D\{Left sub{-}array exists?\}}
\NormalTok{    D {-}{-}\textgreater{}|Yes| E[Recursively sort left]}
\NormalTok{    D {-}{-}\textgreater{}|No| F\{Right sub{-}array exists?\}}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{}|Yes| G[Recursively sort right]}
\NormalTok{    F {-}{-}\textgreater{}|No| H[Combine sorted sub{-}arrays]}
\NormalTok{    G {-}{-}\textgreater{} H}
\NormalTok{    H {-}{-}\textgreater{} I[End]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the recursive nature of the quick sort
algorithm, showing how the array is partitioned and sub-arrays are
sorted.

\hypertarget{q4cor-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxa95uxab5uxa95-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1uxaa8-uxab5uxab0uxa95uxa97-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}{%
\subsubsection{Q4cOR: ઉદાહરણ સાથે ક્વીક સોર્ટ મેથડનુ વર્કિંગ સમજાવો.
(૦૭)}\label{q4cor-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxa95uxab5uxa95-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1uxaa8-uxab5uxab0uxa95uxa97-uxab8uxaaeuxa9cuxab5.-uxae6uxaed}}

ક્વીક સોર્ટ એક કાર્યક્ષમ, વિભાજન-અને-શાસન સોર્ટિંગ અલ્ગોરિધમ છે. અહીં ઉદાહરણ સાથે
તેના કાર્યની સમજૂતી આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  મૂળભૂત સિદ્ધાંત:

  \begin{itemize}
  \tightlist
  \item
    એરેમાંથી એક `પિવોટ' તત્વ પસંદ કરો.
  \item
    અન્ય તત્વોને બે પેટા-એરેમાં વિભાજિત કરો, તેઓ પિવોટ કરતાં નાના છે કે મોટા તે મુજબ.
  \item
    પેટા-એરેને પુનરાવર્તિત રીતે સોર્ટ કરો.
  \end{itemize}
\item
  અલ્ગોરિધમના પગલાં:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    પિવોટ પસંદ કરો (સામાન્ય રીતે છેલ્લું તત્વ).
  \item
    એરેને વિભાજિત કરો:

    \begin{itemize}
    \tightlist
    \item
      પિવોટ કરતાં નાના તત્વોને ડાબી બાજુ ખસેડો.
    \item
      પિવોટ કરતાં મોટા તત્વોને જમણી બાજુ ખસેડો.
    \end{itemize}
  \item
    ઉપરોક્ત પગલાંને પેટા-એરે પર પુનરાવર્તિત રીતે લાગુ કરો.
  \end{enumerate}
\item
  ઉદાહરણ: ચાલો આ એરેને સોર્ટ કરીએ: {[}8, 3, 2, 5, 1, 7, 6, 4{]}

  પગલું 1: છેલ્લા તત્વને (4) પિવોટ તરીકે પસંદ કરો {[}8, 3, 2, 5, 1, 7, 6, 4{]}
  \^{} પગલું 2: વિભાજન કરો {[}3, 2, 1, 4, 8, 7, 6, 5{]} \^{} પગલું 3: ડાબા
  અને જમણા પેટા-એરેને પુનરાવર્તિત રીતે સોર્ટ કરો ડાબે: {[}3, 2, 1{]} જમણે: {[}8,
  7, 6, 5{]}

  આ પ્રક્રિયા ચાલુ રાખતાં: {[}1, 2, 3, 4, 5, 6, 7, 8{]}
\item
  સમય જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    સરેરાશ કેસ: O(n log n)
  \item
    સૌથી ખરાબ કેસ: O(n\^{}2) (દુર્લભ, જ્યારે પિવોટ હંમેશા સૌથી નાનું અથવા સૌથી
    મોટું તત્વ હોય ત્યારે થાય છે)
  \end{itemize}
\item
  સ્પેસ જટિલતા: O(log n) પુનરાવર્તિત કૉલ સ્ટેકને કારણે
\item
  ફાયદાઓ:

  \begin{itemize}
  \tightlist
  \item
    સામાન્ય રીતે અન્ય O(n log n) અલ્ગોરિધમ્સની તુલનામાં વ્યવહારમાં ઝડપી
  \item
    ઇન-પ્લેસ સોર્ટિંગ (ઘણી વધારાની મેમરીની જરૂર પડતી નથી)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[પિવોટ પસંદ કરો]}
\NormalTok{    B {-}{-}\textgreater{} C[એરેને વિભાજિત કરો]}
\NormalTok{    C {-}{-}\textgreater{} D\{ડાબો પેટા{-}એરે છે?\}}
\NormalTok{    D {-}{-}\textgreater{}|હા| E[ડાબાને પુનરાવર્તિત સોર્ટ કરો]}
\NormalTok{    D {-}{-}\textgreater{}|ના| F\{જમણો પેટા{-}એરે છે?\}}
\NormalTok{    E {-}{-}\textgreater{} F}
\NormalTok{    F {-}{-}\textgreater{}|હા| G[જમણાને પુનરાવર્તિત સોર્ટ કરો]}
\NormalTok{    F {-}{-}\textgreater{}|ના| H[સોર્ટેડ પેટા{-}એરેને જોડો]}
\NormalTok{    G {-}{-}\textgreater{} H}
\NormalTok{    H {-}{-}\textgreater{} I[સમાપ્ત]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ ક્વીક સોર્ટ અલ્ગોરિધમની પુનરાવર્તિત પ્રકૃતિને દર્શાવે છે, જે બતાવે છે કે કેવી રીતે
એરેને વિભાજિત કરવામાં આવે છે અને પેટા-એરેને સોર્ટ કરવામાં આવે છે.

\hypertarget{q5a-explain-binary-tree.-03-marks}{%
\subsubsection{Q5a: Explain binary tree. (03
marks)}\label{q5a-explain-binary-tree.-03-marks}}

A binary tree is a hierarchical data structure in which each node has at
most two children, referred to as the left child and the right child.
Here are the key points about binary trees:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Structure:

  \begin{itemize}
  \tightlist
  \item
    Root: The topmost node of the tree.
  \item
    Nodes: Each element in the tree, containing data and references to
    children.
  \item
    Leaves: Nodes with no children.
  \end{itemize}
\item
  Properties:

  \begin{itemize}
  \tightlist
  \item
    Each node has 0, 1, or 2 children.
  \item
    Left child: The node on the left side.
  \item
    Right child: The node on the right side.
  \end{itemize}
\item
  Types:

  \begin{itemize}
  \tightlist
  \item
    Full Binary Tree: Every node has 0 or 2 children.
  \item
    Complete Binary Tree: All levels are fully filled except possibly
    the last level, which is filled from left to right.
  \item
    Perfect Binary Tree: All internal nodes have two children and all
    leaves are at the same level.
  \end{itemize}
\item
  Applications:

  \begin{itemize}
  \tightlist
  \item
    Expression trees in compilers.
  \item
    Huffman coding trees in data compression.
  \item
    Binary Search Trees for efficient searching and sorting.
  \end{itemize}
\item
  Traversal Methods:

  \begin{itemize}
  \tightlist
  \item
    Inorder: Left, Root, Right
  \item
    Preorder: Root, Left, Right
  \item
    Postorder: Left, Right, Root
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Root] {-}{-}\textgreater{} B[Left Child]}
\NormalTok{    A {-}{-}\textgreater{} C[Right Child]}
\NormalTok{    B {-}{-}\textgreater{} D[Left Grandchild]}
\NormalTok{    B {-}{-}\textgreater{} E[Right Grandchild]}
\NormalTok{    C {-}{-}\textgreater{} F[Left Grandchild]}
\NormalTok{    C {-}{-}\textgreater{} G[Right Grandchild]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates a simple binary tree structure, showing the
root, left and right children, and grandchildren nodes.

\hypertarget{q5a-uxaacuxaafuxaa8uxab0-uxa9fuxab0-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}{%
\subsubsection{Q5a: બાયનરી ટ્રી સમજાવો.
(૦૩)}\label{q5a-uxaacuxaafuxaa8uxab0-uxa9fuxab0-uxab8uxaaeuxa9cuxab5.-uxae6uxae9}}

બાયનરી ટ્રી એ એક હાયરાર્કિકલ ડેટા સ્ટ્રક્ચર છે જેમાં દરેક નોડને વધુમાં વધુ બે બાળકો હોય
છે, જેને ડાબું બાળક અને જમણું બાળક કહેવાય છે. અહીં બાયનરી ટ્રી વિશેના મુખ્ય મુદ્દાઓ છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  રચના:

  \begin{itemize}
  \tightlist
  \item
    રૂટ: ટ્રીનો સૌથી ઉપરનો નોડ.
  \item
    નોડ્સ: ટ્રીમાં દરેક તત્વ, જેમાં ડેટા અને બાળકોના સંદર્ભો હોય છે.
  \item
    પાંદડાં: બાળકો વગરના નોડ્સ.
  \end{itemize}
\item
  ગુણધર્મો:

  \begin{itemize}
  \tightlist
  \item
    દરેક નોડને 0, 1, અથવા 2 બાળકો હોય છે.
  \item
    ડાબું બાળક: ડાબી બાજુનો નોડ.
  \item
    જમણું બાળક: જમણી બાજુનો નોડ.
  \end{itemize}
\item
  પ્રકારો:

  \begin{itemize}
  \tightlist
  \item
    પૂર્ણ બાયનરી ટ્રી: દરેક નોડને 0 અથવા 2 બાળકો હોય છે.
  \item
    સંપૂર્ણ બાયનરી ટ્રી: છેલ્લા સ્તર સિવાય બધા સ્તરો સંપૂર્ણ ભરેલા હોય છે, છેલ્લું સ્તર
    ડાબેથી જમણે ભરાય છે.
  \item
    આદર્શ બાયનરી ટ્રી: બધા આંતરિક નોડ્સને બે બાળકો હોય છે અને બધા પાંદડાં એક જ સ્તરે
    હોય છે.
  \end{itemize}
\item
  ઉપયોગો:

  \begin{itemize}
  \tightlist
  \item
    કમ્પાइલરોમાં એક્સપ્રેશન ટ્રીઓ.
  \item
    ડેટા કમ્પ્રેશનમાં હફમેન કોડિંગ ટ્રીઓ.
  \item
    કાર્યક્ષમ શોધ અને સોર્ટિંગ માટે બાયનરી સર્ચ ટ્રીઓ.
  \end{itemize}
\item
  ટ્રાવર્સલ પદ્ધતિઓ:

  \begin{itemize}
  \tightlist
  \item
    ઇનઓર્ડર: ડાબું, રૂટ, જમણું
  \item
    પ્રીઓર્ડર: રૂટ, ડાબું, જમણું
  \item
    પોસ્ટઓર્ડર: ડાબું, જમણું, રૂટ
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[રૂટ] {-}{-}\textgreater{} B[ડાબું બાળક]}
\NormalTok{    A {-}{-}\textgreater{} C[જમણું બાળક]}
\NormalTok{    B {-}{-}\textgreater{} D[ડાબું પૌત્ર]}
\NormalTok{    B {-}{-}\textgreater{} E[જમણું પૌત્ર]}
\NormalTok{    C {-}{-}\textgreater{} F[ડાબું પૌત્ર]}
\NormalTok{    C {-}{-}\textgreater{} G[જમણું પૌત્ર]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ એક સરળ બાયનરી ટ્રી સ્ટ્રક્ચરને દર્શાવે છે, જેમાં રૂટ, ડાબા અને જમણા બાળકો, અને
પૌત્ર નોડ્સ બતાવવામાં આવ્યા છે.

Certainly. I'll regenerate both the English and Gujarati answers with
the improvements we discussed.

\hypertarget{q5b-define-the-terms-root-path-parent-and-children-with-reference-to-tree.-04-marks}{%
\subsubsection{Q5b: Define the terms root, path, parent and children
with reference to tree. (04
marks)}\label{q5b-define-the-terms-root-path-parent-and-children-with-reference-to-tree.-04-marks}}

In the context of tree data structures, these terms have specific
meanings:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Root:

  \begin{itemize}
  \tightlist
  \item
    Definition: The topmost node in a tree structure.
  \item
    Characteristics:

    \begin{itemize}
    \tightlist
    \item
      It has no parent.
    \item
      All other nodes can be reached from the root.
    \end{itemize}
  \item
    Example: In a family tree, the oldest known ancestor would be the
    root.
  \end{itemize}
\item
  Path:

  \begin{itemize}
  \tightlist
  \item
    Definition: A sequence of nodes and edges connecting a node with a
    descendant.
  \item
    Characteristics:

    \begin{itemize}
    \tightlist
    \item
      Starts from one node and ends at another.
    \item
      Each node in the path is connected by an edge to the next node.
    \end{itemize}
  \item
    Example: The sequence of nodes you traverse to get from the root to
    a specific leaf.
  \end{itemize}
\item
  Parent:

  \begin{itemize}
  \tightlist
  \item
    Definition: A node that has one or more child nodes.
  \item
    Characteristics:

    \begin{itemize}
    \tightlist
    \item
      Directly connected to its children.
    \item
      A node can be a parent to multiple children but can have only one
      parent (except the root).
    \end{itemize}
  \item
    Example: In a directory structure, a folder containing files is a
    parent to those files.
  \end{itemize}
\item
  Children:

  \begin{itemize}
  \tightlist
  \item
    Definition: Nodes that are direct descendants of a parent node.
  \item
    Characteristics:

    \begin{itemize}
    \tightlist
    \item
      Directly connected to their parent.
    \item
      A node can have multiple children or no children (leaf).
    \end{itemize}
  \item
    Example: In an organizational chart, employees directly under a
    manager are the children nodes of that manager node.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Root] {-}{-}\textgreater{} B[Child 1]}
\NormalTok{    A {-}{-}\textgreater{} C[Child 2]}
\NormalTok{    B {-}{-}\textgreater{} D[Grandchild 1]}
\NormalTok{    B {-}{-}\textgreater{} E[Grandchild 2]}
\NormalTok{    C {-}{-}\textgreater{} F[Grandchild 3]}
\end{Highlighting}
\end{Shaded}

This diagram illustrates the concepts of root (A), parent (A, B, C),
children (B, C, D, E, F), and path (e.g., A -\textgreater{} B
-\textgreater{} E). Here, A is the root, B and C are children of A, and
D, E, F are grandchildren. The path from A to E is A -\textgreater{} B
-\textgreater{} E.

\hypertarget{q5b-uxa9fuxab0-uxaa8-uxab8uxaa6uxab0uxaad-uxaae-uxab0uxa9f-uxaaauxaa5-parent-uxa85uxaa8-children-uxaaauxaa6-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}{%
\subsubsection{Q5b: ટ્રી ના સંદર્ભ મા રૂટ, પાથ, parent અને children પદો
વ્યાખ્યાયિત કરો.
(૦૪)}\label{q5b-uxa9fuxab0-uxaa8-uxab8uxaa6uxab0uxaad-uxaae-uxab0uxa9f-uxaaauxaa5-parent-uxa85uxaa8-children-uxaaauxaa6-uxab5uxaafuxa96uxaafuxaafuxaa4-uxa95uxab0.-uxae6uxaea}}

ટ્રી ડેટા સ્ટ્રક્ચરના સંદર્ભમાં, આ પદોના ચોક્કસ અર્થ છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  રૂટ (Root):

  \begin{itemize}
  \tightlist
  \item
    વ્યાખ્યા: ટ્રી સ્ટ્રક્ચરમાં સૌથી ઉપરનો નોડ.
  \item
    લક્ષણો:

    \begin{itemize}
    \tightlist
    \item
      તેને કોઈ parent નથી.
    \item
      બધા અન્ય નોડ્સ રૂટથી પહોંચી શકાય છે.
    \end{itemize}
  \item
    ઉદાહરણ: કુટુંબ વૃક્ષમાં, સૌથી જૂનો જાણીતો પૂર્વજ રૂટ હશે.
  \end{itemize}
\item
  પાથ (Path):

  \begin{itemize}
  \tightlist
  \item
    વ્યાખ્યા: એક નોડને તેના વંશજ સાથે જોડતા નોડ્સ અને એજની શ્રેણી.
  \item
    લક્ષણો:

    \begin{itemize}
    \tightlist
    \item
      એક નોડથી શરૂ થાય છે અને બીજા પર સમાપ્ત થાય છે.
    \item
      પાથમાં દરેક નોડ આગળના નોડ સાથે એજ દ્વારા જોડાયેલો હોય છે.
    \end{itemize}
  \item
    ઉદાહરણ: રૂટથી ચોક્કસ leaf સુધી પહોંચવા માટે તમે જે નોડ્સની શ્રેણીમાંથી પસાર થાઓ
    છો તે.
  \end{itemize}
\item
  Parent:

  \begin{itemize}
  \tightlist
  \item
    વ્યાખ્યા: એક અથવા વધુ child નોડ્સ ધરાવતો નોડ.
  \item
    લક્ષણો:

    \begin{itemize}
    \tightlist
    \item
      તેના children સાથે સીધો જોડાયેલો.
    \item
      એક નોડ અનેક childrenનો parent હોઈ શકે છે પરંતુ તેને માત્ર એક જ parent હોઈ
      શકે છે (રૂટ સિવાય).
    \end{itemize}
  \item
    ઉદાહરણ: ડિરેક્ટરી સ્ટ્રક્ચરમાં, ફાઇલો ધરાવતું ફોલ્ડર તે ફાઇલોનો parent છે.
  \end{itemize}
\item
  Children:

  \begin{itemize}
  \tightlist
  \item
    વ્યાખ્યા: parent નોડના સીધા વંશજો.
  \item
    લક્ષણો:

    \begin{itemize}
    \tightlist
    \item
      તેમના parent સાથે સીધા જોડાયેલા.
    \item
      એક નોડને અનેક children હોઈ શકે છે અથવા કોઈ child ન પણ હોય (leaf).
    \end{itemize}
  \item
    ઉદાહરણ: સંગઠનાત્મક ચાર્ટમાં, મેનેજર હેઠળ સીધા કર્મચારીઓ તે મેનેજર નોડના
    children નોડ્સ છે.
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Root] {-}{-}\textgreater{} B[Child 1]}
\NormalTok{    A {-}{-}\textgreater{} C[Child 2]}
\NormalTok{    B {-}{-}\textgreater{} D[Grandchild 1]}
\NormalTok{    B {-}{-}\textgreater{} E[Grandchild 2]}
\NormalTok{    C {-}{-}\textgreater{} F[Grandchild 3]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ રૂટ (A), parent (A, B, C), children (B, C, D, E, F), અને પાથ
(દા.ત., A -\textgreater{} B -\textgreater{} E) ના ખ્યાલોને દર્શાવે છે. અહીં, A
એ રૂટ છે, B અને C એ A ના children છે, અને D, E, F એ grandchildren છે. A થી E
સુધીનો પાથ A -\textgreater{} B -\textgreater{} E છે.

\hypertarget{q5c-apply-preorder-and-postorder-traversal-for-given-below-tree.-07-marks}{%
\subsubsection{Q5c: Apply preorder and postorder traversal for given
below tree. (07
marks)}\label{q5c-apply-preorder-and-postorder-traversal-for-given-below-tree.-07-marks}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    Root["Root"] {-}{-}\textgreater{} 40}
\NormalTok{    40((40)) {-}{-}\textgreater{} 30((30))}
\NormalTok{    40 {-}{-}\textgreater{} 50((50))}
\NormalTok{    30 {-}{-}\textgreater{} 25((25))}
\NormalTok{    30 {-}{-}\textgreater{} 35((35))}
\NormalTok{    50 {-}{-}\textgreater{} 45((45))}
\NormalTok{    50 {-}{-}\textgreater{} 60((60))}
\NormalTok{    25 {-}{-}\textgreater{} 15((15))}
\NormalTok{    25 {-}{-}\textgreater{} 28((28))}
\NormalTok{    60 {-}{-}\textgreater{} 55((55))}
\NormalTok{    60 {-}{-}\textgreater{} 70((70))}
    
\NormalTok{    classDef default fill:\#D3D3D3,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    class Root font{-}weight:bold,fill:none,stroke:none;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

Let's apply both preorder and postorder traversals to the given binary
tree:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Preorder Traversal:

  \begin{itemize}
  \tightlist
  \item
    Algorithm: Visit Root, Traverse Left Subtree, Traverse Right Subtree
  \item
    Steps:

    \begin{enumerate}
    \def\labelenumii{\arabic{enumii}.}
    \tightlist
    \item
      Visit the root (40)
    \item
      Traverse left subtree of 40
    \item
      Traverse right subtree of 40
    \end{enumerate}
  \item
    Preorder sequence: 40, 30, 25, 15, 28, 35, 50, 45, 60, 55, 70
  \end{itemize}

  Explanation:

  \begin{itemize}
  \tightlist
  \item
    Start at 40 (root)
  \item
    Go left: 30, then 25, then 15
  \item
    Backtrack to 25, go right: 28
  \item
    Backtrack to 30, go right: 35
  \item
    Backtrack to 40, go right: 50, then 45
  \item
    Backtrack to 50, go right: 60, then 55
  \item
    Backtrack to 60, go right: 70
  \end{itemize}
\item
  Postorder Traversal:

  \begin{itemize}
  \tightlist
  \item
    Algorithm: Traverse Left Subtree, Traverse Right Subtree, Visit Root
  \item
    Steps:

    \begin{enumerate}
    \def\labelenumii{\arabic{enumii}.}
    \tightlist
    \item
      Traverse left subtree of 40
    \item
      Traverse right subtree of 40
    \item
      Visit the root (40)
    \end{enumerate}
  \item
    Postorder sequence: 15, 28, 25, 35, 30, 45, 55, 70, 60, 50, 40
  \end{itemize}

  Explanation:

  \begin{itemize}
  \tightlist
  \item
    Start at leftmost leaf: 15
  \item
    Go to its sibling: 28
  \item
    Visit their parent: 25
  \item
    Go to 25's sibling: 35
  \item
    Visit their parent: 30
  \item
    Move to right subtree, start at leftmost leaf: 45
  \item
    Move to 60's left child: 55
  \item
    Then to 60's right child: 70
  \item
    Visit 60, then 50
  \item
    Finally, visit the root: 40
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    Root["Root"] {-}{-}\textgreater{} 40}
\NormalTok{    40((40)) {-}{-}\textgreater{} 30((30))}
\NormalTok{    40 {-}{-}\textgreater{} 50((50))}
\NormalTok{    30 {-}{-}\textgreater{} 25((25))}
\NormalTok{    30 {-}{-}\textgreater{} 35((35))}
\NormalTok{    50 {-}{-}\textgreater{} 45((45))}
\NormalTok{    50 {-}{-}\textgreater{} 60((60))}
\NormalTok{    25 {-}{-}\textgreater{} 15((15))}
\NormalTok{    25 {-}{-}\textgreater{} 28((28))}
\NormalTok{    60 {-}{-}\textgreater{} 55((55))}
\NormalTok{    60 {-}{-}\textgreater{} 70((70))}
    
\NormalTok{    classDef default fill:\#D3D3D3,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    class Root font{-}weight:bold,fill:none,stroke:none;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

This diagram shows the tree structure. The traversal orders given above
demonstrate how preorder and postorder traversals navigate through this
tree.

\hypertarget{q5c-uxaa8uxa9a-uxa86uxaaauxab2-uxa9fuxab0-uxaaeuxa9f-uxaaauxab0-uxa93uxab0uxaa1uxab0-uxa85uxaa8-uxaaauxab8uxa9fuxa93uxab0uxaa1uxab0-uxa9fuxab0uxab5uxab0uxab8uxab2-uxab2uxa97-uxa95uxab0.-uxae6uxaed}{%
\subsubsection{Q5c: નીચે આપેલા ટ્રી માટે પ્રી ઓર્ડર અને પોસ્ટઓર્ડર ટ્રાવર્સલ લાગુ
કરો.
(૦૭)}\label{q5c-uxaa8uxa9a-uxa86uxaaauxab2-uxa9fuxab0-uxaaeuxa9f-uxaaauxab0-uxa93uxab0uxaa1uxab0-uxa85uxaa8-uxaaauxab8uxa9fuxa93uxab0uxaa1uxab0-uxa9fuxab0uxab5uxab0uxab8uxab2-uxab2uxa97-uxa95uxab0.-uxae6uxaed}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    Root["Root"] {-}{-}\textgreater{} 40}
\NormalTok{    40((40)) {-}{-}\textgreater{} 30((30))}
\NormalTok{    40 {-}{-}\textgreater{} 50((50))}
\NormalTok{    30 {-}{-}\textgreater{} 25((25))}
\NormalTok{    30 {-}{-}\textgreater{} 35((35))}
\NormalTok{    50 {-}{-}\textgreater{} 45((45))}
\NormalTok{    50 {-}{-}\textgreater{} 60((60))}
\NormalTok{    25 {-}{-}\textgreater{} 15((15))}
\NormalTok{    25 {-}{-}\textgreater{} 28((28))}
\NormalTok{    60 {-}{-}\textgreater{} 55((55))}
\NormalTok{    60 {-}{-}\textgreater{} 70((70))}
    
\NormalTok{    classDef default fill:\#D3D3D3,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    class Root font{-}weight:bold,fill:none,stroke:none;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

આપેલા બાયનરી ટ્રી માટે પ્રી ઓર્ડર અને પોસ્ટઓર્ડર ટ્રાવર્સલ લાગુ કરીએ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  પ્રી ઓર્ડર ટ્રાવર્સલ:

  \begin{itemize}
  \tightlist
  \item
    અલ્ગોરિધમ: રૂટની મુલાકાત લો, ડાબા સબટ્રીને ટ્રાવર્સ કરો, જમણા સબટ્રીને ટ્રાવર્સ
    કરો
  \item
    પગલાં:

    \begin{enumerate}
    \def\labelenumii{\arabic{enumii}.}
    \tightlist
    \item
      રૂટની મુલાકાત લો (40)
    \item
      40ના ડાબા સબટ્રીને ટ્રાવર્સ કરો
    \item
      40ના જમણા સબટ્રીને ટ્રાવર્સ કરો
    \end{enumerate}
  \item
    પ્રી ઓર્ડર ક્રમ: 40, 30, 25, 15, 28, 35, 50, 45, 60, 55, 70
  \end{itemize}

  સમજૂતી:

  \begin{itemize}
  \tightlist
  \item
    40 (રૂટ)થી શરૂ કરો
  \item
    ડાબે જાઓ: 30, પછી 25, પછી 15
  \item
    25 પર પાછા ફરો, જમણે જાઓ: 28
  \item
    30 પર પાછા ફરો, જમણે જાઓ: 35
  \item
    40 પર પાછા ફરો, જમણે જાઓ: 50, પછી 45
  \item
    50 પર પાછા ફરો, જમણે જાઓ: 60, પછી 55
  \item
    60 પર પાછા ફરો, જમણે જાઓ: 70
  \end{itemize}
\item
  પોસ્ટઓર્ડર ટ્રાવર્સલ:

  \begin{itemize}
  \tightlist
  \item
    અલ્ગોરિધમ: ડાબા સબટ્રીને ટ્રાવર્સ કરો, જમણા સબટ્રીને ટ્રાવર્સ કરો, રૂટની
    મુલાકાત લો
  \item
    પગલાં:

    \begin{enumerate}
    \def\labelenumii{\arabic{enumii}.}
    \tightlist
    \item
      40ના ડાબા સબટ્રીને ટ્રાવર્સ કરો
    \item
      40ના જમણા સબટ્રીને ટ્રાવર્સ કરો
    \item
      રૂટની મુલાકાત લો (40)
    \end{enumerate}
  \item
    પોસ્ટઓર્ડર ક્રમ: 15, 28, 25, 35, 30, 45, 55, 70, 60, 50, 40
  \end{itemize}

  સમજૂતી:

  \begin{itemize}
  \tightlist
  \item
    સૌથી ડાબા છેડાના leafથી શરૂ કરો: 15
  \item
    તેના siblingમાં જાઓ: 28
  \item
    તેમના parentની મુલાકાત લો: 25
  \item
    25ના siblingમાં જાઓ: 35
  \item
    તેમના parentની મુલાકાત લો: 30
  \item
    જમણા સબટ્રીમાં જાઓ, સૌથી ડાબા છેડાના leafથી શરૂ કરો: 45
  \item
    60ના ડાબા childમાં જાઓ: 55
  \item
    પછી 60ના જમણા childમાં: 70
  \item
    60ની મુલાકાત લો, પછી 50
  \item
    અંતે, રૂટની મુલાકાત લો: 40
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    Root["Root"] {-}{-}\textgreater{} 40}
\NormalTok{    40((40)) {-}{-}\textgreater{} 30((30))}
\NormalTok{    40 {-}{-}\textgreater{} 50((50))}
\NormalTok{    30 {-}{-}\textgreater{} 25((25))}
\NormalTok{    30 {-}{-}\textgreater{} 35((35))}
\NormalTok{    50 {-}{-}\textgreater{} 45((45))}
\NormalTok{    50 {-}{-}\textgreater{} 60((60))}
\NormalTok{    25 {-}{-}\textgreater{} 15((15))}
\NormalTok{    25 {-}{-}\textgreater{} 28((28))}
\NormalTok{    60 {-}{-}\textgreater{} 55((55))}
\NormalTok{    60 {-}{-}\textgreater{} 70((70))}
    
\NormalTok{    classDef default fill:\#D3D3D3,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    class Root font{-}weight:bold,fill:none,stroke:none;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ ટ્રી સ્ટ્રક્ચરને દર્શાવે છે. ઉપર આપેલા ટ્રાવર્સલ ક્રમો દર્શાવે છે કે પ્રી ઓર્ડર અને
પોસ્ટઓર્ડર ટ્રાવર્સલ આ ટ્રીમાં કેવી રીતે નેવિગેટ કરે છે.

\hypertarget{q5aor-enlist-applications-of-binary-tree.-03-marks}{%
\subsubsection{Q5aOR: Enlist applications of binary tree. (03
marks)}\label{q5aor-enlist-applications-of-binary-tree.-03-marks}}

Binary trees have numerous applications in computer science and
real-world scenarios. Here are some key applications:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Expression Trees:

  \begin{itemize}
  \tightlist
  \item
    Used in compilers to represent and evaluate arithmetic expressions
  \item
    Enables efficient parsing and calculation of mathematical formulas
  \end{itemize}
\item
  Huffman Coding Trees:

  \begin{itemize}
  \tightlist
  \item
    Applied in data compression algorithms
  \item
    Assigns variable-length codes to characters based on their frequency
  \end{itemize}
\item
  Binary Search Trees (BST):

  \begin{itemize}
  \tightlist
  \item
    Efficient for searching, inserting, and deleting elements
  \item
    Used in implementing database indexes and file systems
  \end{itemize}
\item
  Decision Trees:

  \begin{itemize}
  \tightlist
  \item
    Applied in machine learning for classification and regression tasks
  \item
    Used in artificial intelligence for game strategies
  \end{itemize}
\item
  Syntax Trees:

  \begin{itemize}
  \tightlist
  \item
    Used in programming language compilers for parsing and code
    generation
  \item
    Represents the structure of program code
  \end{itemize}
\item
  Heap Data Structure:

  \begin{itemize}
  \tightlist
  \item
    Implements priority queues
  \item
    Used in heap sort algorithm and graph algorithms like Dijkstra's
    shortest path
  \end{itemize}
\item
  Trie (Prefix Tree):

  \begin{itemize}
  \tightlist
  \item
    Efficient for storing and searching strings
  \item
    Used in autocomplete features and IP routing tables
  \end{itemize}
\end{enumerate}

These applications demonstrate the versatility and importance of binary
trees in various areas of computer science and software development.

\hypertarget{q5aor-uxaacuxaafuxaa8uxab0-uxa9fuxab0-uxaa8-uxa8fuxaaauxab2uxa95uxab6uxab8-uxab2uxa96.-uxae6uxae9}{%
\subsubsection{Q5aOR: બાયનરી ટ્રી ની એપ્લિકેશંસ લખો.
(૦૩)}\label{q5aor-uxaacuxaafuxaa8uxab0-uxa9fuxab0-uxaa8-uxa8fuxaaauxab2uxa95uxab6uxab8-uxab2uxa96.-uxae6uxae9}}

બાયનરી ટ્રીના કમ્પ્યુટર સાયન્સ અને વાસ્તવિક દુનિયાના સ્થિતિઓમાં ઘણા ઉપયોગો છે. અહીં
કેટલીક મુખ્ય એપ્લિકેશન્સ આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Expression Trees:

  \begin{itemize}
  \tightlist
  \item
    કમ્પાઇલર્સમાં ગાણિતિક અભિવ્યક્તિઓને રજૂ કરવા અને મૂલ્યાંકન કરવા માટે વપરાય છે
  \item
    ગાણિતિક સૂત્રોનું કાર્યક્ષમ parsing અને ગણતરી સક્ષમ કરે છે
  \end{itemize}
\item
  Huffman Coding Trees:

  \begin{itemize}
  \tightlist
  \item
    ડેટા કમ્પ્રેશન અલ્ગોરિધમ્સમાં લાગુ કરવામાં આવે છે
  \item
    અક્ષરોની આવૃત્તિના આધારે તેમને variable-length કોડ્સ આપે છે
  \end{itemize}
\item
  Binary Search Trees (BST):

  \begin{itemize}
  \tightlist
  \item
    એલિમેન્ટ્સ શોધવા, દાખલ કરવા અને કાઢી નાખવા માટે કાર્યક્ષમ
  \item
    ડેટાબેસ ઇન્ડેક્સ અને ફાઇલ સિસ્ટમ્સને અમલમાં મૂકવા માટે વપરાય છે
  \end{itemize}
\item
  Decision Trees:

  \begin{itemize}
  \tightlist
  \item
    મશીન લર્નિંગમાં વર્ગીકરણ અને નિયમન કાર્યો માટે લાગુ કરવામાં આવે છે
  \item
    ગેમ વ્યૂહરચનાઓ માટે આર્ટિફિશિયલ ઇન્ટેલિજન્સમાં વપરાય છે
  \end{itemize}
\item
  Syntax Trees:

  \begin{itemize}
  \tightlist
  \item
    પ્રોગ્રામિંગ લેંગ્વેજ કમ્પાઇલર્સમાં parsing અને કોડ જનરેશન માટે વપરાય છે
  \item
    પ્રોગ્રામ કોડની રચનાનું પ્રતિનિધિત્વ કરે છે
  \end{itemize}
\item
  Heap Data Structure:

  \begin{itemize}
  \tightlist
  \item
    પ્રાયોરિટી ક્યૂઝને અમલમાં મૂકે છે
  \item
    heap sort અલ્ગોરિધમ અને Dijkstra's shortest path જેવા ગ્રાફ અલ્ગોરિધમ્સમાં
    વપરાય છે
  \end{itemize}
\item
  Trie (Prefix Tree):

  \begin{itemize}
  \tightlist
  \item
    સ્ટ્રિંગ્સ સ્ટોર કરવા અને શોધવા માટે કાર્યક્ષમ
  \item
    ઓટોકમ્પ્લીટ સુવિધાઓ અને IP રાઉટિંગ ટેબલ્સમાં વપરાય છે
  \end{itemize}
\end{enumerate}

આ એપ્લિકેશન્સ કમ્પ્યુટર સાયન્સ અને સોફ્ટવેર ડેવલપમેન્ટના વિવિધ ક્ષેત્રોમાં બાયનરી ટ્રીની
બહુમુખી પ્રતિભા અને મહત્વ દર્શાવે છે.

\hypertarget{q5bor-explain-insertion-of-a-node-in-binary-search-tree.-04-marks}{%
\subsubsection{Q5bOR: Explain insertion of a node in binary search tree.
(04
marks)}\label{q5bor-explain-insertion-of-a-node-in-binary-search-tree.-04-marks}}

Insertion of a node in a Binary Search Tree (BST) follows a specific
algorithm to maintain the BST property. Here's a detailed explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  BST Property:

  \begin{itemize}
  \tightlist
  \item
    For any node, all elements in its left subtree are smaller than the
    node.
  \item
    All elements in its right subtree are larger than the node.
  \end{itemize}
\item
  Insertion Algorithm:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Start at the root of the tree.
  \item
    Compare the new value with the current node:

    \begin{itemize}
    \tightlist
    \item
      If smaller, move to the left child.
    \item
      If larger, move to the right child.
    \end{itemize}
  \item
    Repeat step b until reaching a null pointer.
  \item
    Create a new node with the value and insert it at the null position.
  \end{enumerate}
\item
  Steps in Detail:

  \begin{itemize}
  \tightlist
  \item
    If the tree is empty, the new node becomes the root.
  \item
    Otherwise, traverse the tree:

    \begin{itemize}
    \tightlist
    \item
      If the new value is less than the current node, go left.
    \item
      If it's greater, go right.
    \item
      If you reach a null pointer, insert the new node there.
    \end{itemize}
  \end{itemize}
\item
  Time Complexity:

  \begin{itemize}
  \tightlist
  \item
    Average case: O(log n), where n is the number of nodes.
  \item
    Worst case (skewed tree): O(n)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start at root] {-}{-}\textgreater{} B\{New value \textless{} current node?\}}
\NormalTok{    B {-}{-}\textgreater{}|Yes| C[Move to left child]}
\NormalTok{    B {-}{-}\textgreater{}|No| D[Move to right child]}
\NormalTok{    C {-}{-}\textgreater{} E\{Left child exists?\}}
\NormalTok{    D {-}{-}\textgreater{} F\{Right child exists?\}}
\NormalTok{    E {-}{-}\textgreater{}|Yes| B}
\NormalTok{    E {-}{-}\textgreater{}|No| G[Insert new node as left child]}
\NormalTok{    F {-}{-}\textgreater{}|Yes| B}
\NormalTok{    F {-}{-}\textgreater{}|No| H[Insert new node as right child]}
\end{Highlighting}
\end{Shaded}

This flowchart illustrates the decision process for inserting a new node
in a BST.

\hypertarget{q5bor-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa9fuxab0-uxaae-uxaa8uxaa1-uxa95uxab5-uxab0uxaa4-uxa89uxaaeuxab0-uxab6uxa95uxaaf-uxaa4-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}{%
\subsubsection{Q5bOR: બાયનરી સર્ચ ટ્રી મા નોડ કેવી રીતે ઉમેરી શકાય તે સમજાવો.
(૦૪)}\label{q5bor-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa9fuxab0-uxaae-uxaa8uxaa1-uxa95uxab5-uxab0uxaa4-uxa89uxaaeuxab0-uxab6uxa95uxaaf-uxaa4-uxab8uxaaeuxa9cuxab5.-uxae6uxaea}}

બાયનરી સર્ચ ટ્રી (BST)માં નોડ ઉમેરવાની પ્રક્રિયા BST ગુણધર્મને જાળવવા માટે ચોક્કસ
અલ્ગોરિધમનું પાલન કરે છે. અહીં વિગતવાર સમજૂતી આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  BST ગુણધર્મ:

  \begin{itemize}
  \tightlist
  \item
    કોઈપણ નોડ માટે, તેના ડાબા સબટ્રીમાં બધા તત્વો નોડ કરતાં નાના હોય છે.
  \item
    તેના જમણા સબટ્રીમાં બધા તત્વો નોડ કરતાં મોટા હોય છે.
  \end{itemize}
\item
  ઉમેરવાનો અલ્ગોરિધમ:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    ટ્રીના રૂટથી શરૂ કરો.
  \item
    નવા મૂલ્યને વર્તમાન નોડ સાથે સરખાવો:

    \begin{itemize}
    \tightlist
    \item
      જો નાનું હોય, તો ડાબા child પર જાઓ.
    \item
      જો મોટું હોય, તો જમણા child પર જાઓ.
    \end{itemize}
  \item
    null pointer સુધી પહોંચે ત્યાં સુધી પગલું b પુનરાવર્તિત કરો.
  \item
    મૂલ્ય સાથે નવો નોડ બનાવો અને તેને null સ્થાને દાખલ કરો.
  \end{enumerate}
\item
  વિગતવાર પગલાં:

  \begin{itemize}
  \tightlist
  \item
    જો ટ્રી ખાલી હોય, તો નવો નોડ રૂટ બને છે.
  \item
    અન્યથા, ટ્રીને ટ્રાવર્સ કરો:

    \begin{itemize}
    \tightlist
    \item
      જો નવું મૂલ્ય વર્તમાન નોડ કરતાં ઓછું હોય, તો ડાબે જાઓ.
    \item
      જો તે વધારે હોય, તો જમણે જાઓ.
    \item
      જો તમે null pointer પર પહોંચો, તો ત્યાં નવો નોડ દાખલ કરો.
    \end{itemize}
  \end{itemize}
\item
  સમય જટિલતા:

  \begin{itemize}
  \tightlist
  \item
    સરેરાશ કેસ: O(log n), જ્યાં n નોડ્સની સંખ્યા છે.
  \item
    સૌથી ખરાબ કેસ (skewed tree): O(n)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[રૂટથી શરૂ કરો] {-}{-}\textgreater{} B\{નવું મૂલ્ય \textless{} વર્તમાન નોડ?\}}
\NormalTok{    B {-}{-}\textgreater{}|હા| C[ડાબા child પર જાઓ]}
\NormalTok{    B {-}{-}\textgreater{}|ના| D[જમણા child પર જાઓ]}
\NormalTok{    C {-}{-}\textgreater{} E\{ડાબું child છે?\}}
\NormalTok{    D {-}{-}\textgreater{} F\{જમણું child છે?\}}
\NormalTok{    E {-}{-}\textgreater{}|હા| B}
\NormalTok{    E {-}{-}\textgreater{}|ના| G[નવા નોડને ડાબા child તરીકે દાખલ કરો]}
\NormalTok{    F {-}{-}\textgreater{}|હા| B}
\NormalTok{    F {-}{-}\textgreater{}|ના| H[નવા નોડને જમણા child તરીકે દાખલ કરો]}
\end{Highlighting}
\end{Shaded}

આ ફ્લોચાર્ટ BST માં નવો નોડ દાખલ કરવા માટેની નિર્ણય પ્રક્રિયાને દર્શાવે છે.

\hypertarget{q5cor-draw-binary-search-tree-for-8-4-12-2-6-10-14-1-3-5-and-write-in-order-traversal-for-the-tree.-07-marks}{%
\subsubsection{Q5cOR: Draw Binary search tree for 8, 4, 12, 2, 6, 10,
14, 1, 3, 5 and write In-order traversal for the tree. (07
marks)}\label{q5cor-draw-binary-search-tree-for-8-4-12-2-6-10-14-1-3-5-and-write-in-order-traversal-for-the-tree.-07-marks}}

Let's construct the Binary Search Tree (BST) step by step and then
perform an in-order traversal.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  BST Construction:

  \begin{itemize}
  \tightlist
  \item
    Start with 8 as the root
  \item
    Insert each number one by one according to BST rules
  \end{itemize}
\end{enumerate}

Here's the resulting BST:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    8((8)) {-}{-}\textgreater{} 4((4))}
\NormalTok{    8 {-}{-}\textgreater{} 12((12))}
\NormalTok{    4 {-}{-}\textgreater{} 2((2))}
\NormalTok{    4 {-}{-}\textgreater{} 6((6))}
\NormalTok{    2 {-}{-}\textgreater{} 1((1))}
\NormalTok{    2 {-}{-}\textgreater{} 3((3))}
\NormalTok{    6 {-}{-}\textgreater{} 5((5))}
\NormalTok{    12 {-}{-}\textgreater{} 10((10))}
\NormalTok{    12 {-}{-}\textgreater{} 14((14))}

\NormalTok{    classDef default fill:\#f9f,stroke:\#333,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  In-order Traversal:

  \begin{itemize}
  \tightlist
  \item
    Algorithm: Visit left subtree, visit root, visit right subtree
  \item
    Process:

    \begin{itemize}
    \tightlist
    \item
      Start at the root (8)
    \item
      Traverse left subtree completely
    \item
      Visit the root
    \item
      Traverse right subtree completely
    \end{itemize}
  \end{itemize}
\item
  In-order Traversal Sequence: 1, 2, 3, 4, 5, 6, 8, 10, 12, 14
\end{enumerate}

Explanation of the traversal: - Start at 8, go left to 4, then to 2,
then to 1 - Visit 1, go back to 2, visit 2, go right to 3 - Visit 3, go
back to 4, visit 4, go right to 6 - Go left to 5, visit 5, go back to 6,
visit 6 - Go back to 8, visit 8 - Go right to 12, go left to 10, visit
10 - Go back to 12, visit 12, go right to 14, visit 14

This in-order traversal results in the numbers being visited in
ascending order, which is a property of in-order traversal in a BST.

\hypertarget{q5cor-8-4-12-2-6-10-14-1-3-5-uxaa8uxaaeuxaacuxab0-uxaaeuxa9f-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa9fuxab0-uxaa6uxab0-uxa85uxaa8-uxa9fuxab0-uxaaeuxa9f-uxa87uxaa8-uxa93uxab0uxaa1uxab0-uxa9fuxab0uxab5uxab0uxab8uxab2-uxab2uxa96.-uxae6uxaed}{%
\subsubsection{Q5cOR: 8, 4, 12, 2, 6, 10, 14, 1, 3, 5 નમ્બર માટે બાયનરી
સર્ચ ટ્રી દોરો અને ટ્રી માટે ઇન ઓર્ડર ટ્રાવર્સલ લખો.
(૦૭)}\label{q5cor-8-4-12-2-6-10-14-1-3-5-uxaa8uxaaeuxaacuxab0-uxaaeuxa9f-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9a-uxa9fuxab0-uxaa6uxab0-uxa85uxaa8-uxa9fuxab0-uxaaeuxa9f-uxa87uxaa8-uxa93uxab0uxaa1uxab0-uxa9fuxab0uxab5uxab0uxab8uxab2-uxab2uxa96.-uxae6uxaed}}

ચાલો, પગલે પગલે બાયનરી સર્ચ ટ્રી (BST) બનાવીએ અને પછી ઇન-ઓર્ડર ટ્રાવર્સલ કરીએ.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  BST નિર્માણ:

  \begin{itemize}
  \tightlist
  \item
    8 ને રૂટ તરીકે શરૂ કરો
  \item
    BST નિયમો અનુસાર દરેક નંબરને એક પછી એક દાખલ કરો
  \end{itemize}
\end{enumerate}

અહીં પરિણામી BST છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    8((8)) {-}{-}\textgreater{} 4((4))}
\NormalTok{    8 {-}{-}\textgreater{} 12((12))}
\NormalTok{    4 {-}{-}\textgreater{} 2((2))}
\NormalTok{    4 {-}{-}\textgreater{} 6((6))}
\NormalTok{    2 {-}{-}\textgreater{} 1((1))}
\NormalTok{    2 {-}{-}\textgreater{} 3((3))}
\NormalTok{    6 {-}{-}\textgreater{} 5((5))}
\NormalTok{    12 {-}{-}\textgreater{} 10((10))}
\NormalTok{    12 {-}{-}\textgreater{} 14((14))}

\NormalTok{    classDef default fill:\#f9f,stroke:\#333,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  ઇન-ઓર્ડર ટ્રાવર્સલ:

  \begin{itemize}
  \tightlist
  \item
    અલ્ગોરિધમ: ડાબા સબટ્રીની મુલાકાત લો, રૂટની મુલાકાત લો, જમણા સબટ્રીની
    મુલાકાત લો
  \item
    પ્રક્રિયા:

    \begin{itemize}
    \tightlist
    \item
      રૂટ (8) થી શરૂ કરો
    \item
      ડાબા સબટ્રીને સંપૂર્ણપણે ટ્રાવર્સ કરો
    \item
      રૂટની મુલાકાત લો
    \item
      જમણા સબટ્રીને સંપૂર્ણપણે ટ્રાવર્સ કરો
    \end{itemize}
  \end{itemize}
\item
  ઇન-ઓર્ડર ટ્રાવર્સલ ક્રમ: 1, 2, 3, 4, 5, 6, 8, 10, 12, 14
\end{enumerate}

ટ્રાવર્સલની સમજૂતી: - 8 થી શરૂ કરો, ડાબે 4 પર જાઓ, પછી 2 પર, પછી 1 પર - 1 ની
મુલાકાત લો, 2 પર પાછા જાઓ, 2 ની મુલાકાત લો, જમણે 3 પર જાઓ - 3 ની મુલાકાત લો,
4 પર પાછા જાઓ, 4 ની મુલાકાત લો, જમણે 6 પર જાઓ - ડાબે 5 પર જાઓ, 5 ની મુલાકાત
લો, 6 પર પાછા જાઓ, 6 ની મુલાકાત લો - 8 પર પાછા જાઓ, 8 ની મુલાકાત લો - જમણે
12 પર જાઓ, ડાબે 10 પર જાઓ, 10 ની મુલાકાત લો - 12 પર પાછા જાઓ, 12 ની મુલાકાત
લો, જમણે 14 પર જાઓ, 14 ની મુલાકાત લો

આ ઇન-ઓર્ડર ટ્રાવર્સલ પરિણામે નંબરોની મુલાકાત ચડતા ક્રમમાં લેવાય છે, જે BST માં
ઇન-ઓર્ડર ટ્રાવર્સલની એક વિશેષતા છે.

\hypertarget{dsa-winter-2023}{%
\subsection{1333203 DSA Winter 2023}\label{dsa-winter-2023}}

\hypertarget{q1a-define-linked-list.-list-different-types-of-linked-list.-03-marks}{%
\subsubsection{Q1a: Define linked list. List different types of linked
list. (03
marks)}\label{q1a-define-linked-list.-list-different-types-of-linked-list.-03-marks}}

\textbf{Ans 1a:} A linked list is a dynamic data structure consisting of
a sequence of elements, where each element (called a node) contains data
and a reference (or link) to the next element in the sequence. Unlike
arrays, linked lists do not store elements in contiguous memory
locations, allowing for efficient insertion and deletion operations.

Key characteristics of linked lists: - Dynamic size: Can grow or shrink
during program execution - Non-contiguous memory allocation: Elements
can be stored anywhere in memory - Efficient insertion and deletion:
O(1) time complexity for operations at the beginning or end

Different types of linked lists:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Singly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Each node contains data and a single reference to the next node
  \item
    Last node points to NULL, indicating the end of the list
  \end{itemize}
\item
  \textbf{Doubly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Each node contains data and two references: one to the next node and
    one to the previous node
  \item
    Allows traversal in both directions
  \end{itemize}
\item
  \textbf{Circular Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Similar to singly linked list, but the last node points back to the
    first node
  \item
    Forms a closed loop
  \end{itemize}
\item
  \textbf{Circular Doubly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Combines features of doubly linked and circular linked lists
  \item
    Last node's next pointer points to the first node, and first node's
    previous pointer points to the last node
  \end{itemize}
\item
  \textbf{Header Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Contains a special header node at the beginning
  \item
    Header node may store metadata about the list (e.g., size, pointers
    to first and last elements)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Node 1] {-}{-}\textgreater{} B[Node 2]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 3]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 4]}
\NormalTok{    D {-}{-}\textgreater{} E[NULL]}
\NormalTok{    style A fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style B fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style C fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style D fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style E fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa85-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxab5uxab5uxaa7-uxaaauxab0uxa95uxab0uxaa8-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 1અ: લીન્કડ લીસ્ટની વ્યાખ્યા આપો. વિવિધ પ્રકારના લિન્ક્ડ
લીસ્ટ ની યાદી આપો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-1uxa85-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxab5uxab5uxaa7-uxaaauxab0uxa95uxab0uxaa8-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 1અ:} linked list એ એક ડાયનેમિક ડેટા સ્ટ્રક્ચર છે જેમાં એલિમેન્ટ્સનો
ક્રમ હોય છે, જ્યાં દરેક એલિમેન્ટ (જેને node કહેવાય છે) ડેટા અને ક્રમમાં આગળના એલિમેન્ટનો
સંદર્ભ (અથવા link) ધરાવે છે. એરેઝથી વિપરીત, linked lists એલિમેન્ટ્સને સતત મેમરી
સ્થાનોમાં સંગ્રહિત કરતા નથી, જે insertion અને deletion ઓપરેશન્સને કાર્યક્ષમ બનાવે છે.

linked lists ની મુખ્ય લાક્ષણિકતાઓ: - ડાયનેમિક કદ: પ્રોગ્રામ એક્ઝીક્યુશન દરમિયાન
વધી અથવા ઘટી શકે છે - નોન-કન્ટીગ્યુઅસ મેમરી એલોકેશન: એલિમેન્ટ્સ મેમરીમાં ગમે ત્યાં સ્ટોર
કરી શકાય છે - કાર્યક્ષમ insertion અને deletion: શરૂઆત અથવા અંતમાં ઓપરેશન્સ માટે
O(1) સમય જટિલતા

વિવિધ પ્રકારના linked lists:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Singly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    દરેક node ડેટા અને આગળના node નો એક સિંગલ સંદર્ભ ધરાવે છે
  \item
    છેલ્લું node NULL તરફ પોઈન્ટ કરે છે, જે લિસ્ટના અંતને સૂચવે છે
  \end{itemize}
\item
  \textbf{Doubly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    દરેક node ડેટા અને બે સંદર્ભો ધરાવે છે: એક આગળના node માટે અને એક પાછલા node
    માટે
  \item
    બંને દિશાઓમાં ટ્રાવર્સલની મંજૂરી આપે છે
  \end{itemize}
\item
  \textbf{Circular Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List જેવું જ, પરંતુ છેલ્લું node પ્રથમ node તરફ પાછું પોઈન્ટ કરે છે
  \item
    બંધ લૂપ બનાવે છે
  \end{itemize}
\item
  \textbf{Circular Doubly Linked List}:

  \begin{itemize}
  \tightlist
  \item
    Doubly Linked અને Circular Linked Lists ની વિશેષતાઓને જોડે છે
  \item
    છેલ્લા node નો next pointer પ્રથમ node તરફ પોઈન્ટ કરે છે, અને પ્રથમ node નો
    previous pointer છેલ્લા node તરફ પોઈન્ટ કરે છે
  \end{itemize}
\item
  \textbf{Header Linked List}:

  \begin{itemize}
  \tightlist
  \item
    શરૂઆતમાં એક વિશેષ header node ધરાવે છે
  \item
    Header node લિસ્ટ વિશેના મેટાડેટા સ્ટોર કરી શકે છે (દા.ત., કદ, પ્રથમ અને છેલ્લા
    એલિમેન્ટ્સના pointers)
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Node 1] {-}{-}\textgreater{} B[Node 2]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 3]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 4]}
\NormalTok{    D {-}{-}\textgreater{} E[NULL]}
\NormalTok{    style A fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style B fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style C fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style D fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style E fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\end{Highlighting}
\end{Shaded}

\hypertarget{q1b-explain-linear-and-non-linear-data-structure-in-python-with-examples.-04-marks}{%
\subsubsection{Q1b: Explain Linear and Non Linear Data structure in
Python with examples. (04
marks)}\label{q1b-explain-linear-and-non-linear-data-structure-in-python-with-examples.-04-marks}}

\textbf{Ans 1b:} Data structures in Python can be categorized into two
main types: Linear and Non-Linear. These categories differ in how they
organize and allow access to data elements.

\textbf{1. Linear Data Structures:} Linear data structures are those in
which data elements are arranged sequentially or linearly. Each element
is directly connected to its previous and next elements (if they exist).

Characteristics: - Elements are arranged in a sequential order - Each
element has at most one predecessor and one successor - Data can be
traversed in a single run

Examples in Python:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Lists:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}apple\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}banana\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cherry\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(fruits[}\DecValTok{1}\NormalTok{])  }\CommentTok{\# Output: banana}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Tuples:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coordinates }\OperatorTok{=}\NormalTok{ (}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(coordinates[}\DecValTok{0}\NormalTok{])  }\CommentTok{\# Output: 10}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  Strings:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Hello"}
\BuiltInTok{print}\NormalTok{(message[}\DecValTok{2}\NormalTok{])  }\CommentTok{\# Output: l}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  Stack (implemented using a list):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}
\NormalTok{stack.append(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}
\NormalTok{stack.append(}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(stack.pop())  }\CommentTok{\# Output: b}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{4}
\tightlist
\item
  Queue (using collections.deque):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ deque}
\NormalTok{queue }\OperatorTok{=}\NormalTok{ deque([}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{])}
\NormalTok{queue.append(}\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(queue.popleft())  }\CommentTok{\# Output: x}
\end{Highlighting}
\end{Shaded}

\textbf{2. Non-Linear Data Structures:} Non-linear data structures are
those in which data elements are not arranged sequentially. Each element
can be connected to multiple other elements.

Characteristics: - Elements are not arranged in a sequential order - An
element can be connected to multiple other elements - Data cannot be
traversed in a single run

Examples in Python:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Dictionaries:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{person }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}John\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}age\textquotesingle{}}\NormalTok{: }\DecValTok{30}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(person[}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{])  }\CommentTok{\# Output: John}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Sets:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unique\_numbers }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{\}}
\NormalTok{unique\_numbers.add(}\DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(unique\_numbers)  }\CommentTok{\# Output: \{1, 2, 3, 4, 5, 6\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  Trees (implemented using a class):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ TreeNode:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, value):}
        \VariableTok{self}\NormalTok{.value }\OperatorTok{=}\NormalTok{ value}
        \VariableTok{self}\NormalTok{.left }\OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.right }\OperatorTok{=} \VariableTok{None}

\NormalTok{root }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{1}\NormalTok{)}
\NormalTok{root.left }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{2}\NormalTok{)}
\NormalTok{root.right }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  Graphs (using a dictionary):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Linear Data Structures] {-}{-}\textgreater{} B[Lists]}
\NormalTok{    A {-}{-}\textgreater{} C[Tuples]}
\NormalTok{    A {-}{-}\textgreater{} D[Strings]}
\NormalTok{    A {-}{-}\textgreater{} E[Stacks]}
\NormalTok{    A {-}{-}\textgreater{} F[Queues]}
\NormalTok{    G[Non{-}Linear Data Structures] {-}{-}\textgreater{} H[Dictionaries]}
\NormalTok{    G {-}{-}\textgreater{} I[Sets]}
\NormalTok{    G {-}{-}\textgreater{} J[Trees]}
\NormalTok{    G {-}{-}\textgreater{} K[Graphs]}
\NormalTok{    style A fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style G fill:\#bbf,stroke:\#333,stroke{-}width:2px}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxaac-uxaaauxaafuxaa5uxaa8uxaae-uxab2uxaa8uxaafuxab0-uxa85uxaa8-uxaa8uxaa8-uxab2uxaa8uxaafuxab0-uxaa1uxa9f-uxab8uxa9fuxab0uxa95uxa9auxab0-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 1બ: પાયથનમાં લીનીયર અને નોન-લીનીયર ડેટા સ્ટ્રક્ચર ઉદાહરણ
સાથે સમજાવો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-1uxaac-uxaaauxaafuxaa5uxaa8uxaae-uxab2uxaa8uxaafuxab0-uxa85uxaa8-uxaa8uxaa8-uxab2uxaa8uxaafuxab0-uxaa1uxa9f-uxab8uxa9fuxab0uxa95uxa9auxab0-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 1બ:} પાયથનમાં ડેટા સ્ટ્રક્ચર્સને બે મુખ્ય પ્રકારોમાં વર્ગીકૃત કરી શકાય છે:
લીનીયર અને નોન-લીનીયર. આ વર્ગીકરણો ડેટા એલિમેન્ટ્સને કેવી રીતે વ્યવસ્થિત કરે છે અને
તેમના ઍક્સેસની મંજૂરી આપે છે તેના આધારે અલગ પડે છે.

\textbf{1. લીનીયર ડેટા સ્ટ્રક્ચર્સ:} લીનીયર ડેટા સ્ટ્રક્ચર્સ એ છે જેમાં ડેટા એલિમેન્ટ્સ
અનુક્રમિક અથવા રેખીય રીતે ગોઠવાયેલા હોય છે. દરેક એલિમેન્ટ તેના અગાઉના અને પછીના
એલિમેન્ટ્સ સાથે સીધું જોડાયેલું હોય છે (જો તે અસ્તિત્વમાં હોય તો).

લાક્ષણિકતાઓ: - એલિમેન્ટ્સ અનુક્રમિક ક્રમમાં ગોઠવાયેલા હોય છે - દરેક એલિમેન્ટને વધુમાં વધુ
એક પૂર્વગામી અને એક અનુગામી હોય છે - ડેટાને એક જ રનમાં ટ્રાવર્સ કરી શકાય છે

પાયથનમાં ઉદાહરણો:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Lists:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}apple\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}banana\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}cherry\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(fruits[}\DecValTok{1}\NormalTok{])  }\CommentTok{\# આઉટપુટ: banana}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Tuples:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coordinates }\OperatorTok{=}\NormalTok{ (}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(coordinates[}\DecValTok{0}\NormalTok{])  }\CommentTok{\# આઉટપુટ: 10}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  Strings:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message }\OperatorTok{=} \StringTok{"Hello"}
\BuiltInTok{print}\NormalTok{(message[}\DecValTok{2}\NormalTok{])  }\CommentTok{\# આઉટપુટ: l}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  Stack (લિસ્ટનો ઉપયોગ કરીને અમલીકરણ):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}
\NormalTok{stack.append(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}
\NormalTok{stack.append(}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(stack.pop())  }\CommentTok{\# આઉટપુટ: b}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{4}
\tightlist
\item
  Queue (collections.deque નો ઉપયોગ કરીને):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ deque}
\NormalTok{queue }\OperatorTok{=}\NormalTok{ deque([}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{])}
\NormalTok{queue.append(}\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(queue.popleft())  }\CommentTok{\# આઉટપુટ: x}
\end{Highlighting}
\end{Shaded}

\textbf{2. નોન-લીનીયર ડેટા સ્ટ્રક્ચર્સ:} નોન-લીનીયર ડેટા સ્ટ્રક્ચર્સ એ છે જેમાં ડેટા
એલિમેન્ટ્સ અનુક્રમિક રીતે ગોઠવાયેલા નથી. દરેક એલિમેન્ટ અન્ય ઘણા એલિમેન્ટ્સ સાથે જોડાયેલું
હોઈ શકે છે.

લાક્ષણિકતાઓ: - એલિમેન્ટ્સ અનુક્રમિક ક્રમમાં ગોઠવાયેલા નથી - એક એલિમેન્ટ અન્ય ઘણા
એલિમેન્ટ્સ સાથે જોડાયેલું હોઈ શકે છે - ડેટાને એક જ રનમાં ટ્રાવર્સ કરી શકાતો નથી

પાયથનમાં ઉદાહરણો:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Dictionaries:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{person }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}John\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}age\textquotesingle{}}\NormalTok{: }\DecValTok{30}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(person[}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{])  }\CommentTok{\# આઉટપુટ: John}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Sets:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unique\_numbers }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{\}}
\NormalTok{unique\_numbers.add(}\DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(unique\_numbers)  }\CommentTok{\# આઉટપુટ: \{1, 2, 3, 4, 5, 6\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  Trees (ક્લાસનો ઉપયોગ કરીને અમલીકરણ):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ TreeNode:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, value):}
        \VariableTok{self}\NormalTok{.value }\OperatorTok{=}\NormalTok{ value}
        \VariableTok{self}\NormalTok{.left }\OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.right }\OperatorTok{=} \VariableTok{None}

\NormalTok{root }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{1}\NormalTok{)}
\NormalTok{root.left }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{2}\NormalTok{)}
\NormalTok{root.right }\OperatorTok{=}\NormalTok{ TreeNode(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  Graphs (ડિક્શનરીનો ઉપયોગ કરીને):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{],}
    \StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[લીનીયર ડેટા સ્ટ્રક્ચર્સ] {-}{-}\textgreater{} B[Lists]}
\NormalTok{    A {-}{-}\textgreater{} C[Tuples]}
\NormalTok{    A {-}{-}\textgreater{} D[Strings]}
\NormalTok{    A {-}{-}\textgreater{} E[Stacks]}
\NormalTok{    A {-}{-}\textgreater{} F[Queues]}
\NormalTok{    G[નોન{-}લીનીયર ડેટા સ્ટ્રક્ચર્સ] {-}{-}\textgreater{} H[Dictionaries]}
\NormalTok{    G {-}{-}\textgreater{} I[Sets]}
\NormalTok{    G {-}{-}\textgreater{} J[Trees]}
\NormalTok{    G {-}{-}\textgreater{} K[Graphs]}
\NormalTok{    style A fill:\#f9f,stroke:\#333,stroke{-}width:2px}
\NormalTok{    style G fill:\#bbf,stroke:\#333,stroke{-}width:2px}
\end{Highlighting}
\end{Shaded}

\hypertarget{q1c-explain-class-attributes-object-and-class-method-in-python-with-suitable-example.-07-marks}{%
\subsubsection{Q1c: Explain class, attributes, object and class method
in python with suitable example. (07
marks)}\label{q1c-explain-class-attributes-object-and-class-method-in-python-with-suitable-example.-07-marks}}

\textbf{Ans 1c:} In Python, object-oriented programming (OOP) is
implemented using classes and objects. Let's explore these concepts
along with attributes and class methods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Class}: A class is a blueprint for creating objects. It
  defines a set of attributes and methods that the objects of that class
  will have.
\item
  \textbf{Attributes}: Attributes are variables that hold data
  associated with a class or its instances. There are two types of
  attributes:

  \begin{itemize}
  \tightlist
  \item
    Instance attributes: Unique to each instance
  \item
    Class attributes: Shared among all instances of the class
  \end{itemize}
\item
  \textbf{Object}: An object is an instance of a class. It's a concrete
  entity based on the class blueprint.
\item
  \textbf{Class Method}: A class method is a method that is bound to the
  class and not the instance of the class. It can access and modify
  class state.
\end{enumerate}

Let's illustrate these concepts with an example of a \texttt{Car} class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Car:}
    \CommentTok{\# Class attribute}
\NormalTok{    number\_of\_cars }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, make, model, year):}
        \CommentTok{\# Instance attributes}
        \VariableTok{self}\NormalTok{.make }\OperatorTok{=}\NormalTok{ make}
        \VariableTok{self}\NormalTok{.model }\OperatorTok{=}\NormalTok{ model}
        \VariableTok{self}\NormalTok{.year }\OperatorTok{=}\NormalTok{ year}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}
\NormalTok{        Car.number\_of\_cars }\OperatorTok{+=} \DecValTok{1}

    \KeywordTok{def}\NormalTok{ accelerate(}\VariableTok{self}\NormalTok{, increment):}
        \CommentTok{"""Instance method to increase speed"""}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{+=}\NormalTok{ increment}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ is now going }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ km/h"}\NormalTok{)}

    \AttributeTok{@classmethod}
    \KeywordTok{def}\NormalTok{ total\_cars(cls):}
        \CommentTok{"""Class method to return total number of cars"""}
        \ControlFlowTok{return} \SpecialStringTok{f"Total number of cars: }\SpecialCharTok{\{}\NormalTok{cls}\SpecialCharTok{.}\NormalTok{number\_of\_cars}\SpecialCharTok{\}}\SpecialStringTok{"}

    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ company\_slogan():}
        \CommentTok{"""Static method for company slogan"""}
        \ControlFlowTok{return} \StringTok{"We build awesome cars!"}

\CommentTok{\# Creating objects (instances) of the Car class}
\NormalTok{car1 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Toyota"}\NormalTok{, }\StringTok{"Corolla"}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\NormalTok{car2 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Honda"}\NormalTok{, }\StringTok{"Civic"}\NormalTok{, }\DecValTok{2021}\NormalTok{)}

\CommentTok{\# Accessing instance attributes}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Car 1: }\SpecialCharTok{\{}\NormalTok{car1}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{car1}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Car 2: }\SpecialCharTok{\{}\NormalTok{car2}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{car2}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Calling instance method}
\NormalTok{car1.accelerate(}\DecValTok{50}\NormalTok{)}

\CommentTok{\# Accessing class attribute and calling class method}
\BuiltInTok{print}\NormalTok{(Car.total\_cars())}

\CommentTok{\# Calling static method}
\BuiltInTok{print}\NormalTok{(Car.company\_slogan())}
\end{Highlighting}
\end{Shaded}

Explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Class Definition}: The \texttt{Car} class is defined with the
  \texttt{class} keyword.
\item
  \textbf{Attributes}:

  \begin{itemize}
  \tightlist
  \item
    Class attribute: \texttt{number\_of\_cars} is shared among all
    instances.
  \item
    Instance attributes: \texttt{make}, \texttt{model}, \texttt{year},
    and \texttt{speed} are unique to each car object.
  \end{itemize}
\item
  \textbf{Methods}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_\_init\_\_}: Constructor method to initialize instance
    attributes.
  \item
    \texttt{accelerate}: Instance method that modifies the object's
    state.
  \item
    \texttt{total\_cars}: Class method (decorated with
    \texttt{@classmethod}) that accesses class state.
  \item
    \texttt{company\_slogan}: Static method (decorated with
    \texttt{@staticmethod}) that doesn't access instance or class state.
  \end{itemize}
\item
  \textbf{Objects}: \texttt{car1} and \texttt{car2} are instances of the
  \texttt{Car} class, created with specific attribute values.
\item
  \textbf{Accessing Attributes and Methods}:

  \begin{itemize}
  \tightlist
  \item
    Instance attributes are accessed using dot notation:
    \texttt{car1.make}
  \item
    Instance methods are called on objects: \texttt{car1.accelerate(50)}
  \item
    Class methods are called on the class: \texttt{Car.total\_cars()}
  \item
    Static methods can be called on either the class or an instance:
    \texttt{Car.company\_slogan()}
  \end{itemize}
\end{enumerate}

This example demonstrates the core concepts of OOP in Python, showing
how classes encapsulate data (attributes) and behavior (methods), and
how objects are instantiated from these classes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class Car \{}
\NormalTok{        +number\_of\_cars: int}
\NormalTok{        {-}make: str}
\NormalTok{        {-}model: str}
\NormalTok{        {-}year: int}
\NormalTok{        {-}speed: int}
\NormalTok{        +\_\_init\_\_(make: str, model: str, year: int)}
\NormalTok{        +accelerate(increment: int): void}
\NormalTok{        +total\_cars(): str}
\NormalTok{        +company\_slogan(): str}
\NormalTok{    \}}
\NormalTok{    Car {-}{-}\textgreater{} "2" Car : creates}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa95-uxaaauxaafuxaa5uxaa8uxaae-uxa95uxab2uxab8-uxa8fuxa9fuxab0uxaacuxaafuxa9fuxab8-uxa93uxaacuxa9cuxa95uxa9f-uxa85uxaa8-uxa95uxab2uxab8-uxaaeuxaa5uxaa1-uxaafuxa97uxaaf-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 1ક: પાયથનમાં ક્લાસ, એટ્રિબ્યુટ્સ, ઓબ્જેક્ટ અને ક્લાસ મેથડ યોગ્ય
ઉદાહરણ સાથે સમજાવો. (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-1uxa95-uxaaauxaafuxaa5uxaa8uxaae-uxa95uxab2uxab8-uxa8fuxa9fuxab0uxaacuxaafuxa9fuxab8-uxa93uxaacuxa9cuxa95uxa9f-uxa85uxaa8-uxa95uxab2uxab8-uxaaeuxaa5uxaa1-uxaafuxa97uxaaf-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 1ક:} પાયથનમાં, ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ (OOP) ક્લાસ અને
ઓબ્જેક્ટ્સનો ઉપયોગ કરીને અમલમાં મૂકવામાં આવે છે. આ વિભાવનાઓને એટ્રિબ્યુટ્સ અને ક્લાસ મેથડ્સ
સાથે સમજીએ.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{ક્લાસ (Class)}: ક્લાસ એ ઓબ્જેક્ટ્સ બનાવવા માટેનો બ્લુપ્રિન્ટ છે. તે
  એટ્રિબ્યુટ્સ અને મેથડ્સનો સેટ વ્યાખ્યાયિત કરે છે જે તે ક્લાસના ઓબ્જેક્ટ્સ ધરાવશે.
\item
  \textbf{એટ્રિબ્યુટ્સ (Attributes)}: એટ્રિબ્યુટ્સ એ વેરિએબલ્સ છે જે ક્લાસ અથવા તેના
  ઇન્સ્ટન્સ સાથે સંકળાયેલ ડેટા ધરાવે છે. બે પ્રકારના એટ્રિબ્યુટ્સ છે:

  \begin{itemize}
  \tightlist
  \item
    ઇન્સ્ટન્સ એટ્રિબ્યુટ્સ: દરેક ઇન્સ્ટન્સ માટે અનન્ય
  \item
    ક્લાસ એટ્રિબ્યુટ્સ: ક્લાસના તમામ ઇન્સ્ટન્સ વચ્ચે શેર કરેલ
  \end{itemize}
\item
  \textbf{ઓબ્જેક્ટ (Object)}: ઓબ્જેક્ટ એ ક્લાસનું ઇન્સ્ટન્સ છે. તે ક્લાસ બ્લુપ્રિન્ટ પર
  આધારિત ઠોસ એન્ટિટી છે.
\item
  \textbf{ક્લાસ મેથડ (Class Method)}: ક્લાસ મેથડ એ એક મેથડ છે જે ક્લાસ સાથે બંધાયેલ
  છે, ક્લાસના ઇન્સ્ટન્સ સાથે નહીં. તે ક્લાસ સ્થિતિને ઍક્સેસ અને સંશોધિત કરી શકે છે.
\end{enumerate}

આ વિભાવનાઓને \texttt{Car} ક્લાસના ઉદાહરણ સાથે સમજાવીએ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Car:}
    \CommentTok{\# ક્લાસ એટ્રિબ્યુટ}
\NormalTok{    number\_of\_cars }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, make, model, year):}
        \CommentTok{\# ઇન્સ્ટન્સ એટ્રિબ્યુટ્સ}
        \VariableTok{self}\NormalTok{.make }\OperatorTok{=}\NormalTok{ make}
        \VariableTok{self}\NormalTok{.model }\OperatorTok{=}\NormalTok{ model}
        \VariableTok{self}\NormalTok{.year }\OperatorTok{=}\NormalTok{ year}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{=} \DecValTok{0}
\NormalTok{        Car.number\_of\_cars }\OperatorTok{+=} \DecValTok{1}

    \KeywordTok{def}\NormalTok{ accelerate(}\VariableTok{self}\NormalTok{, increment):}
        \CommentTok{"""ગતિ વધારવા માટેની ઇન્સ્ટન્સ મેથડ"""}
        \VariableTok{self}\NormalTok{.speed }\OperatorTok{+=}\NormalTok{ increment}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{ હવે }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{speed}\SpecialCharTok{\}}\SpecialStringTok{ કિમી/કલાક પર જઈ રહી છે"}\NormalTok{)}

    \AttributeTok{@classmethod}
    \KeywordTok{def}\NormalTok{ total\_cars(cls):}
        \CommentTok{"""કુલ કારની સંખ્યા પરત કરવા માટેની ક્લાસ મેથડ"""}
        \ControlFlowTok{return} \SpecialStringTok{f"કુલ કારની સંખ્યા: }\SpecialCharTok{\{}\NormalTok{cls}\SpecialCharTok{.}\NormalTok{number\_of\_cars}\SpecialCharTok{\}}\SpecialStringTok{"}

    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ company\_slogan():}
        \CommentTok{"""કંપનીના સ્લોગન માટેની સ્ટેટિક મેથડ"""}
        \ControlFlowTok{return} \StringTok{"અમે અદ્ભુત કાર બનાવીએ છીએ!"}

\CommentTok{\# Car ક્લાસના ઓબ્જેક્ટ્સ (ઇન્સ્ટન્સ) બનાવવા}
\NormalTok{car1 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Toyota"}\NormalTok{, }\StringTok{"Corolla"}\NormalTok{, }\DecValTok{2020}\NormalTok{)}
\NormalTok{car2 }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Honda"}\NormalTok{, }\StringTok{"Civic"}\NormalTok{, }\DecValTok{2021}\NormalTok{)}

\CommentTok{\# ઇન્સ્ટન્સ એટ્રિબ્યુટ્સને ઍક્સેસ કરવું}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"કાર 1: }\SpecialCharTok{\{}\NormalTok{car1}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{car1}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"કાર 2: }\SpecialCharTok{\{}\NormalTok{car2}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{car2}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# ઇન્સ્ટન્સ મેથડને કૉલ કરવી}
\NormalTok{car1.accelerate(}\DecValTok{50}\NormalTok{)}

\CommentTok{\# ક્લાસ એટ્રિબ્યુટને ઍક્સેસ કરવું અને ક્લાસ મેથડને કૉલ કરવી}
\BuiltInTok{print}\NormalTok{(Car.total\_cars())}

\CommentTok{\# સ્ટેટિક મેથડને કૉલ કરવી}
\BuiltInTok{print}\NormalTok{(Car.company\_slogan())}
\end{Highlighting}
\end{Shaded}

સમજૂતી:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{ક્લાસ વ્યાખ્યા}: \texttt{Car} ક્લાસ \texttt{class} કીવર્ડ સાથે
  વ્યાખ્યાયિત કરવામાં આવે છે.
\item
  \textbf{એટ્રિબ્યુટ્સ}:

  \begin{itemize}
  \tightlist
  \item
    ક્લાસ એટ્રિબ્યુટ: \texttt{number\_of\_cars} તમામ ઇન્સ્ટન્સ વચ્ચે શેર કરવામાં આવે
    છે.
  \item
    ઇન્સ્ટન્સ એટ્રિબ્યુટ્સ: \texttt{make}, \texttt{model}, \texttt{year}, અને
    \texttt{speed} દરેક કાર ઓબ્જેક્ટ માટે અનન્ય છે.
  \end{itemize}
\item
  \textbf{મેથડ્સ}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_\_init\_\_}: ઇન્સ્ટન્સ એટ્રિબ્યુટ્સને પ્રારંભિક કરવા માટેની કન્સ્ટ્રક્ટર
    મેથડ.
  \item
    \texttt{accelerate}: ઓબ્જેક્ટની સ્થિતિને સંશોધિત કરતી ઇન્સ્ટન્સ મેથડ.
  \item
    \texttt{total\_cars}: ક્લાસ સ્થિતિને ઍક્સેસ કરતી ક્લાસ મેથડ
    (\texttt{@classmethod} સાથે ડેકોરેટેડ).
  \item
    \texttt{company\_slogan}: ઇન્સ્ટન્સ અથવા ક્લાસ સ્થિતિને ઍક્સેસ ન કરતી સ્ટેટિક
    મેથડ (\texttt{@staticmethod} સાથે ડેકોરેટેડ).
  \end{itemize}
\item
  \textbf{ઓબ્જેક્ટ્સ}: \texttt{car1} અને \texttt{car2} એ \texttt{Car} ક્લાસના
  ઇન્સ્ટન્સ છે, જે ચોક્કસ એટ્રિબ્યુટ મૂલ્યો સાથે બનાવવામાં આવ્યા છે.
\item
  \textbf{એટ્રિબ્યુટ્સ અને મેથડ્સને ઍક્સેસ કરવું}:

  \begin{itemize}
  \tightlist
  \item
    ઇન્સ્ટન્સ એટ્રિબ્યુટ્સને ડોટ નોટેશનનો ઉપયોગ કરીને ઍક્સેસ કરવામાં આવે છે:
    \texttt{car1.make}
  \item
    ઇન્સ્ટન્સ મેથડ્સને ઓબ્જેક્ટ્સ પર કૉલ કરવામાં આવે છે: \texttt{car1.accelerate(50)}
  \item
    ક્લાસ મેથડ્સને ક્લાસ પર કૉલ કરવામાં આવે છે: \texttt{Car.total\_cars()}
  \item
    સ્ટેટિક મેથડ્સને ક્લાસ અથવા ઇન્સ્ટન્સ પર કૉલ કરી શકાય છે:
    \texttt{Car.company\_slogan()}
  \end{itemize}
\end{enumerate}

આ ઉદાહરણ પાયથનમાં OOP ના મુખ્ય ખ્યાલોને દર્શાવે છે, જે બતાવે છે કે કેવી રીતે ક્લાસ ડેટા
(એટ્રિબ્યુટ્સ) અને વર્તણૂક (મેથડ્સ) ને એનકેપ્સ્યુલેટ કરે છે, અને કેવી રીતે આ ક્લાસમાંથી ઓબ્જેક્ટ્સ
બનાવવામાં આવે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    class Car \{}
\NormalTok{        +number\_of\_cars: int}
\NormalTok{        {-}make: str}
\NormalTok{        {-}model: str}
\NormalTok{        {-}year: int}
\NormalTok{        {-}speed: int}
\NormalTok{        +\_\_init\_\_(make: str, model: str, year: int)}
\NormalTok{        +accelerate(increment: int): void}
\NormalTok{        +total\_cars(): str}
\NormalTok{        +company\_slogan(): str}
\NormalTok{    \}}
\NormalTok{    Car {-}{-}\textgreater{} "2" Car : બનાવે છે}
\end{Highlighting}
\end{Shaded}

\hypertarget{q1cor-define-data-encapsulation-polymorphism.-develop-a-python-code-to-explain-polymorphism.-07-marks}{%
\subsubsection{Q1cOR: Define Data Encapsulation \& Polymorphism. Develop
a Python code to explain Polymorphism. (07
marks)}\label{q1cor-define-data-encapsulation-polymorphism.-develop-a-python-code-to-explain-polymorphism.-07-marks}}

\textbf{Ans 1cOR:}

\textbf{Data Encapsulation:} Data Encapsulation is an Object-Oriented
Programming concept that binds together the data and the functions that
manipulate the data, keeping both safe from outside interference and
misuse. It wraps the data (variables) and code acting on the data
(methods) together as a single unit. In Python, encapsulation is
achieved using private and protected members along with public
interfaces.

\textbf{Polymorphism:} Polymorphism is the ability of different classes
with the same interface to have different implementations. It allows us
to use a single interface to represent different underlying forms (data
types or classes). Polymorphism enables using a single type of object to
represent various scenarios, making code more flexible and reusable.

Let's develop a Python code to explain Polymorphism:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ abc }\ImportTok{import}\NormalTok{ ABC, abstractmethod}

\KeywordTok{class}\NormalTok{ Shape(ABC):}
    \AttributeTok{@abstractmethod}
    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{pass}

    \AttributeTok{@abstractmethod}
    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{pass}

\KeywordTok{class}\NormalTok{ Rectangle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, length, width):}
        \VariableTok{self}\NormalTok{.length }\OperatorTok{=}\NormalTok{ length}
        \VariableTok{self}\NormalTok{.width }\OperatorTok{=}\NormalTok{ width}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.length }\OperatorTok{*} \VariableTok{self}\NormalTok{.width}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \DecValTok{2} \OperatorTok{*}\NormalTok{ (}\VariableTok{self}\NormalTok{.length }\OperatorTok{+} \VariableTok{self}\NormalTok{.width)}

\KeywordTok{class}\NormalTok{ Circle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, radius):}
        \VariableTok{self}\NormalTok{.radius }\OperatorTok{=}\NormalTok{ radius}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \FloatTok{3.14} \OperatorTok{*} \VariableTok{self}\NormalTok{.radius }\OperatorTok{**} \DecValTok{2}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \DecValTok{2} \OperatorTok{*} \FloatTok{3.14} \OperatorTok{*} \VariableTok{self}\NormalTok{.radius}

\KeywordTok{class}\NormalTok{ Triangle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, a, b, c):}
        \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}
        \VariableTok{self}\NormalTok{.b }\OperatorTok{=}\NormalTok{ b}
        \VariableTok{self}\NormalTok{.c }\OperatorTok{=}\NormalTok{ c}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \CommentTok{\# Using Heron\textquotesingle{}s formula}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.a }\OperatorTok{+} \VariableTok{self}\NormalTok{.b }\OperatorTok{+} \VariableTok{self}\NormalTok{.c) }\OperatorTok{/} \DecValTok{2}
        \ControlFlowTok{return}\NormalTok{ (s }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.a) }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.b) }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.c)) }\OperatorTok{**} \FloatTok{0.5}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.a }\OperatorTok{+} \VariableTok{self}\NormalTok{.b }\OperatorTok{+} \VariableTok{self}\NormalTok{.c}

\KeywordTok{def}\NormalTok{ print\_shape\_info(shape):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Shape: }\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(shape)}\SpecialCharTok{.}\VariableTok{\_\_name\_\_}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Area: }\SpecialCharTok{\{}\NormalTok{shape}\SpecialCharTok{.}\NormalTok{area()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Perimeter: }\SpecialCharTok{\{}\NormalTok{shape}\SpecialCharTok{.}\NormalTok{perimeter()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{()}

\CommentTok{\# Create different shapes}
\NormalTok{rectangle }\OperatorTok{=}\NormalTok{ Rectangle(}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{circle }\OperatorTok{=}\NormalTok{ Circle(}\DecValTok{3}\NormalTok{)}
\NormalTok{triangle }\OperatorTok{=}\NormalTok{ Triangle(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\CommentTok{\# Demonstrate polymorphism}
\NormalTok{shapes }\OperatorTok{=}\NormalTok{ [rectangle, circle, triangle]}

\ControlFlowTok{for}\NormalTok{ shape }\KeywordTok{in}\NormalTok{ shapes:}
\NormalTok{    print\_shape\_info(shape)}
\end{Highlighting}
\end{Shaded}

Explanation of the code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We define an abstract base class \texttt{Shape} with abstract methods
  \texttt{area()} and \texttt{perimeter()}.
\item
  We create three concrete classes: \texttt{Rectangle}, \texttt{Circle},
  and \texttt{Triangle}, each inheriting from \texttt{Shape} and
  implementing its own \texttt{area()} and \texttt{perimeter()} methods.
\item
  The \texttt{print\_shape\_info()} function demonstrates polymorphism.
  It takes a \texttt{shape} parameter and calls the \texttt{area()} and
  \texttt{perimeter()} methods without knowing the specific type of
  shape.
\item
  We create instances of different shapes and store them in a list.
\item
  We iterate through the list of shapes, calling
  \texttt{print\_shape\_info()} for each shape. This demonstrates
  polymorphism as the same function works with different shape objects.
\end{enumerate}

This code showcases polymorphism by allowing different shape objects to
be treated uniformly through a common interface (\texttt{Shape}), while
each shape implements its specific behavior for area and perimeter
calculations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    Shape \textless{}|{-}{-} Rectangle}
\NormalTok{    Shape \textless{}|{-}{-} Circle}
\NormalTok{    Shape \textless{}|{-}{-} Triangle}
\NormalTok{    Shape : +area()}
\NormalTok{    Shape : +perimeter()}
\NormalTok{    Rectangle : {-}length}
\NormalTok{    Rectangle : {-}width}
\NormalTok{    Rectangle : +area()}
\NormalTok{    Rectangle : +perimeter()}
\NormalTok{    Circle : {-}radius}
\NormalTok{    Circle : +area()}
\NormalTok{    Circle : +perimeter()}
\NormalTok{    Triangle : {-}a}
\NormalTok{    Triangle : {-}b}
\NormalTok{    Triangle : {-}c}
\NormalTok{    Triangle : +area()}
\NormalTok{    Triangle : +perimeter()}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-1uxa95or-uxaa1uxa9f-uxa8fuxaa8uxa95uxaaauxab8uxab2uxab8uxaa8-uxa85uxaa8-uxaaauxab2uxaaeuxab0uxaabuxab8uxaaeuxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxaaauxab2uxaaeuxab0uxaabuxab8uxaae-uxab8uxaaeuxa9cuxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 1કOR: ડેટા એન્કેપ્સુલેસન અને પોલીમોર્ફીસમની વ્યાખ્યા આપો.
પોલીમોર્ફીસમ સમજાવવા માટેનો પાયથન કોડ વિકસાવો. (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-1uxa95or-uxaa1uxa9f-uxa8fuxaa8uxa95uxaaauxab8uxab2uxab8uxaa8-uxa85uxaa8-uxaaauxab2uxaaeuxab0uxaabuxab8uxaaeuxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxaaauxab2uxaaeuxab0uxaabuxab8uxaae-uxab8uxaaeuxa9cuxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 1કOR:}

\textbf{ડેટા એન્કેપ્સુલેસન:} ડેટા એન્કેપ્સુલેસન એ ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગનો એક ખ્યાલ
છે જે ડેટા અને ડેટાને હેરફેર કરતા ફંક્શન્સને એકસાથે બાંધે છે, બંનેને બાહ્ય દખલ અને દુરુપયોગથી
સુરક્ષિત રાખે છે. તે ડેટા (વેરિએબલ્સ) અને ડેટા પર કાર્ય કરતા કોડ (મેથડ્સ) ને એક એકમ
તરીકે સાથે રાખે છે. પાયથનમાં, એન્કેપ્સુલેસન પબ્લિક ઇન્ટરફેસ સાથે પ્રાઇવેટ અને પ્રોટેક્ટેડ
સભ્યોનો ઉપયોગ કરીને પ્રાપ્ત કરવામાં આવે છે.

\textbf{પોલીમોર્ફીસમ:} પોલીમોર્ફીસમ એ વિવિધ વર્ગોની એક જ ઇન્ટરફેસ સાથે અલગ અલગ
અમલીકરણ કરવાની ક્ષમતા છે. તે એક જ ઇન્ટરફેસનો ઉપયોગ કરીને વિવિધ અંતર્નિહિત સ્વરૂપો
(ડેટા પ્રકારો અથવા વર્ગો) ને રજૂ કરવાની મંજૂરી આપે છે. પોલીમોર્ફીસમ વિવિધ
પરિસ્થિતિઓનું પ્રતિનિધિત્વ કરવા માટે એક જ પ્રકારના ઓબ્જેક્ટનો ઉપયોગ કરવા સક્ષમ બનાવે
છે, જેથી કોડ વધુ લવચીક અને ફરીથી ઉપયોગ કરી શકાય તેવો બને છે.

ચાલો પોલીમોર્ફીસમ સમજાવવા માટે એક પાયથન કોડ વિકસાવીએ:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ abc }\ImportTok{import}\NormalTok{ ABC, abstractmethod}

\KeywordTok{class}\NormalTok{ Shape(ABC):}
    \AttributeTok{@abstractmethod}
    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{pass}

    \AttributeTok{@abstractmethod}
    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{pass}

\KeywordTok{class}\NormalTok{ Rectangle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, length, width):}
        \VariableTok{self}\NormalTok{.length }\OperatorTok{=}\NormalTok{ length}
        \VariableTok{self}\NormalTok{.width }\OperatorTok{=}\NormalTok{ width}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.length }\OperatorTok{*} \VariableTok{self}\NormalTok{.width}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \DecValTok{2} \OperatorTok{*}\NormalTok{ (}\VariableTok{self}\NormalTok{.length }\OperatorTok{+} \VariableTok{self}\NormalTok{.width)}

\KeywordTok{class}\NormalTok{ Circle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, radius):}
        \VariableTok{self}\NormalTok{.radius }\OperatorTok{=}\NormalTok{ radius}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \FloatTok{3.14} \OperatorTok{*} \VariableTok{self}\NormalTok{.radius }\OperatorTok{**} \DecValTok{2}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \DecValTok{2} \OperatorTok{*} \FloatTok{3.14} \OperatorTok{*} \VariableTok{self}\NormalTok{.radius}

\KeywordTok{class}\NormalTok{ Triangle(Shape):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, a, b, c):}
        \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}
        \VariableTok{self}\NormalTok{.b }\OperatorTok{=}\NormalTok{ b}
        \VariableTok{self}\NormalTok{.c }\OperatorTok{=}\NormalTok{ c}

    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \CommentTok{\# હેરોનનું સૂત્ર વાપરીને}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.a }\OperatorTok{+} \VariableTok{self}\NormalTok{.b }\OperatorTok{+} \VariableTok{self}\NormalTok{.c) }\OperatorTok{/} \DecValTok{2}
        \ControlFlowTok{return}\NormalTok{ (s }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.a) }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.b) }\OperatorTok{*}\NormalTok{ (s }\OperatorTok{{-}} \VariableTok{self}\NormalTok{.c)) }\OperatorTok{**} \FloatTok{0.5}

    \KeywordTok{def}\NormalTok{ perimeter(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.a }\OperatorTok{+} \VariableTok{self}\NormalTok{.b }\OperatorTok{+} \VariableTok{self}\NormalTok{.c}

\KeywordTok{def}\NormalTok{ print\_shape\_info(shape):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"આકાર: }\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(shape)}\SpecialCharTok{.}\VariableTok{\_\_name\_\_}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"ક્ષેત્રફળ: }\SpecialCharTok{\{}\NormalTok{shape}\SpecialCharTok{.}\NormalTok{area()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"પરિમિતિ: }\SpecialCharTok{\{}\NormalTok{shape}\SpecialCharTok{.}\NormalTok{perimeter()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{()}

\CommentTok{\# વિવિધ આકારો બનાવો}
\NormalTok{rectangle }\OperatorTok{=}\NormalTok{ Rectangle(}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{circle }\OperatorTok{=}\NormalTok{ Circle(}\DecValTok{3}\NormalTok{)}
\NormalTok{triangle }\OperatorTok{=}\NormalTok{ Triangle(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\CommentTok{\# પોલીમોર્ફીસમ દર્શાવો}
\NormalTok{shapes }\OperatorTok{=}\NormalTok{ [rectangle, circle, triangle]}

\ControlFlowTok{for}\NormalTok{ shape }\KeywordTok{in}\NormalTok{ shapes:}
\NormalTok{    print\_shape\_info(shape)}
\end{Highlighting}
\end{Shaded}

કોડની સમજૂતી:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  અમે \texttt{area()} અને \texttt{perimeter()} એબ્સ્ટ્રેક્ટ મેથડ્સ સાથે એક એબ્સ્ટ્રેક્ટ
  બેઝ ક્લાસ \texttt{Shape} વ્યાખ્યાયિત કરીએ છીએ.
\item
  અમે ત્રણ કોન્ક્રીટ ક્લાસ બનાવીએ છીએ: \texttt{Rectangle}, \texttt{Circle},
  અને \texttt{Triangle}, દરેક \texttt{Shape} માંથી વારસો મેળવે છે અને તેની
  પોતાની \texttt{area()} અને \texttt{perimeter()} મેથડ્સનો અમલ કરે છે.
\item
  \texttt{print\_shape\_info()} ફંક્શન પોલીમોર્ફીસમ દર્શાવે છે. તે
  \texttt{shape} પેરામીટર લે છે અને આકારનો ચોક્કસ પ્રકાર જાણ્યા વિના
  \texttt{area()} અને \texttt{perimeter()} મેથડ્સને કૉલ કરે છે.
\item
  અમે વિવિધ આકારોના ઇન્સ્ટન્સ બનાવીએ છીએ અને તેમને એક લિસ્ટમાં સ્ટોર કરીએ છીએ.
\item
  અમે આકારોની લિસ્ટમાંથી પસાર થઈએ છીએ, દરેક આકાર માટે
  \texttt{print\_shape\_info()} ને કૉલ કરીએ છીએ. આ પોલીમોર્ફીસમ દર્શાવે છે
  કારણ કે એક જ ફંક્શન વિવિધ આકાર ઓબ્જેક્ટ્સ સાથે કાર્ય કરે છે.
\end{enumerate}

આ કોડ વિવિધ આકાર ઓબ્જેક્ટ્સને સામાન્ય ઇન્ટરફેસ (\texttt{Shape}) દ્વારા એકસમાન રીતે
ગણવાની મંજૂરી આપીને પોલીમોર્ફીસમ દર્શાવે છે, જ્યારે દરેક આકાર ક્ષેત્રફળ અને પરિમિતિની
ગણતરી માટે તેના ચોક્કસ વર્તનનો અમલ કરે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{classDiagram}
\NormalTok{    Shape \textless{}|{-}{-} Rectangle}
\NormalTok{    Shape \textless{}|{-}{-} Circle}
\NormalTok{    Shape \textless{}|{-}{-} Triangle}
\NormalTok{    Shape : +area()}
\NormalTok{    Shape : +perimeter()}
\NormalTok{    Rectangle : {-}length}
\NormalTok{    Rectangle : {-}width}
\NormalTok{    Rectangle : +area()}
\NormalTok{    Rectangle : +perimeter()}
\NormalTok{    Circle : {-}radius}
\NormalTok{    Circle : +area()}
\NormalTok{    Circle : +perimeter()}
\NormalTok{    Triangle : {-}a}
\NormalTok{    Triangle : {-}b}
\NormalTok{    Triangle : {-}c}
\NormalTok{    Triangle : +area()}
\NormalTok{    Triangle : +perimeter()}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2a-differentiate-between-stack-and-queue.-03-marks}{%
\subsubsection{Q2a: Differentiate between Stack and Queue. (03
marks)}\label{q2a-differentiate-between-stack-and-queue.-03-marks}}

\textbf{Ans 2a:} Stack and Queue are both fundamental data structures
used in computer science, but they differ in their behavior and use
cases. Here's a comparison:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Order of Operations}:

  \begin{itemize}
  \tightlist
  \item
    Stack: Last-In-First-Out (LIFO)
  \item
    Queue: First-In-First-Out (FIFO)
  \end{itemize}
\item
  \textbf{Access Points}:

  \begin{itemize}
  \tightlist
  \item
    Stack: Single end (top) for both insertion and deletion
  \item
    Queue: Two ends - rear for insertion (enqueue) and front for
    deletion (dequeue)
  \end{itemize}
\item
  \textbf{Main Operations}:

  \begin{itemize}
  \tightlist
  \item
    Stack: Push (insert) and Pop (remove)
  \item
    Queue: Enqueue (insert) and Dequeue (remove)
  \end{itemize}
\item
  \textbf{Use Cases}:

  \begin{itemize}
  \tightlist
  \item
    Stack: Function call management, undo mechanisms, expression
    evaluation
  \item
    Queue: Task scheduling, breadth-first search, printer spooling
  \end{itemize}
\item
  \textbf{Flexibility}:

  \begin{itemize}
  \tightlist
  \item
    Stack: More flexible for nested structures
  \item
    Queue: Better for sequential processing
  \end{itemize}
\end{enumerate}

Tabular Comparison:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1508}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3730}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4762}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stack
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Order & LIFO (Last-In-First-Out) & FIFO (First-In-First-Out) \\
Insertion & At one end (top) & At one end (rear) \\
Deletion & From the same end as insertion (top) & From the opposite end
of insertion (front) \\
Main Operations & Push, Pop & Enqueue, Dequeue \\
Access & Only top element is accessible & Elements accessible from both
ends \\
Implementation & Can be implemented using arrays or linked lists & Can
be implemented using arrays, linked lists, or circular arrays \\
Terminology & Top & Front and Rear \\
Overflow Condition & When stack is full & When queue is full \\
Underflow Condition & When stack is empty & When queue is empty \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TB}
\NormalTok{    subgraph Stack}
\NormalTok{        A[Top] {-}{-}\textgreater{} B}
\NormalTok{        B {-}{-}\textgreater{} C}
\NormalTok{        C {-}{-}\textgreater{} D[Bottom]}
\NormalTok{    end}
\NormalTok{    subgraph Queue}
\NormalTok{        E[Front] {-}{-}{-} F}
\NormalTok{        F {-}{-}{-} G}
\NormalTok{        G {-}{-}{-} H[Rear]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa85-uxab8uxa9fuxa95-uxa85uxaa8-uxa95uxaaf-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2અ: સ્ટેક અને ક્યુ નો તફાવત આપો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxa85-uxab8uxa9fuxa95-uxa85uxaa8-uxa95uxaaf-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 2અ:} સ્ટેક અને ક્યુ બંને કમ્પ્યુટર સાયન્સમાં ઉપયોગમાં લેવાતા મૂળભૂત ડેટા
સ્ટ્રક્ચર્સ છે, પરંતુ તેઓ તેમના વર્તન અને ઉપયોગના કિસ્સાઓમાં અલગ પડે છે. અહીં એક તુલના
આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{ઓપરેશન્સનો ક્રમ}:

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક: Last-In-First-Out (LIFO)
  \item
    ક્યુ: First-In-First-Out (FIFO)
  \end{itemize}
\item
  \textbf{ઍક્સેસ પોઇન્ટ્સ}:

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક: એક જ છેડો (ટોચ) દાખલ કરવા અને કાઢવા બંને માટે
  \item
    ક્યુ: બે છેડા - દાખલ કરવા માટે પાછળનો (enqueue) અને કાઢવા માટે આગળનો
    (dequeue)
  \end{itemize}
\item
  \textbf{મુખ્ય ઓપરેશન્સ}:

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક: Push (દાખલ કરવું) અને Pop (કાઢવું)
  \item
    ક્યુ: Enqueue (દાખલ કરવું) અને Dequeue (કાઢવું)
  \end{itemize}
\item
  \textbf{ઉપયોગના કિસ્સાઓ}:

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક: ફંક્શન કૉલ મેનેજમેન્ટ, અન્ડુ મેકેનિઝમ્સ, એક્સપ્રેશન ઇવેલ્યુએશન
  \item
    ક્યુ: ટાસ્ક શેડ્યુલિંગ, બ્રેડ્થ-ફર્સ્ટ સર્ચ, પ્રિન્ટર સ્પૂલિંગ
  \end{itemize}
\item
  \textbf{લવચીકતા}:

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક: નેસ્ટેડ સ્ટ્રક્ચર્સ માટે વધુ લવચીક
  \item
    ક્યુ: અનુક્રમિક પ્રોસેસિંગ માટે વધુ સારું
  \end{itemize}
\end{enumerate}

કોષ્ટક સ્વરૂપે તુલના:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1111}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3932}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4957}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટેક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ક્રમ & LIFO (Last-In-First-Out) & FIFO (First-In-First-Out) \\
દાખલ કરવું & એક છેડે (ટોચ પર) & એક છેડે (પાછળ) \\
કાઢવું & દાખલ કરવાના એ જ છેડેથી (ટોચ) & દાખલ કરવાના વિરુદ્ધ છેડેથી (આગળ) \\
મુખ્ય ઓપરેશન્સ & Push, Pop & Enqueue, Dequeue \\
ઍક્સેસ & માત્ર ટોચનું એલિમેન્ટ ઍક્સેસ કરી શકાય છે & બંને છેડેથી એલિમેન્ટ્સ ઍક્સેસ કરી શકાય
છે \\
અમલીકરણ & એરે અથવા લિંક્ડ લિસ્ટ્સનો ઉપયોગ કરીને અમલ કરી શકાય છે & એરે, લિંક્ડ
લિસ્ટ્સ, અથવા સર્ક્યુલર એરેનો ઉપયોગ કરીને અમલ કરી શકાય છે \\
શબ્દાવલી & ટોચ & આગળ અને પાછળ \\
ઓવરફ્લો સ્થિતિ & જ્યારે સ્ટેક ભરાઈ જાય & જ્યારે ક્યુ ભરાઈ જાય \\
અન્ડરફ્લો સ્થિતિ & જ્યારે સ્ટેક ખાલી હોય & જ્યારે ક્યુ ખાલી હોય \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TB}
\NormalTok{    subgraph Stack}
\NormalTok{        A[Top] {-}{-}\textgreater{} B}
\NormalTok{        B {-}{-}\textgreater{} C}
\NormalTok{        C {-}{-}\textgreater{} D[Bottom]}
\NormalTok{    end}
\NormalTok{    subgraph Queue}
\NormalTok{        E[Front] {-}{-}{-} F}
\NormalTok{        F {-}{-}{-} G}
\NormalTok{        G {-}{-}{-} H[Rear]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2b-write-an-algorithm-for-push-and-pop-operation-of-stack-in-python.-04-marks}{%
\subsubsection{Q2b: Write an algorithm for PUSH and POP operation of
stack in python. (04
marks)}\label{q2b-write-an-algorithm-for-push-and-pop-operation-of-stack-in-python.-04-marks}}

\textbf{Ans 2b:}

Here are the algorithms for PUSH and POP operations of a stack
implemented in Python:

\textbf{PUSH Algorithm:} 1. Check if the stack is full 2. If full,
display ``Stack Overflow'' error 3. If not full, increment the top
pointer 4. Add the new element at the position of the top pointer

Python implementation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ push(stack, item, max\_size):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{\textgreater{}=}\NormalTok{ max\_size:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Stack Overflow. Cannot push item:"}\NormalTok{, item)}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        stack.append(item)}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Pushed item:"}\NormalTok{, item)}
\end{Highlighting}
\end{Shaded}

\textbf{POP Algorithm:} 1. Check if the stack is empty 2. If empty,
display ``Stack Underflow'' error 3. If not empty, retrieve the item at
the top pointer 4. Decrement the top pointer 5. Return the retrieved
item

Python implementation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pop(stack):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Stack Underflow. Cannot pop item from an empty stack."}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        item }\OperatorTok{=}\NormalTok{ stack.pop()}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Popped item:"}\NormalTok{, item)}
        \ControlFlowTok{return}\NormalTok{ item}
\end{Highlighting}
\end{Shaded}

\textbf{Usage example:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Initialize an empty stack}
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}
\NormalTok{max\_size }\OperatorTok{=} \DecValTok{5}

\CommentTok{\# Push operations}
\NormalTok{push(stack, }\DecValTok{10}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{20}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{30}\NormalTok{, max\_size)}

\CommentTok{\# Pop operations}
\NormalTok{pop(stack)}
\NormalTok{pop(stack)}

\CommentTok{\# Try to pop from an empty stack}
\NormalTok{pop(stack)}
\NormalTok{pop(stack)  }\CommentTok{\# This will show the underflow error}

\CommentTok{\# Try to push beyond the max size}
\NormalTok{push(stack, }\DecValTok{40}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{50}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{60}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{70}\NormalTok{, max\_size)  }\CommentTok{\# This will show the overflow error}
\end{Highlighting}
\end{Shaded}

This implementation uses Python's built-in list as the underlying data
structure for the stack. The \texttt{append()} method is used for
pushing elements, and the \texttt{pop()} method is used for removing
elements from the top of the stack.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B\{Is operation PUSH?\}}
\NormalTok{    B {-}{-}\textgreater{}|Yes| C\{Is stack full?\}}
\NormalTok{    C {-}{-}\textgreater{}|Yes| D[Display: Stack Overflow]}
\NormalTok{    C {-}{-}\textgreater{}|No| E[Increment top pointer]}
\NormalTok{    E {-}{-}\textgreater{} F[Add new element at top]}
\NormalTok{    B {-}{-}\textgreater{}|No| G\{Is stack empty?\}}
\NormalTok{    G {-}{-}\textgreater{}|Yes| H[Display: Stack Underflow]}
\NormalTok{    G {-}{-}\textgreater{}|No| I[Retrieve top item]}
\NormalTok{    I {-}{-}\textgreater{} J[Decrement top pointer]}
\NormalTok{    J {-}{-}\textgreater{} K[Return popped item]}
\NormalTok{    D {-}{-}\textgreater{} L[End]}
\NormalTok{    F {-}{-}\textgreater{} L}
\NormalTok{    H {-}{-}\textgreater{} L}
\NormalTok{    K {-}{-}\textgreater{} L}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxaac-uxaaauxab6-uxa85uxaa8-uxaaauxaaa-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2બ: પુશ અને પોપ ઓપરેશન માટેનો અલ્ગોરીધમ લખો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxaac-uxaaauxab6-uxa85uxaa8-uxaaauxaaa-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 2બ:}

અહીં પાયથનમાં અમલ કરાયેલ સ્ટેકના PUSH અને POP ઓપરેશન માટેના અલ્ગોરિધમ આપ્યા છે:

\textbf{PUSH અલ્ગોરિધમ:} 1. તપાસો કે શું સ્ટેક ભરેલો છે 2. જો ભરેલો હોય, તો ``સ્ટેક
ઓવરફ્લો'' ભૂલ દર્શાવો 3. જો ભરેલો ન હોય, તો ટોચના પોઈન્ટરને વધારો 4. ટોચના
પોઈન્ટરની સ્થિતિએ નવું એલિમેન્ટ ઉમેરો

પાયથન અમલીકરણ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ push(stack, item, max\_size):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{\textgreater{}=}\NormalTok{ max\_size:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"સ્ટેક ઓવરફ્લો. આઇટમ પુશ કરી શકાતી નથી:"}\NormalTok{, item)}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        stack.append(item)}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"પુશ કરેલી આઇટમ:"}\NormalTok{, item)}
\end{Highlighting}
\end{Shaded}

\textbf{POP અલ્ગોરિધમ:} 1. તપાસો કે શું સ્ટેક ખાલી છે 2. જો ખાલી હોય, તો ``સ્ટેક
અન્ડરફ્લો'' ભૂલ દર્શાવો 3. જો ખાલી ન હોય, તો ટોચના પોઈન્ટર પરની આઇટમ મેળવો 4.
ટોચના પોઈન્ટરને ઘટાડો 5. મેળવેલી આઇટમ પરત કરો

પાયથન અમલીકરણ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pop(stack):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(stack) }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"સ્ટેક અન્ડરફ્લો. ખાલી સ્ટેકમાંથી આઇટમ પોપ કરી શકાતી નથી."}\NormalTok{)}
        \ControlFlowTok{return} \VariableTok{None}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        item }\OperatorTok{=}\NormalTok{ stack.pop()}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"પોપ કરેલી આઇટમ:"}\NormalTok{, item)}
        \ControlFlowTok{return}\NormalTok{ item}
\end{Highlighting}
\end{Shaded}

\textbf{ઉપયોગનું ઉદાહરણ:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ખાલી સ્ટેક શરૂ કરો}
\NormalTok{stack }\OperatorTok{=}\NormalTok{ []}
\NormalTok{max\_size }\OperatorTok{=} \DecValTok{5}

\CommentTok{\# પુશ ઓપરેશન્સ}
\NormalTok{push(stack, }\DecValTok{10}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{20}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{30}\NormalTok{, max\_size)}

\CommentTok{\# પોપ ઓપરેશન્સ}
\NormalTok{pop(stack)}
\NormalTok{pop(stack)}

\CommentTok{\# ખાલી સ્ટેકમાંથી પોપ કરવાનો પ્રયાસ}
\NormalTok{pop(stack)}
\NormalTok{pop(stack)  }\CommentTok{\# આ અન્ડરફ્લો ભૂલ બતાવશે}

\CommentTok{\# મહત્તમ કદથી વધારે પુશ કરવાનો પ્રયાસ}
\NormalTok{push(stack, }\DecValTok{40}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{50}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{60}\NormalTok{, max\_size)}
\NormalTok{push(stack, }\DecValTok{70}\NormalTok{, max\_size)  }\CommentTok{\# આ ઓવરફ્લો ભૂલ બતાવશે}
\end{Highlighting}
\end{Shaded}

આ અમલીકરણ સ્ટેક માટે પાયથનની બિલ્ટ-ઇન લિસ્ટનો ઉપયોગ કરે છે. \texttt{append()}
મેથડનો ઉપયોગ એલિમેન્ટ્સ પુશ કરવા માટે થાય છે, અને \texttt{pop()} મેથડનો ઉપયોગ
સ્ટેકની ટોચથી એલિમેન્ટ્સ દૂર કરવા માટે થાય છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂ] {-}{-}\textgreater{} B\{શું ઓપરેશન PUSH છે?\}}
\NormalTok{    B {-}{-}\textgreater{}|હા| C\{શું સ્ટેક ભરેલો છે?\}}
\NormalTok{    C {-}{-}\textgreater{}|હા| D["સ્ટેક ઓવરફ્લો" દર્શાવો]}
\NormalTok{    C {-}{-}\textgreater{}|ના| E[ટોચના પોઈન્ટરને વધારો]}
\NormalTok{    E {-}{-}\textgreater{} F[ટોચ પર નવું એલિમેન્ટ ઉમેરો]}
\NormalTok{    B {-}{-}\textgreater{}|ના| G\{શું સ્ટેક ખાલી છે?\}}
\NormalTok{    G {-}{-}\textgreater{}|હા| H["સ્ટેક અન્ડરફ્લો" દર્શાવો]}
\NormalTok{    G {-}{-}\textgreater{}|ના| I[ટોચની આઇટમ મેળવો]}
\NormalTok{    I {-}{-}\textgreater{} J[ટોચના પોઈન્ટરને ઘટાડો]}
\NormalTok{    J {-}{-}\textgreater{} K[પોપ કરેલી આઇટમ પરત કરો]}
\NormalTok{    D {-}{-}\textgreater{} L[અંત]}
\NormalTok{    F {-}{-}\textgreater{} L}
\NormalTok{    H {-}{-}\textgreater{} L}
\NormalTok{    K {-}{-}\textgreater{} L}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2c-convert-following-equation-from-infix-to-postfix-using-stack-a-b-c---d-e-f-07-marks}{%
\subsubsection{Q2c: Convert following equation from infix to postfix
using Stack: A * (B + C) - D / (E + F) (07
marks)}\label{q2c-convert-following-equation-from-infix-to-postfix-using-stack-a-b-c---d-e-f-07-marks}}

\textbf{Ans 2c:}

To convert the infix expression A * (B + C) - D / (E + F) to postfix,
we'll use the stack-based algorithm. Here's the step-by-step process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initialize an empty stack and an empty output string.
\item
  Scan the infix expression from left to right.
\item
  For each character in the infix expression:

  \begin{itemize}
  \tightlist
  \item
    If it's an operand (letter or digit), add it to the output string.
  \item
    If it's a left parenthesis `(', push it onto the stack.
  \item
    If it's a right parenthesis `)', pop operators from the stack and
    add them to the output string until a left parenthesis is
    encountered. Pop and discard the left parenthesis.
  \item
    If it's an operator (+, -, *, /):

    \begin{itemize}
    \tightlist
    \item
      While the stack is not empty and the top of the stack has higher
      or equal precedence, pop operators from the stack and add them to
      the output string.
    \item
      Push the current operator onto the stack.
    \end{itemize}
  \end{itemize}
\item
  After scanning all characters, pop any remaining operators from the
  stack and add them to the output string.
\end{enumerate}

Let's apply this algorithm to our expression: A * (B + C) - D / (E + F)

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0678}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1017}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2034}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1864}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.4407}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Step
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Symbol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stack
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Output
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Explanation
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & A & {[}{]} & A & Operand, add to output \\
2 & * & {[}*{]} & A & Push * to stack \\
3 & ( & {[}*, ({]} & A & Push ( to stack \\
4 & B & {[}*, ({]} & AB & Operand, add to output \\
5 & + & {[}*, (, +{]} & AB & Push + to stack \\
6 & C & {[}*, (, +{]} & ABC & Operand, add to output \\
7 & ) & {[}*{]} & ABC+ & Pop until (, add to output \\
8 & - & {[}-{]} & ABC+* & Pop *, push - \\
9 & D & {[}-{]} & ABC+*D & Operand, add to output \\
10 & / & {[}-, /{]} & ABC+*D & Push / (higher precedence) \\
11 & ( & {[}-, /, ({]} & ABC+*D & Push ( to stack \\
12 & E & {[}-, /, ({]} & ABC+*DE & Operand, add to output \\
13 & + & {[}-, /, (, +{]} & ABC+*DE & Push + to stack \\
14 & F & {[}-, /, (, +{]} & ABC+*DEF & Operand, add to output \\
15 & ) & {[}-, /{]} & ABC+*DEF+ & Pop until (, add to output \\
16 & End & {[}{]} & ABC+*DEF+/- & Pop remaining operators \\
\end{longtable}

Therefore, the postfix expression is: ABC+*DEF+/-

Verification: - The original infix expression: A * (B + C) - D / (E + F)
- The resulting postfix expression: ABC+*DEF+/-

This postfix expression correctly represents the original infix
expression, preserving the order of operations and parentheses.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Initialize empty stack and output]}
\NormalTok{    B {-}{-}\textgreater{} C[Scan infix expression left to right]}
\NormalTok{    C {-}{-}\textgreater{} D\{"Is character operand?"\}}
\NormalTok{    D {-}{-}\textgreater{}|Yes| E[Add to output]}
\NormalTok{    D {-}{-}\textgreater{}|No| F\{"Is character \textquotesingle{}(\textquotesingle{}?"\}}
\NormalTok{    F {-}{-}\textgreater{}|Yes| G[Push to stack]}
\NormalTok{    F {-}{-}\textgreater{}|No| H\{"Is character \textquotesingle{})\textquotesingle{}?"\}}
\NormalTok{    H {-}{-}\textgreater{}|Yes| I["Pop and output until \textquotesingle{}(\textquotesingle{}"]}
\NormalTok{    H {-}{-}\textgreater{}|No| J\{"Is character operator?"\}}
\NormalTok{    J {-}{-}\textgreater{}|Yes| K[Pop higher precedence operators]}
\NormalTok{    K {-}{-}\textgreater{} L[Push current operator]}
\NormalTok{    J {-}{-}\textgreater{}|No| M[End of expression?]}
\NormalTok{    M {-}{-}\textgreater{}|No| C}
\NormalTok{    M {-}{-}\textgreater{}|Yes| N[Pop remaining operators]}
\NormalTok{    N {-}{-}\textgreater{} O[End]}
\NormalTok{    E {-}{-}\textgreater{} C}
\NormalTok{    G {-}{-}\textgreater{} C}
\NormalTok{    I {-}{-}\textgreater{} C}
\NormalTok{    L {-}{-}\textgreater{} C}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxab8uxaaeuxa95uxab0uxaa3uxaa8-uxa87uxaa8uxaabuxa95uxab8uxaaeuxaa5-uxaaauxab8uxa9fuxaabuxa95uxab8uxaae-uxaacuxaa6uxab2-a-b-c---d-e-f-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2ક: નીચે આપેલ સમીકરણને ઇન્ફિક્સમાંથી પોસ્ટફિક્સમાં બદલો: A *
(B + C) - D / (E + F) (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxab8uxaaeuxa95uxab0uxaa3uxaa8-uxa87uxaa8uxaabuxa95uxab8uxaaeuxaa5-uxaaauxab8uxa9fuxaabuxa95uxab8uxaae-uxaacuxaa6uxab2-a-b-c---d-e-f-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 2ક:}

ઇન્ફિક્સ અભિવ્યક્તિ A * (B + C) - D / (E + F) ને પોસ્ટફિક્સમાં રૂપાંતરિત કરવા માટે,
આપણે સ્ટેક-આધારિત અલ્ગોરિધમનો ઉપયોગ કરીશું. અહીં પગલાવાર પ્રક્રિયા આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ખાલી સ્ટેક અને ખાલી આઉટપુટ સ્ટ્રિંગ શરૂ કરો.
\item
  ઇન્ફિક્સ અભિવ્યક્તિને ડાબેથી જમણે સ્કેન કરો.
\item
  ઇન્ફિક્સ અભિવ્યક્તિના દરેક અક્ષર માટે:

  \begin{itemize}
  \tightlist
  \item
    જો તે ઓપરેન્ડ (અક્ષર અથવા અંક) હોય, તો તેને આઉટપુટ સ્ટ્રિંગમાં ઉમેરો.
  \item
    જો તે ડાબો કૌંસ `(' હોય, તો તેને સ્ટેક પર પુશ કરો.
  \item
    જો તે જમણો કૌંસ `)' હોય, તો ડાબો કૌંસ મળે ત્યાં સુધી સ્ટેકમાંથી ઓપરેટરોને પોપ
    કરો અને તેમને આઉટપુટ સ્ટ્રિંગમાં ઉમેરો. ડાબા કૌંસને પોપ કરો અને કાઢી નાખો.
  \item
    જો તે ઓપરેટર (+, -, *, /) હોય:

    \begin{itemize}
    \tightlist
    \item
      જ્યાં સુધી સ્ટેક ખાલી ન હોય અને સ્ટેકની ટોચ પર ઉચ્ચ અથવા સમાન અગ્રતા હોય,
      ત્યાં સુધી સ્ટેકમાંથી ઓપરેટરોને પોપ કરો અને તેમને આઉટપુટ સ્ટ્રિંગમાં ઉમેરો.
    \item
      વર્તમાન ઓપરેટરને સ્ટેક પર પુશ કરો.
    \end{itemize}
  \end{itemize}
\item
  બધા અક્ષરોને સ્કેન કર્યા પછી, સ્ટેકમાંથી કોઈપણ બાકી રહેલા ઓપરેટરોને પોપ કરો અને
  તેમને આઉટપુટ સ્ટ્રિંગમાં ઉમેરો.
\end{enumerate}

ચાલો આ અલ્ગોરિધમને આપણા સમીકરણ પર લાગુ કરીએ: A * (B + C) - D / (E + F)

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0678}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0847}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2034}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1864}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.4576}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પગલું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રતીક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટેક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સમજૂતી
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & A & {[}{]} & A & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
2 & * & {[}*{]} & A & * ને સ્ટેક પર પુશ કરો \\
3 & ( & {[}*, ({]} & A & ( ને સ્ટેક પર પુશ કરો \\
4 & B & {[}*, ({]} & AB & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
5 & + & {[}*, (, +{]} & AB & + ને સ્ટેક પર પુશ કરો \\
6 & C & {[}*, (, +{]} & ABC & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
7 & ) & {[}*{]} & ABC+ & ( સુધી પોપ કરો, આઉટપુટમાં ઉમેરો \\
8 & - & {[}-{]} & ABC+* & * ને પોપ કરો, - ને પુશ કરો \\
9 & D & {[}-{]} & ABC+*D & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
10 & / & {[}-, /{]} & ABC+*D & / ને પુશ કરો (ઉચ્ચ અગ્રતા) \\
11 & ( & {[}-, /, ({]} & ABC+*D & ( ને સ્ટેક પર પુશ કરો \\
12 & E & {[}-, /, ({]} & ABC+*DE & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
13 & + & {[}-, /, (, +{]} & ABC+*DE & + ને સ્ટેક પર પુશ કરો \\
14 & F & {[}-, /, (, +{]} & ABC+*DEF & ઓપરેન્ડ, આઉટપુટમાં ઉમેરો \\
15 & ) & {[}-, /{]} & ABC+*DEF+ & ( સુધી પોપ કરો, આઉટપુટમાં ઉમેરો \\
16 & અંત & {[}{]} & ABC+*DEF+/- & બાકીના ઓપરેટરોને પોપ કરો \\
\end{longtable}

તેથી, પોસ્ટફિક્સ અભિવ્યક્તિ છે: ABC+*DEF+/-

ચકાસણી: - મૂળ ઇન્ફિક્સ અભિવ્યક્તિ: A * (B + C) - D / (E + F) - પરિણામી
પોસ્ટફિક્સ અભિવ્યક્તિ: ABC+*DEF+/-

આ પોસ્ટફિક્સ અભિવ્યક્તિ મૂળ ઇન્ફિક્સ અભિવ્યક્તિનું યોગ્ય રીતે પ્રતિનિધિત્વ કરે છે,
ઓપરેશનનો ક્રમ અને કૌંસને જાળવી રાખે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂ] {-}{-}\textgreater{} B[ખાલી સ્ટેક અને આઉટપુટ શરૂ કરો]}
\NormalTok{    B {-}{-}\textgreater{} C[ઇન્ફિક્સ અભિવ્યક્તિને ડાબેથી જમણે સ્કેન કરો]}
\NormalTok{    C {-}{-}\textgreater{} D\{શું અક્ષર ઓપરેન્ડ છે?\}}
\NormalTok{    D {-}{-}\textgreater{}|હા| E[આઉટપુટમાં ઉમેરો]}
\NormalTok{    D {-}{-}\textgreater{}|ના| F\{"શું અક્ષર \textquotesingle{}(\textquotesingle{} છે?"\}}
\NormalTok{    F {-}{-}\textgreater{}|હા| G[સ્ટેક પર પુશ કરો]}
\NormalTok{    F {-}{-}\textgreater{}|ના| H\{"શું અક્ષર \textquotesingle{})\textquotesingle{} છે?"\}}
\NormalTok{    H {-}{-}\textgreater{}|હા| I["\textquotesingle{}(\textquotesingle{} સુધી પોપ કરો અને આઉટપુટમાં ઉમેરો"]}
\NormalTok{    H {-}{-}\textgreater{}|ના| J\{શું અક્ષર ઓપરેટર છે?\}}
\NormalTok{    J {-}{-}\textgreater{}|હા| K[ઉચ્ચ અગ્રતાના ઓપરેટરોને પોપ કરો]}
\NormalTok{    K {-}{-}\textgreater{} L[વર્તમાન ઓપરેટરને પુશ કરો]}
\NormalTok{    J {-}{-}\textgreater{}|ના| M[અભિવ્યક્તિનો અંત?]}
\NormalTok{    M {-}{-}\textgreater{}|ના| C}
\NormalTok{    M {-}{-}\textgreater{}|હા| N[બાકીના ઓપરેટરોને પોપ કરો]}
\NormalTok{    N {-}{-}\textgreater{} O[અંત]}
\NormalTok{    E {-}{-}\textgreater{} C}
\NormalTok{    G {-}{-}\textgreater{} C}
\NormalTok{    I {-}{-}\textgreater{} C}
\NormalTok{    L {-}{-}\textgreater{} C}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2aor-differentiate-between-simple-queue-and-circular-queue.-03-marks}{%
\subsubsection{Q2aOR: Differentiate between simple Queue and circular
Queue. (03
marks)}\label{q2aor-differentiate-between-simple-queue-and-circular-queue.-03-marks}}

\textbf{Ans 2aOR:}

Simple Queue and Circular Queue are both linear data structures based on
the First-In-First-Out (FIFO) principle, but they differ in their
implementation and efficiency. Here's a comparison:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Definition}:

  \begin{itemize}
  \tightlist
  \item
    Simple Queue: A linear data structure where insertion is done at the
    rear and deletion is done from the front.
  \item
    Circular Queue: A variation of a simple queue where the last element
    is connected to the first element, forming a circle.
  \end{itemize}
\item
  \textbf{Memory Utilization}:

  \begin{itemize}
  \tightlist
  \item
    Simple Queue: May lead to unused memory when elements are dequeued.
  \item
    Circular Queue: Efficiently utilizes memory by reusing empty spaces.
  \end{itemize}
\item
  \textbf{Overflow Condition}:

  \begin{itemize}
  \tightlist
  \item
    Simple Queue: Occurs when rear reaches the end of the array, even if
    there's space at the front.
  \item
    Circular Queue: Occurs only when all spaces are filled, regardless
    of position.
  \end{itemize}
\item
  \textbf{Implementation Complexity}:

  \begin{itemize}
  \tightlist
  \item
    Simple Queue: Simpler to implement.
  \item
    Circular Queue: Slightly more complex due to circular nature.
  \end{itemize}
\item
  \textbf{Operations}:

  \begin{itemize}
  \tightlist
  \item
    Simple Queue: Enqueue and Dequeue operations may require shifting
    elements.
  \item
    Circular Queue: Uses modulo arithmetic for Enqueue and Dequeue,
    avoiding shifts.
  \end{itemize}
\end{enumerate}

Tabular Comparison:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1875}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4792}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Simple Queue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Circular Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Structure & Linear & Circular \\
Memory Utilization & Less efficient & More efficient \\
Overflow Condition & When rear reaches array end & When all spaces are
filled \\
Implementation & Simpler & More complex \\
Space Reusability & Limited & High \\
Position Tracking & Front and Rear pointers & Front and Rear pointers
with modulo arithmetic \\
Best Use Case & When queue size is unpredictable & Fixed size buffer,
continuous operations \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "Simple Queue"}
\NormalTok{        A[Front] {-}{-}{-} B {-}{-}{-} C {-}{-}{-} D[Rear] {-}{-}{-} E[Unused]}
\NormalTok{    end}
\NormalTok{    subgraph "Circular Queue"}
\NormalTok{        F[Front/Rear] {-}{-}{-} G {-}{-}{-} H {-}{-}{-} I {-}{-}{-} J}
\NormalTok{        J {-}{-}{-} F}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa85or-uxab8uxaaeuxaaauxab2-uxa95uxaaf-uxa85uxaa8-uxab8uxab0uxa95uxaafuxab2uxab0-uxa95uxaaf-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2અOR: સિમ્પલ ક્યુ અને સર્ક્યુલર ક્યુ નો તફાવત આપો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxa85or-uxab8uxaaeuxaaauxab2-uxa95uxaaf-uxa85uxaa8-uxab8uxab0uxa95uxaafuxab2uxab0-uxa95uxaaf-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 2અOR:}

સિમ્પલ ક્યુ અને સર્ક્યુલર ક્યુ બંને First-In-First-Out (FIFO) સિદ્ધાંત પર આધારિત
લીનિયર ડેટા સ્ટ્રક્ચર્સ છે, પરંતુ તેમના અમલીકરણ અને કાર્યક્ષમતામાં તફાવત છે. અહીં એક
તુલના આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{વ્યાખ્યા}:

  \begin{itemize}
  \tightlist
  \item
    સિમ્પલ ક્યુ: એક લીનિયર ડેટા સ્ટ્રક્ચર જ્યાં દાખલ કરવાનું કામ પાછળના છેડે અને
    કાઢવાનું કામ આગળના છેડેથી થાય છે.
  \item
    સર્ક્યુલર ક્યુ: સિમ્પલ ક્યુનો એક પ્રકાર જ્યાં છેલ્લો એલિમેન્ટ પ્રથમ એલિમેન્ટ સાથે
    જોડાયેલો હોય છે, વર્તુળ બનાવે છે.
  \end{itemize}
\item
  \textbf{મેમરી ઉપયોગ}:

  \begin{itemize}
  \tightlist
  \item
    સિમ્પલ ક્યુ: જ્યારે એલિમેન્ટ્સ કાઢવામાં આવે છે ત્યારે વણવપરાયેલી મેમરી રહી શકે છે.
  \item
    સર્ક્યુલર ક્યુ: ખાલી જગ્યાઓનો ફરીથી ઉપયોગ કરીને મેમરીનો કાર્યક્ષમ ઉપયોગ કરે છે.
  \end{itemize}
\item
  \textbf{ઓવરફ્લો સ્થિતિ}:

  \begin{itemize}
  \tightlist
  \item
    સિમ્પલ ક્યુ: જ્યારે પાછળનો છેડો એરેના અંત સુધી પહોંચે છે ત્યારે થાય છે, પછી ભલે આગળ
    જગ્યા હોય.
  \item
    સર્ક્યુલર ક્યુ: માત્ર ત્યારે જ થાય છે જ્યારે બધી જગ્યાઓ ભરાયેલી હોય, સ્થાનની પરવા
    કર્યા વગર.
  \end{itemize}
\item
  \textbf{અમલીકરણ જટિલતા}:

  \begin{itemize}
  \tightlist
  \item
    સિમ્પલ ક્યુ: અમલ કરવામાં સરળ.
  \item
    સર્ક્યુલર ક્યુ: વર્તુળાકાર પ્રકૃતિને કારણે થોડું વધુ જટિલ.
  \end{itemize}
\item
  \textbf{ઓપરેશન્સ}:

  \begin{itemize}
  \tightlist
  \item
    સિમ્પલ ક્યુ: Enqueue અને Dequeue ઓપરેશન્સમાં એલિમેન્ટ્સને ખસેડવાની જરૂર પડી શકે છે.
  \item
    સર્ક્યુલર ક્યુ: Enqueue અને Dequeue માટે મોડ્યુલો ગણિતનો ઉપયોગ કરે છે, ખસેડવાનું
    ટાળે છે.
  \end{itemize}
\end{enumerate}

કોષ્ટક સ્વરૂપે તુલના:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1585}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3902}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4512}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિમ્પલ ક્યુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સર્ક્યુલર ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
રચના & લીનિયર & વર્તુળાકાર \\
મેમરી ઉપયોગ & ઓછો કાર્યક્ષમ & વધુ કાર્યક્ષમ \\
ઓવરફ્લો સ્થિતિ & જ્યારે પાછળનો છેડો એરેના અંત સુધી પહોંચે & જ્યારે બધી જગ્યાઓ ભરાયેલી
હોય \\
અમલીકરણ & સરળ & વધુ જટિલ \\
જગ્યા પુન:ઉપયોગ & મર્યાદિત & ઉચ્ચ \\
સ્થિતિ ટ્રેકિંગ & આગળ અને પાછળના પોઇન્ટર્સ & આગળ અને પાછળના પોઇન્ટર્સ મોડ્યુલો ગણિત
સાથે \\
શ્રેષ્ઠ ઉપયોગ કેસ & જ્યારે ક્યુનું કદ અનિશ્ચિત હોય & નિશ્ચિત કદનો બફર, સતત ઓપરેશન્સ \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "સિમ્પલ ક્યુ"}
\NormalTok{        A[આગળ] {-}{-}{-} B {-}{-}{-} C {-}{-}{-} D[પાછળ] {-}{-}{-} E[વણવપરાયેલ]}
\NormalTok{    end}
\NormalTok{    subgraph "સર્ક્યુલર ક્યુ"}
\NormalTok{        F[આગળ/પાછળ] {-}{-}{-} G {-}{-}{-} H {-}{-}{-} I {-}{-}{-} J}
\NormalTok{        J {-}{-}{-} F}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2bor-explain-concept-of-recursive-function-with-suitable-example.-04-marks}{%
\subsubsection{Q2bOR: Explain concept of recursive function with
suitable example. (04
marks)}\label{q2bor-explain-concept-of-recursive-function-with-suitable-example.-04-marks}}

\textbf{Ans 2bOR:}

A recursive function is a function that calls itself during its
execution. This technique allows the function to repeat its behavior to
solve a problem by breaking it down into smaller, more manageable
subproblems. Recursive functions typically have two main components:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Base case}: A condition that stops the recursion.
\item
  \textbf{Recursive case}: The part where the function calls itself with
  a modified input.
\end{enumerate}

Key aspects of recursive functions: - They can often provide elegant
solutions to complex problems. - Each recursive call creates a new
instance of the function on the call stack. - Improper implementation
can lead to stack overflow errors.

Let's illustrate this concept with a classic example: calculating the
factorial of a number.

Example: Factorial Calculation

The factorial of a non-negative integer n, denoted as n!, is the product
of all positive integers less than or equal to n.~For example, 5! = 5 *
4 * 3 * 2 * 1 = 120.

Here's a Python implementation of a recursive factorial function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ factorial(n):}
    \CommentTok{\# Base case}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{0} \KeywordTok{or}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{1}
    
    \CommentTok{\# Recursive case}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Example usage}
\BuiltInTok{print}\NormalTok{(factorial(}\DecValTok{5}\NormalTok{))  }\CommentTok{\# Output: 120}
\end{Highlighting}
\end{Shaded}

Explanation of the recursive process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  When \texttt{factorial(5)} is called:

  \begin{itemize}
  \tightlist
  \item
    5 is not 0 or 1, so it goes to the recursive case.
  \item
    It returns 5 * factorial(4)
  \end{itemize}
\item
  Now \texttt{factorial(4)} is called:

  \begin{itemize}
  \tightlist
  \item
    4 is not 0 or 1, so it returns 4 * factorial(3)
  \end{itemize}
\item
  This continues until we reach \texttt{factorial(1)}:

  \begin{itemize}
  \tightlist
  \item
    1 is a base case, so it returns 1
  \end{itemize}
\item
  The recursion then unwinds:

  \begin{itemize}
  \tightlist
  \item
    factorial(2) = 2 * 1 = 2
  \item
    factorial(3) = 3 * 2 = 6
  \item
    factorial(4) = 4 * 6 = 24
  \item
    factorial(5) = 5 * 24 = 120
  \end{itemize}
\item
  The final result, 120, is returned.
\end{enumerate}

This recursive approach breaks down the problem of calculating 5! into
smaller subproblems, eventually reaching the base case and then building
the solution back up.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["factorial(5)"] {-}{-}\textgreater{} B["5 * factorial(4)"]}
\NormalTok{    B {-}{-}\textgreater{} C["5 * 4 * factorial(3)"]}
\NormalTok{    C {-}{-}\textgreater{} D["5 * 4 * 3 * factorial(2)"]}
\NormalTok{    D {-}{-}\textgreater{} E["5 * 4 * 3 * 2 * factorial(1)"]}
\NormalTok{    E {-}{-}\textgreater{} F[5 * 4 * 3 * 2 * 1]}
\NormalTok{    F {-}{-}\textgreater{} G[120]}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxaacor-uxab0uxa95uxab0uxab8uxab5-uxaabuxa95uxab6uxaa8uxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxaafuxa97uxaaf-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2બOR: રીકર્સિવ ફંક્શનનો કોન્સેપ્ટ યોગ્ય ઉદાહરણ સાથે સમજાવો.
(૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxaacor-uxab0uxa95uxab0uxab8uxab5-uxaabuxa95uxab6uxaa8uxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxaafuxa97uxaaf-uxa89uxaa6uxab9uxab0uxaa3-uxab8uxaa5-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 2બOR:}

રીકર્સિવ ફંક્શન એ એવું ફંક્શન છે જે તેના અમલીકરણ દરમિયાન પોતાને જ કૉલ કરે છે. આ તકનીક
ફંક્શનને સમસ્યાને નાના, વધુ સંચાલનક્ષમ ઉપ-સમસ્યાઓમાં વિભાજિત કરીને તેના વર્તનને
પુનરાવર્તિત કરવાની મંજૂરી આપે છે. રીકર્સિવ ફંક્શન્સમાં સામાન્ય રીતે બે મુખ્ય ઘટકો હોય છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{બેઝ કેસ}: એક શરત જે રીકર્શનને રોકે છે.
\item
  \textbf{રીકર્સિવ કેસ}: જે ભાગમાં ફંક્શન પોતાને સુધારેલા ઇનપુટ સાથે કૉલ કરે છે.
\end{enumerate}

રીકર્સિવ ફંક્શન્સના મુખ્ય પાસાઓ: - તેઓ ઘણીવાર જટિલ સમસ્યાઓ માટે સુંદર ઉકેલો પ્રદાન
કરી શકે છે. - દરેક રીકર્સિવ કૉલ કૉલ સ્ટેક પર ફંક્શનનું નવું ઇન્સ્ટન્સ બનાવે છે. - અયોગ્ય
અમલીકરણ સ્ટેક ઓવરફ્લો ભૂલો તરફ દોરી શકે છે.

ચાલો આ કોન્સેપ્ટને એક ક્લાસિક ઉદાહરણ સાથે સમજાવીએ: સંખ્યાનું ફેક્ટોરિયલ ગણવું.

ઉદાહરણ: ફેક્ટોરિયલ ગણતરી

નોન-નેગેટિવ ઇન્ટીજર n નું ફેક્ટોરિયલ, n! તરીકે દર્શાવવામાં આવે છે, તે n કરતાં ઓછા અથવા
તેના જેટલા બધા પોઝિટિવ ઇન્ટીજર્સનો ગુણાકાર છે. દાખલા તરીકે, 5! = 5 * 4 * 3 * 2
* 1 = 120.

અહીં રીકર્સિવ ફેક્ટોરિયલ ફંક્શનનું પાયથન અમલીકરણ આપ્યું છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ factorial(n):}
    \CommentTok{\# બેઝ કેસ}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{0} \KeywordTok{or}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{1}
    
    \CommentTok{\# રીકર્સિવ કેસ}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# ઉપયોગનું ઉદાહરણ}
\BuiltInTok{print}\NormalTok{(factorial(}\DecValTok{5}\NormalTok{))  }\CommentTok{\# આઉટપુટ: 120}
\end{Highlighting}
\end{Shaded}

રીકર્સિવ પ્રક્રિયાની સમજૂતી:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  જ્યારે \texttt{factorial(5)} કૉલ થાય છે:

  \begin{itemize}
  \tightlist
  \item
    5 એ 0 અથવા 1 નથી, તેથી તે રીકર્સિવ કેસમાં જાય છે.
  \item
    તે 5 * factorial(4) પરત કરે છે
  \end{itemize}
\item
  હવે \texttt{factorial(4)} કૉલ થાય છે:

  \begin{itemize}
  \tightlist
  \item
    4 એ 0 અથવા 1 નથી, તેથી તે 4 * factorial(3) પરત કરે છે
  \end{itemize}
\item
  આ ત્યાં સુધી ચાલુ રહે છે જ્યાં સુધી આપણે \texttt{factorial(1)} સુધી પહોંચતા નથી:

  \begin{itemize}
  \tightlist
  \item
    1 એક બેઝ કેસ છે, તેથી તે 1 પરત કરે છે
  \end{itemize}
\item
  પછી રીકર્શન પાછું વળે છે:

  \begin{itemize}
  \tightlist
  \item
    factorial(2) = 2 * 1 = 2
  \item
    factorial(3) = 3 * 2 = 6
  \item
    factorial(4) = 4 * 6 = 24
  \item
    factorial(5) = 5 * 24 = 120
  \end{itemize}
\item
  અંતિમ પરિણામ, 120, પરત કરવામાં આવે છે.
\end{enumerate}

આ રીકર્સિવ અભિગમ 5! ની ગણતરી કરવાની સમસ્યાને નાની ઉપ-સમસ્યાઓમાં વિભાજિત કરે છે,
અંતે બેઝ કેસ સુધી પહોંચે છે અને પછી ઉકેલને પાછો બાંધે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["factorial(5)"] {-}{-}\textgreater{} B["5 * factorial(4)"]}
\NormalTok{    B {-}{-}\textgreater{} C["5 * 4 * factorial(3)"]}
\NormalTok{    C {-}{-}\textgreater{} D["5 * 4 * 3 * factorial(2)"]}
\NormalTok{    D {-}{-}\textgreater{} E["5 * 4 * 3 * 2 * factorial(1)"]}
\NormalTok{    E {-}{-}\textgreater{} F[5 * 4 * 3 * 2 * 1]}
\NormalTok{    F {-}{-}\textgreater{} G[120]}
\end{Highlighting}
\end{Shaded}

\hypertarget{q2cor-develop-a-python-code-to-implement-enqueue-and-dequeue-operation-in-queue.-07-marks}{%
\subsubsection{Q2cOR: Develop a python code to implement Enqueue and
Dequeue operation in Queue. (07
marks)}\label{q2cor-develop-a-python-code-to-implement-enqueue-and-dequeue-operation-in-queue.-07-marks}}

\textbf{Ans 2cOR:}

Here's a Python implementation of a Queue class with Enqueue and Dequeue
operations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Queue:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, capacity):}
        \VariableTok{self}\NormalTok{.capacity }\OperatorTok{=}\NormalTok{ capacity}
        \VariableTok{self}\NormalTok{.queue }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{] }\OperatorTok{*}\NormalTok{ capacity}
        \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}
        \VariableTok{self}\NormalTok{.size }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ is\_empty(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ is\_full(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \VariableTok{self}\NormalTok{.capacity}

    \KeywordTok{def}\NormalTok{ enqueue(}\VariableTok{self}\NormalTok{, item):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_full():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue Overflow! Cannot enqueue item:"}\NormalTok{, item)}
            \ControlFlowTok{return}

        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \DecValTok{0}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.rear }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.rear }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}

        \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.rear] }\OperatorTok{=}\NormalTok{ item}
        \VariableTok{self}\NormalTok{.size }\OperatorTok{+=} \DecValTok{1}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Enqueued }\SpecialCharTok{\{}\NormalTok{item}\SpecialCharTok{\}}\SpecialStringTok{ to the queue"}\NormalTok{)}

    \KeywordTok{def}\NormalTok{ dequeue(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue Underflow! Cannot dequeue from an empty queue"}\NormalTok{)}
            \ControlFlowTok{return} \VariableTok{None}

\NormalTok{        item }\OperatorTok{=} \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.front]}
        \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.front] }\OperatorTok{=} \VariableTok{None}

        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.front }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}

        \VariableTok{self}\NormalTok{.size }\OperatorTok{{-}=} \DecValTok{1}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Dequeued }\SpecialCharTok{\{}\NormalTok{item}\SpecialCharTok{\}}\SpecialStringTok{ from the queue"}\NormalTok{)}
        \ControlFlowTok{return}\NormalTok{ item}

    \KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue is empty"}\NormalTok{)}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            index }\OperatorTok{=} \VariableTok{self}\NormalTok{.front}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"Queue contents:"}\NormalTok{)}
            \ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\VariableTok{self}\NormalTok{.size):}
                \BuiltInTok{print}\NormalTok{(}\VariableTok{self}\NormalTok{.queue[index], end}\OperatorTok{=}\StringTok{" "}\NormalTok{)}
\NormalTok{                index }\OperatorTok{=}\NormalTok{ (index }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}
            \BuiltInTok{print}\NormalTok{()}

\CommentTok{\# Example usage:}
\NormalTok{queue }\OperatorTok{=}\NormalTok{ Queue(}\DecValTok{5}\NormalTok{)}

\NormalTok{queue.enqueue(}\DecValTok{1}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{2}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{3}\NormalTok{)}
\NormalTok{queue.display()}

\NormalTok{queue.dequeue()}
\NormalTok{queue.display()}

\NormalTok{queue.enqueue(}\DecValTok{4}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{5}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{6}\NormalTok{)}
\NormalTok{queue.display()}

\NormalTok{queue.dequeue()}
\NormalTok{queue.dequeue()}
\NormalTok{queue.display()}

\NormalTok{queue.enqueue(}\DecValTok{7}\NormalTok{)}
\NormalTok{queue.display()}
\end{Highlighting}
\end{Shaded}

Explanation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{Queue} class is initialized with a fixed capacity. It uses
  a list to store elements and keeps track of the front, rear, and size
  of the queue.
\item
  \texttt{is\_empty()} and \texttt{is\_full()} methods check if the
  queue is empty or full, respectively.
\item
  \texttt{enqueue(item)} operation:

  \begin{itemize}
  \tightlist
  \item
    Checks if the queue is full before adding an item.
  \item
    If it's the first item, sets both front and rear to 0.
  \item
    Otherwise, increments rear using modulo arithmetic to wrap around.
  \item
    Adds the item and increments the size.
  \end{itemize}
\item
  \texttt{dequeue()} operation:

  \begin{itemize}
  \tightlist
  \item
    Checks if the queue is empty before removing an item.
  \item
    Retrieves the item at the front.
  \item
    If it's the last item, resets front and rear to -1.
  \item
    Otherwise, increments front using modulo arithmetic.
  \item
    Decrements the size and returns the dequeued item.
  \end{itemize}
\item
  \texttt{display()} method shows the current contents of the queue.
\end{enumerate}

The example usage demonstrates enqueue and dequeue operations, handling
overflow and underflow conditions, and displaying the queue's contents
at various stages.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Initialize Queue] {-}{-}\textgreater{} B\{Is Queue Full?\}}
\NormalTok{    B {-}{-}\textgreater{}|Yes| C[Overflow Error]}
\NormalTok{    B {-}{-}\textgreater{}|No| D[Enqueue Item]}
\NormalTok{    D {-}{-}\textgreater{} E\{Is Queue Empty?\}}
\NormalTok{    E {-}{-}\textgreater{}|Yes| F[Underflow Error]}
\NormalTok{    E {-}{-}\textgreater{}|No| G[Dequeue Item]}
\NormalTok{    G {-}{-}\textgreater{} H[Update Front/Rear]}
\NormalTok{    D {-}{-}\textgreater{} I[Update Rear]}
\NormalTok{    I {-}{-}\textgreater{} J[Display Queue]}
\NormalTok{    H {-}{-}\textgreater{} J}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-2uxa95or-enqueue-uxa85uxaa8-dequeue-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 2કOR: Enqueue અને Dequeue ઓપરેશન માટેનો પાયથન કોડ
વિકસાવો. (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-2uxa95or-enqueue-uxa85uxaa8-dequeue-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 2કOR:}

અહીં Enqueue અને Dequeue ઓપરેશન્સ સાથે Queue ક્લાસનું પાયથન અમલીકરણ આપ્યું છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Queue:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, capacity):}
        \VariableTok{self}\NormalTok{.capacity }\OperatorTok{=}\NormalTok{ capacity}
        \VariableTok{self}\NormalTok{.queue }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{] }\OperatorTok{*}\NormalTok{ capacity}
        \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}
        \VariableTok{self}\NormalTok{.size }\OperatorTok{=} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ is\_empty(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \DecValTok{0}

    \KeywordTok{def}\NormalTok{ is\_full(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \VariableTok{self}\NormalTok{.capacity}

    \KeywordTok{def}\NormalTok{ enqueue(}\VariableTok{self}\NormalTok{, item):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_full():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુ ઓવરફ્લો! આઇટમ એનક્યુ કરી શકાતી નથી:"}\NormalTok{, item)}
            \ControlFlowTok{return}

        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \DecValTok{0}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.rear }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.rear }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}

        \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.rear] }\OperatorTok{=}\NormalTok{ item}
        \VariableTok{self}\NormalTok{.size }\OperatorTok{+=} \DecValTok{1}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{item}\SpecialCharTok{\}}\SpecialStringTok{ ને ક્યુમાં એનક્યુ કર્યું"}\NormalTok{)}

    \KeywordTok{def}\NormalTok{ dequeue(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુ અન્ડરફ્લો! ખાલી ક્યુમાંથી ડિક્યુ કરી શકાતું નથી"}\NormalTok{)}
            \ControlFlowTok{return} \VariableTok{None}

\NormalTok{        item }\OperatorTok{=} \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.front]}
        \VariableTok{self}\NormalTok{.queue[}\VariableTok{self}\NormalTok{.front] }\OperatorTok{=} \VariableTok{None}

        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.size }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=} \VariableTok{self}\NormalTok{.rear }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.front }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.front }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}

        \VariableTok{self}\NormalTok{.size }\OperatorTok{{-}=} \DecValTok{1}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{item}\SpecialCharTok{\}}\SpecialStringTok{ ને ક્યુમાંથી ડિક્યુ કર્યું"}\NormalTok{)}
        \ControlFlowTok{return}\NormalTok{ item}

    \KeywordTok{def}\NormalTok{ display(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.is\_empty():}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુ ખાલી છે"}\NormalTok{)}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            index }\OperatorTok{=} \VariableTok{self}\NormalTok{.front}
            \BuiltInTok{print}\NormalTok{(}\StringTok{"ક્યુની સામગ્રી:"}\NormalTok{)}
            \ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\VariableTok{self}\NormalTok{.size):}
                \BuiltInTok{print}\NormalTok{(}\VariableTok{self}\NormalTok{.queue[index], end}\OperatorTok{=}\StringTok{" "}\NormalTok{)}
\NormalTok{                index }\OperatorTok{=}\NormalTok{ (index }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{\%} \VariableTok{self}\NormalTok{.capacity}
            \BuiltInTok{print}\NormalTok{()}

\CommentTok{\# ઉપયોગનું ઉદાહરણ:}
\NormalTok{queue }\OperatorTok{=}\NormalTok{ Queue(}\DecValTok{5}\NormalTok{)}

\NormalTok{queue.enqueue(}\DecValTok{1}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{2}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{3}\NormalTok{)}
\NormalTok{queue.display()}

\NormalTok{queue.dequeue()}
\NormalTok{queue.display()}

\NormalTok{queue.enqueue(}\DecValTok{4}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{5}\NormalTok{)}
\NormalTok{queue.enqueue(}\DecValTok{6}\NormalTok{)}
\NormalTok{queue.display()}

\NormalTok{queue.dequeue()}
\NormalTok{queue.dequeue()}
\NormalTok{queue.display()}

\NormalTok{queue.enqueue(}\DecValTok{7}\NormalTok{)}
\NormalTok{queue.display()}
\end{Highlighting}
\end{Shaded}

સમજૂતી:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Queue} ક્લાસ નિશ્ચિત ક્ષમતા સાથે શરૂ થાય છે. તે એલિમેન્ટ્સ સંગ્રહ કરવા માટે
  લિસ્ટનો ઉપયોગ કરે છે અને ક્યુના આગળ, પાછળ અને કદને ટ્રૅક કરે છે.
\item
  \texttt{is\_empty()} અને \texttt{is\_full()} મેથડ્સ અનુક્રમે ક્યુ ખાલી છે કે
  ભરેલી છે તે તપાસે છે.
\item
  \texttt{enqueue(item)} ઓપરેશન:

  \begin{itemize}
  \tightlist
  \item
    આઇટમ ઉમેરતા પહેલા તપાસે છે કે ક્યુ ભરેલી છે કે નહીં.
  \item
    જો તે પ્રથમ આઇટમ હોય, તો આગળ અને પાછળ બંનેને 0 પર સેટ કરે છે.
  \item
    અન્યથા, પાછળને મોડ્યુલો ગણિતનો ઉપયોગ કરીને વધારે છે જેથી તે ફરીથી શરૂઆતમાં આવી
    શકે.
  \item
    આઇટમ ઉમેરે છે અને કદ વધારે છે.
  \end{itemize}
\item
  \texttt{dequeue()} ઓપરેશન:

  \begin{itemize}
  \tightlist
  \item
    આઇટમ કાઢતા પહેલા તપાસે છે કે ક્યુ ખાલી છે કે નહીં.
  \item
    આગળના આઇટમને મેળવે છે.
  \item
    જો તે છેલ્લી આઇટમ હોય, તો આગળ અને પાછળને -1 પર રીસેટ કરે છે.
  \item
    અન્યથા, આગળને મોડ્યુલો ગણિતનો ઉપયોગ કરીને વધારે છે.
  \item
    કદ ઘટાડે છે અને ડિક્યુ કરેલી આઇટમ પરત કરે છે.
  \end{itemize}
\item
  \texttt{display()} મેથડ ક્યુની વર્તમાન સામગ્રી બતાવે છે.
\end{enumerate}

ઉપયોગનું ઉદાહરણ enqueue અને dequeue ઓપરેશન્સ, ઓવરફ્લો અને અન્ડરફ્લો સ્થિતિઓને
સંભાળવાનું અને વિવિધ તબક્કે ક્યુની સામગ્રી પ્રદર્શિત કરવાનું દર્શાવે છે.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[ક્યુ શરૂ કરો] {-}{-}\textgreater{} B\{શું ક્યુ ભરેલી છે?\}}
\NormalTok{    B {-}{-}\textgreater{}|હા| C[ઓવરફ્લો ભૂલ]}
\NormalTok{    B {-}{-}\textgreater{}|ના| D[આઇટમ એનક્યુ કરો]}
\NormalTok{    D {-}{-}\textgreater{} E\{શું ક્યુ ખાલી છે?\}}
\NormalTok{    E {-}{-}\textgreater{}|હા| F[અન્ડરફ્લો ભૂલ]}
\NormalTok{    E {-}{-}\textgreater{}|ના| G[આઇટમ ડિક્યુ કરો]}
\NormalTok{    G {-}{-}\textgreater{} H[આગળ/પાછળ અપડેટ કરો]}
\NormalTok{    D {-}{-}\textgreater{} I[પાછળ અપડેટ કરો]}
\NormalTok{    I {-}{-}\textgreater{} J[ક્યુ પ્રદર્શિત કરો]}
\NormalTok{    H {-}{-}\textgreater{} J}
\end{Highlighting}
\end{Shaded}

\hypertarget{q3a-give-difference-between-singly-linked-list-and-circular-linked-list.-03-marks}{%
\subsubsection{Q3a: Give Difference between Singly linked list and
Circular linked list. (03
marks)}\label{q3a-give-difference-between-singly-linked-list-and-circular-linked-list.-03-marks}}

\textbf{Ans 3a:}

Singly linked list and Circular linked list are both linear data
structures, but they have some key differences in their structure and
behavior. Here's a comparison:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Structure}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: Each node points to the next node, and the last
    node points to NULL.
  \item
    Circular Linked List: Similar to singly linked list, but the last
    node points back to the first node, forming a circle.
  \end{itemize}
\item
  \textbf{Last Node}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: The last node contains a NULL pointer,
    indicating the end of the list.
  \item
    Circular Linked List: The last node contains a pointer to the first
    node.
  \end{itemize}
\item
  \textbf{Traversal}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: Traversal starts at the head and ends when NULL
    is reached.
  \item
    Circular Linked List: Traversal can start at any node and end when
    it reaches the starting node again.
  \end{itemize}
\item
  \textbf{Insertion at End}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: Requires traversing the entire list to reach the
    last node.
  \item
    Circular Linked List: Can be done in constant time if we maintain a
    pointer to the last node.
  \end{itemize}
\item
  \textbf{Memory Usage}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: Uses slightly less memory as the last node
    stores NULL.
  \item
    Circular Linked List: Uses marginally more memory as every node
    stores a valid address.
  \end{itemize}
\item
  \textbf{Identifying End}:

  \begin{itemize}
  \tightlist
  \item
    Singly Linked List: End is identified by NULL pointer.
  \item
    Circular Linked List: End is identified when we reach the starting
    node again.
  \end{itemize}
\end{enumerate}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2754}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3913}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Singly Linked List
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Circular Linked List
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Last Node Points To & NULL & First Node \\
Traversal End & At NULL & At Starting Node \\
Cycle & No cycle & Forms a cycle \\
Insertion at End & O(n) time & O(1) time with tail pointer \\
Space Efficiency & Slightly more efficient & Slightly less efficient \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "Singly Linked List"}
\NormalTok{        A((1)) {-}{-}\textgreater{} B((2))}
\NormalTok{        B {-}{-}\textgreater{} C((3))}
\NormalTok{        C {-}{-}\textgreater{} D((NULL))}
\NormalTok{    end}
\NormalTok{    subgraph "Circular Linked List"}
\NormalTok{        E((1)) {-}{-}\textgreater{} F((2))}
\NormalTok{        F {-}{-}\textgreater{} G((3))}
\NormalTok{        G {-}{-}\textgreater{} E}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{uxaaauxab0uxab6uxaa8-3uxa85-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxa85uxaa8-uxab8uxab0uxa95uxaafuxab2uxab0-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3અ: સીંગલી લિંક્ડ લીસ્ટ અને સર્ક્યુલર લિંક્ડ લીસ્ટ નો તફાવત
આપો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3uxa85-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxa85uxaa8-uxab8uxab0uxa95uxaafuxab2uxab0-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxaa4uxaabuxab5uxaa4-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 3અ:}

સીંગલી લિંક્ડ લીસ્ટ અને સર્ક્યુલર લિંક્ડ લીસ્ટ બંને લીનિયર ડેટા સ્ટ્રક્ચર્સ છે, પરંતુ તેમની
રચના અને વર્તણૂકમાં કેટલાક મહત્વપૂર્ણ તફાવતો છે. અહીં એક તુલના આપી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{રચના}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: દરેક નોડ આગળના નોડને પોઇન્ટ કરે છે, અને છેલ્લું નોડ NULL ને
    પોઇન્ટ કરે છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: સીંગલી લિંક્ડ લીસ્ટ જેવું જ, પરંતુ છેલ્લું નોડ પ્રથમ નોડને પાછું
    પોઇન્ટ કરે છે, વર્તુળ બનાવે છે.
  \end{itemize}
\item
  \textbf{છેલ્લું નોડ}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: છેલ્લા નોડમાં NULL પોઇન્ટર હોય છે, જે લીસ્ટના અંતને સૂચવે છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: છેલ્લા નોડમાં પ્રથમ નોડનો પોઇન્ટર હોય છે.
  \end{itemize}
\item
  \textbf{ટ્રાવર્સલ}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: ટ્રાવર્સલ હેડથી શરૂ થાય છે અને NULL સુધી પહોંચે ત્યારે સમાપ્ત
    થાય છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: ટ્રાવર્સલ કોઈપણ નોડથી શરૂ થઈ શકે છે અને જ્યારે તે ફરીથી
    શરૂઆતના નોડ પર પહોંચે ત્યારે સમાપ્ત થાય છે.
  \end{itemize}
\item
  \textbf{અંતે ઉમેરો}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: છેલ્લા નોડ સુધી પહોંચવા માટે આખી લીસ્ટને ટ્રાવર્સ કરવાની જરૂર
    પડે છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: જો આપણે છેલ્લા નોડનો પોઇન્ટર જાળવીએ તો સતત સમયમાં કરી
    શકાય છે.
  \end{itemize}
\item
  \textbf{મેમરી વપરાશ}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: છેલ્લું નોડ NULL સંગ્રહિત કરે છે તેથી થોડી ઓછી મેમરીનો ઉપયોગ
    કરે છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: દરેક નોડ માન્ય સરનામું સંગ્રહિત કરે છે તેથી થોડી વધારે
    મેમરીનો ઉપયોગ કરે છે.
  \end{itemize}
\item
  \textbf{અંતની ઓળખ}:

  \begin{itemize}
  \tightlist
  \item
    સીંગલી લિંક્ડ લીસ્ટ: NULL પોઇન્ટર દ્વારા અંત ઓળખાય છે.
  \item
    સર્ક્યુલર લિંક્ડ લીસ્ટ: જ્યારે આપણે ફરીથી શરૂઆતના નોડ પર પહોંચીએ ત્યારે અંત ઓળખાય
    છે.
  \end{itemize}
\end{enumerate}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & સીંગલી લિંક્ડ લીસ્ટ & સર્ક્યુલર લિંક્ડ લીસ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
છેલ્લું નોડ પોઇન્ટ કરે છે & NULL તરફ & પ્રથમ નોડ તરફ \\
ટ્રાવર્સલ અંત & NULL પર & શરૂઆતના નોડ પર \\
ચક્ર & કોઈ ચક્ર નથી & ચક્ર બનાવે છે \\
અંતે ઉમેરો & O(n) સમય & O(1) સમય (tail પોઇન્ટર સાથે) \\
જગ્યા કાર્યક્ષમતા & થોડી વધુ કાર્યક્ષમ & થોડી ઓછી કાર્યક્ષમ \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "સીંગલી લિંક્ડ લીસ્ટ"}
\NormalTok{        A((1)) {-}{-}\textgreater{} B((2))}
\NormalTok{        B {-}{-}\textgreater{} C((3))}
\NormalTok{        C {-}{-}\textgreater{} D((NULL))}
\NormalTok{    end}
\NormalTok{    subgraph "સર્ક્યુલર લિંક્ડ લીસ્ટ"}
\NormalTok{        E((1)) {-}{-}\textgreater{} F((2))}
\NormalTok{        F {-}{-}\textgreater{} G((3))}
\NormalTok{        G {-}{-}\textgreater{} E}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\hypertarget{q3b-explain-concept-of-doubly-linked-list.-04-marks}{%
\subsubsection{Q3b: Explain concept of Doubly linked list. (04
marks)}\label{q3b-explain-concept-of-doubly-linked-list.-04-marks}}

\textbf{Ans 3b:}

A doubly linked list is a linear data structure that consists of a
sequence of elements where each element contains three components: 1.
Data 2. A pointer to the next node 3. A pointer to the previous node

Key characteristics of a doubly linked list include:

\begin{itemize}
\tightlist
\item
  \textbf{Bidirectional traversal}: Unlike a singly linked list, a
  doubly linked list can be traversed in both forward and backward
  directions.
\item
  \textbf{Dynamic size}: The list can grow or shrink in size during
  program execution.
\item
  \textbf{Non-contiguous memory}: Nodes are not stored in contiguous
  memory locations.
\end{itemize}

\textbf{Structure of a node in a doubly linked list:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.prev }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

\textbf{Advantages:} - Bidirectional traversal allows for more efficient
insertion and deletion operations. - Reverse lookup is possible without
the need for an additional data structure.

\textbf{Disadvantages:} - Requires more memory due to the extra pointer
in each node. - Increased complexity in implementation and maintenance.

\textbf{Common operations:} - Insertion (at beginning, end, or any
position) - Deletion (from beginning, end, or any position) - Traversal
(forward and backward) - Searching for an element

\textbf{Diagram:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A["Node 1\textless{}br/\textgreater{}Data: 10\textless{}br/\textgreater{}Prev: NULL"] }
\NormalTok{    B[["Node 2\textless{}br/\textgreater{}Data: 20"]]}
\NormalTok{    C["Node 3\textless{}br/\textgreater{}Data: 30\textless{}br/\textgreater{}Next: NULL"]}
\NormalTok{    A {-}{-}Next{-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}Next{-}{-}\textgreater{} C}
\NormalTok{    C {-}{-}Prev{-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}Prev{-}{-}\textgreater{} A}
\end{Highlighting}
\end{Shaded}

\textbf{Applications:} - Implementation of navigation systems
(forward/backward) - Undo/Redo functionality in applications - Browser
cache for storing recently visited pages

In conclusion, doubly linked lists provide enhanced flexibility in data
manipulation at the cost of increased memory usage and complexity.

\hypertarget{uxaaauxab0uxab6uxaa8-3uxaac-uxaa1uxaacuxab2-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3બ: ડબલી લિન્ક્ડ લીસ્ટ નો કોન્સેપ્ટ સમજાવો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3uxaac-uxaa1uxaacuxab2-uxab2uxaa8uxa95uxaa1-uxab2uxab8uxa9f-uxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 3બ:}

ડબલી લિન્ક્ડ લીસ્ટ એ એક લીનીયર ડેટા સ્ટ્રક્ચર છે જેમાં એલિમેન્ટ્સની એક શ્રેણી હોય છે જેમાં
દરેક એલિમેન્ટમાં ત્રણ ઘટકો હોય છે: 1. ડેટા 2. આગળના નોડ તરફ નિર્દેશ કરતું પોઈન્ટર 3.
પાછલા નોડ તરફ નિર્દેશ કરતું પોઈન્ટર

ડબલી લિન્ક્ડ લીસ્ટની મુખ્ય લાક્ષણિકતાઓમાં સામેલ છે:

\begin{itemize}
\tightlist
\item
  \textbf{દ્વિદિશ ટ્રાવર્સલ}: સિંગલી લિન્ક્ડ લીસ્ટથી વિપરીત, ડબલી લિન્ક્ડ લીસ્ટને
  આગળ અને પાછળ બંને દિશાઓમાં ટ્રાવર્સ કરી શકાય છે.
\item
  \textbf{ડાયનેમિક સાઇઝ}: પ્રોગ્રામના અમલીકરણ દરમિયાન લીસ્ટનું કદ વધી અથવા ઘટી
  શકે છે.
\item
  \textbf{નોન-કન્ટીગ્યુઅસ મેમરી}: નોડ્સ સળંગ મેમરી સ્થાનોમાં સંગ્રહિત થતા નથી.
\end{itemize}

\textbf{ડબલી લિન્ક્ડ લીસ્ટમાં નોડની રચના:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.prev }\OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

\textbf{ફાયદા:} - દ્વિદિશ ટ્રાવર્સલ વધુ કાર્યક્ષમ insertion અને deletion
ऑપરેશન્સની મંજૂરી આપે છે. - વધારાના ડેટા સ્ટ્રક્ચરની જરૂર વિના રિવર્સ લુકઅપ શક્ય છે.

\textbf{ગેરફાયદા:} - દરેક નોડમાં વધારાના પોઈન્ટરને કારણે વધુ મેમરીની જરૂર પડે છે. -
અમલીકરણ અને જાળવણીમાં વધેલી જટિલતા.

\textbf{સામાન્ય ઓપરેશન્સ:} - Insertion (શરૂઆતમાં, અંતમાં, અથવા કોઈપણ સ્થિતિમાં) -
Deletion (શરૂઆતથી, અંતથી, અથવા કોઈપણ સ્થિતિથી) - Traversal (આગળ અને પાછળ) -
કોઈ એલિમેન્ટ માટે શોધ

\textbf{આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[["Node 1\textless{}br/\textgreater{}Data: 10\textless{}br/\textgreater{}Prev: NULL"]] }
\NormalTok{    B[["Node 2\textless{}br/\textgreater{}Data: 20"]]}
\NormalTok{    C[["Node 3\textless{}br/\textgreater{}Data: 30\textless{}br/\textgreater{}Next: NULL"]]}
\NormalTok{    A {-}{-}Next{-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}Next{-}{-}\textgreater{} C}
\NormalTok{    C {-}{-}Prev{-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}Prev{-}{-}\textgreater{} A}
\end{Highlighting}
\end{Shaded}

\textbf{એપ્લિકેશન્સ:} - નેવિગેશન સિસ્ટમ્સનું અમલીકરણ (આગળ/પાછળ) - એપ્લિકેશન્સમાં
અનડુ/રીડુ કાર્યક્ષમતા - તાજેતરમાં મુલાકાત લીધેલા પેજોને સંગ્રહિત કરવા માટે બ્રાઉઝર કેશ

નિષ્કર્ષમાં, ડબલી લિન્ક્ડ લીસ્ટ વધેલી મેમરી વપરાશ અને જટિલતાની કિંમતે ડેટા
મેનિપ્યુલેશનમાં વધારેલી લવચીકતા પ્રદાન કરે છે.

\hypertarget{q3c-write-an-algorithm-for-following-operations-on-singly-linked-list-07-marks}{%
\subsubsection{Q3c: Write an algorithm for following operations on
singly linked list: (07
marks)}\label{q3c-write-an-algorithm-for-following-operations-on-singly-linked-list-07-marks}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item ~
  \hypertarget{to-insert-a-node-at-the-beginning-of-the-list.}{%
  \subsubsection{To insert a node at the beginning of the
  list.}\label{to-insert-a-node-at-the-beginning-of-the-list.}}
\item ~
  \hypertarget{to-insert-the-node-at-the-end-of-the-list.}{%
  \subsubsection{To insert the node at the end of the
  list.}\label{to-insert-the-node-at-the-end-of-the-list.}}
\end{enumerate}

\textbf{Ans 3c:}

Let's start by defining the structure of a node in a singly linked list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

Now, let's write algorithms for the two operations:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Algorithm to insert a node at the beginning of the list:}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insert\_at\_beginning(head, new\_data):}
    \CommentTok{\# Step 1: Create a new node}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(new\_data)}
    
    \CommentTok{\# Step 2: Make the new node point to the current head}
\NormalTok{    new\_node.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ head}
    
    \CommentTok{\# Step 3: Update the head to point to the new node}
\NormalTok{    head }\OperatorTok{=}\NormalTok{ new\_node}
    
    \CommentTok{\# Step 4: Return the new head}
    \ControlFlowTok{return}\NormalTok{ head}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:} - We create a new node with the given data. - We
set the next pointer of the new node to the current head, effectively
linking it to the rest of the list. - We update the head to point to the
new node, making it the new first element. - We return the new head of
the list.

\textbf{Time Complexity:} O(1) - constant time operation

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Algorithm to insert a node at the end of the list:}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insert\_at\_end(head, new\_data):}
    \CommentTok{\# Step 1: Create a new node}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(new\_data)}
    
    \CommentTok{\# Step 2: If the list is empty, make the new node the head}
    \ControlFlowTok{if}\NormalTok{ head }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ new\_node}
    
    \CommentTok{\# Step 3: Traverse to the last node}
\NormalTok{    current }\OperatorTok{=}\NormalTok{ head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    
    \CommentTok{\# Step 4: Link the last node to the new node}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}
    
    \CommentTok{\# Step 5: Return the head (unchanged in this case)}
    \ControlFlowTok{return}\NormalTok{ head}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:} - We create a new node with the given data. - If
the list is empty (head is None), we return the new node as the head. -
We traverse the list to find the last node (the one with next pointing
to None). - We set the next pointer of the last node to our new node. -
We return the head of the list (which remains unchanged in this
operation).

\textbf{Time Complexity:} O(n), where n is the number of nodes in the
list

\textbf{Diagram illustrating both operations:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "Insert at Beginning"}
\NormalTok{        A[New Node] {-}{-}\textgreater{} B[Old Head]}
\NormalTok{        B {-}{-}\textgreater{} C[...]}
\NormalTok{    end}
\NormalTok{    subgraph "Insert at End"}
\NormalTok{        D[Head] {-}{-}\textgreater{} E[...]}
\NormalTok{        E {-}{-}\textgreater{} F[Last Node]}
\NormalTok{        F {-}{-}\textgreater{} G[New Node]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

In conclusion, inserting at the beginning is generally more efficient as
it's a constant time operation, while inserting at the end requires
traversing the entire list, making it less efficient for large lists.

\hypertarget{uxaaauxab0uxab6uxaa8-3uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3ક: નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો: (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96-uxae6uxaed-uxa97uxaa3}}

\hypertarget{uxab2uxab8uxa9f-uxaa8-uxab6uxab0uxa86uxaa4uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5}{%
\subsubsection{૧. લીસ્ટ ની શરૂઆતમાં નોડ દાખલ
કરવા}\label{uxab2uxab8uxa9f-uxaa8-uxab6uxab0uxa86uxaa4uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5}}

\hypertarget{uxab2uxab8uxa9f-uxaa8-uxa85uxaa4uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5}{%
\subsubsection{૨. લીસ્ટ ના અંતમાં નોડ દાખલ
કરવા}\label{uxab2uxab8uxa9f-uxaa8-uxa85uxaa4uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5}}

\textbf{જવાબ 3ક:}

ચાલો પ્રથમ singly linked list માં નોડની રચના વ્યાખ્યાયિત કરીએ:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

હવે, ચાલો બે ઓપરેશન્સ માટે અલગોરિધમ લખીએ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{લીસ્ટની શરૂઆતમાં નોડ દાખલ કરવાનો અલગોરિધમ:}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insert\_at\_beginning(head, new\_data):}
    \CommentTok{\# પગલું 1: નવું નોડ બનાવો}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(new\_data)}
    
    \CommentTok{\# પગલું 2: નવા નોડને વર્તમાન head તરફ પોઇન્ટ કરાવો}
\NormalTok{    new\_node.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ head}
    
    \CommentTok{\# પગલું 3: head ને અપડેટ કરો જેથી તે નવા નોડ તરફ પોઇન્ટ કરે}
\NormalTok{    head }\OperatorTok{=}\NormalTok{ new\_node}
    
    \CommentTok{\# પગલું 4: નવા head ને પરત કરો}
    \ControlFlowTok{return}\NormalTok{ head}
\end{Highlighting}
\end{Shaded}

\textbf{સમજૂતી:} - આપેલા ડેટા સાથે આપણે એક નવું નોડ બનાવીએ છીએ. - નવા નોડના
next પોઇન્ટરને વર્તમાન head પર સેટ કરીએ છીએ, જેથી તે બાકીની લિસ્ટ સાથે જોડાય
જાય. - આપણે head ને અપડેટ કરીએ છીએ જેથી તે નવા નોડ તરફ પોઇન્ટ કરે, જે હવે નવું પ્રથમ
એલિમેન્ટ બની જાય છે. - આપણે લિસ્ટનો નવો head પરત કરીએ છીએ.

\textbf{સમય જટિલતા:} O(1) - સતત સમય ઓપરેશન

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{લીસ્ટના અંતમાં નોડ દાખલ કરવાનો અલગોરિધમ:}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insert\_at\_end(head, new\_data):}
    \CommentTok{\# પગલું 1: નવું નોડ બનાવો}
\NormalTok{    new\_node }\OperatorTok{=}\NormalTok{ Node(new\_data)}
    
    \CommentTok{\# પગલું 2: જો લિસ્ટ ખાલી હોય, તો નવા નોડને head બનાવો}
    \ControlFlowTok{if}\NormalTok{ head }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ new\_node}
    
    \CommentTok{\# પગલું 3: છેલ્લા નોડ સુધી ટ્રાવર્સ કરો}
\NormalTok{    current }\OperatorTok{=}\NormalTok{ head}
    \ControlFlowTok{while}\NormalTok{ current.}\BuiltInTok{next}\NormalTok{:}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    
    \CommentTok{\# પગલું 4: છેલ્લા નોડને નવા નોડ સાથે જોડો}
\NormalTok{    current.}\BuiltInTok{next} \OperatorTok{=}\NormalTok{ new\_node}
    
    \CommentTok{\# પગલું 5: head ને પરત કરો (આ કેસમાં અપરિવર્તિત)}
    \ControlFlowTok{return}\NormalTok{ head}
\end{Highlighting}
\end{Shaded}

\textbf{સમજૂતી:} - આપેલા ડેટા સાથે આપણે એક નવું નોડ બનાવીએ છીએ. - જો લિસ્ટ ખાલી
હોય (head None હોય), તો આપણે નવા નોડને head તરીકે પરત કરીએ છીએ. - આપણે છેલ્લા
નોડને શોધવા માટે લિસ્ટને ટ્રાવર્સ કરીએ છીએ (જેનું next None તરફ પોઇન્ટ કરતું હોય). -
આપણે છેલ્લા નોડના next પોઇન્ટરને આપણા નવા નોડ પર સેટ કરીએ છીએ. - આપણે લિસ્ટનો
head પરત કરીએ છીએ (જે આ ઓપરેશનમાં અપરિવર્તિત રહે છે).

\textbf{સમય જટિલતા:} O(n), જ્યાં n લિસ્ટમાં નોડ્સની સંખ્યા છે

\textbf{બંને ઓપરેશન્સને દર્શાવતી આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    subgraph "શરૂઆતમાં દાખલ કરવું"}
\NormalTok{        A[નવું નોડ] {-}{-}\textgreater{} B[જૂનું Head]}
\NormalTok{        B {-}{-}\textgreater{} C[...]}
\NormalTok{    end}
\NormalTok{    subgraph "અંતમાં દાખલ કરવું"}
\NormalTok{        D[Head] {-}{-}\textgreater{} E[...]}
\NormalTok{        E {-}{-}\textgreater{} F[છેલ્લું નોડ]}
\NormalTok{        F {-}{-}\textgreater{} G[નવું નોડ]}
\NormalTok{    end}

\end{Highlighting}
\end{Shaded}

નિષ્કર્ષમાં, શરૂઆતમાં દાખલ કરવું સામાન્ય રીતે વધુ કાર્યક્ષમ છે કારણ કે તે સતત સમય ઓપરેશન
છે, જ્યારે અંતમાં દાખલ કરવા માટે સમગ્ર લિસ્ટને ટ્રાવર્સ કરવાની જરૂર પડે છે, જે મોટી
લિસ્ટ માટે ઓછું કાર્યક્ષમ બનાવે છે.

\hypertarget{q3aor-list-different-operations-performed-on-singly-linked-list.-03-marks}{%
\subsubsection{Q3aOR: List different operations performed on singly
linked list. (03
marks)}\label{q3aor-list-different-operations-performed-on-singly-linked-list.-03-marks}}

\textbf{Ans 3aOR:}

The singly linked list is a fundamental data structure that supports
various operations. Here's a list of the most common operations
performed on a singly linked list:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Insertion operations:}

  \begin{itemize}
  \tightlist
  \item
    Insert at the beginning (head)
  \item
    Insert at the end (tail)
  \item
    Insert at a specific position
  \end{itemize}
\item
  \textbf{Deletion operations:}

  \begin{itemize}
  \tightlist
  \item
    Delete from the beginning
  \item
    Delete from the end
  \item
    Delete from a specific position
  \item
    Delete a node with a given value
  \end{itemize}
\item
  \textbf{Traversal operation:}

  \begin{itemize}
  \tightlist
  \item
    Traverse the list to display all elements
  \end{itemize}
\item
  \textbf{Search operation:}

  \begin{itemize}
  \tightlist
  \item
    Search for a specific element in the list
  \end{itemize}
\item
  \textbf{Update operation:}

  \begin{itemize}
  \tightlist
  \item
    Modify the data of a specific node
  \end{itemize}
\item
  \textbf{Length calculation:}

  \begin{itemize}
  \tightlist
  \item
    Count the number of nodes in the list
  \end{itemize}
\item
  \textbf{Reverse operation:}

  \begin{itemize}
  \tightlist
  \item
    Reverse the order of nodes in the list
  \end{itemize}
\item
  \textbf{Merge operation:}

  \begin{itemize}
  \tightlist
  \item
    Combine two singly linked lists into one
  \end{itemize}
\item
  \textbf{Sort operation:}

  \begin{itemize}
  \tightlist
  \item
    Arrange the nodes in a specific order (e.g., ascending or
    descending)
  \end{itemize}
\end{enumerate}

\textbf{Diagram illustrating some key operations:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[Tail]}
\NormalTok{    F[New Node] {-}.Insert at beginning.{-}\textgreater{} A}
\NormalTok{    G[New Node] {-}.Insert at end.{-}\textgreater{} E}
\NormalTok{    H[New Node] {-}.Insert at position.{-}\textgreater{} C}
\NormalTok{    I[Delete] {-}.{-}\textgreater{} B}
\NormalTok{    J[Search] {-}.{-}\textgreater{} D}
\end{Highlighting}
\end{Shaded}

These operations form the core functionality of a singly linked list,
allowing for efficient data manipulation and management in various
applications.

\hypertarget{uxaaauxab0uxab6uxaa8-3aor-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaaauxab0uxaa8-uxab5uxab5uxaa7-uxa93uxaaauxab0uxab6uxaa8uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3aOR: સિંગલી લિંક્ડ લિસ્ટ પરના વિવિધ ઓપરેશનની યાદી આપો.
(૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3aor-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9f-uxaaauxab0uxaa8-uxab5uxab5uxaa7-uxa93uxaaauxab0uxab6uxaa8uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 3aOR:}

સિંગલી લિંક્ડ લિસ્ટ એ એક મૂળભૂત ડેટા સ્ટ્રક્ચર છે જે વિવિધ ઓપરેશનોને સપોર્ટ કરે છે. અહીં
સિંગલી લિંક્ડ લિસ્ટ પર કરવામાં આવતા સૌથી સામાન્ય ઓપરેશનોની યાદી છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{દાખલ કરવાના (Insertion) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    શરૂઆતમાં (head) દાખલ કરવું
  \item
    અંતમાં (tail) દાખલ કરવું
  \item
    ચોક્કસ સ્થાને દાખલ કરવું
  \end{itemize}
\item
  \textbf{કાઢી નાખવાના (Deletion) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    શરૂઆતથી કાઢી નાખવું
  \item
    અંતથી કાઢી નાખવું
  \item
    ચોક્કસ સ્થાનેથી કાઢી નાખવું
  \item
    આપેલી કિંમત ધરાવતા નોડને કાઢી નાખવું
  \end{itemize}
\item
  \textbf{ટ્રાવર્સલ ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    બધા એલિમેન્ટ્સ પ્રદર્શિત કરવા માટે લિસ્ટને ટ્રાવર્સ કરવી
  \end{itemize}
\item
  \textbf{શોધ (Search) ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    લિસ્ટમાં ચોક્કસ એલિમેન્ટ શોધવું
  \end{itemize}
\item
  \textbf{અપડેટ ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    ચોક્કસ નોડનો ડેટા સુધારવો
  \end{itemize}
\item
  \textbf{લંબાઈની ગણતરી:}

  \begin{itemize}
  \tightlist
  \item
    લિસ્ટમાં નોડની સંખ્યા ગણવી
  \end{itemize}
\item
  \textbf{રિવર્સ ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    લિસ્ટમાં નોડનો ક્રમ ઉલટાવવો
  \end{itemize}
\item
  \textbf{મર્જ ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    બે સિંગલી લિંક્ડ લિસ્ટને એક કરવી
  \end{itemize}
\item
  \textbf{સોર્ટ ઓપરેશન:}

  \begin{itemize}
  \tightlist
  \item
    નોડને ચોક્કસ ક્રમમાં ગોઠવવા (દા.ત., ચઢતા અથવા ઉતરતા ક્રમમાં)
  \end{itemize}
\end{enumerate}

\textbf{કેટલાક મુખ્ય ઓપરેશનોને દર્શાવતી આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Head] {-}{-}\textgreater{} B[Node 1]}
\NormalTok{    B {-}{-}\textgreater{} C[Node 2]}
\NormalTok{    C {-}{-}\textgreater{} D[Node 3]}
\NormalTok{    D {-}{-}\textgreater{} E[Tail]}
\NormalTok{    F[નવું Node] {-}.શરૂઆતમાં દાખલ.{-}\textgreater{} A}
\NormalTok{    G[નવું Node] {-}.અંતમાં દાખલ.{-}\textgreater{} E}
\NormalTok{    H[નવું Node] {-}.સ્થાને દાખલ.{-}\textgreater{} C}
\NormalTok{    I[કાઢી નાખવું] {-}.{-}\textgreater{} B}
\NormalTok{    J[શોધ] {-}.{-}\textgreater{} D}
\end{Highlighting}
\end{Shaded}

આ ઓપરેશનો સિંગલી લિંક્ડ લિસ્ટની મુખ્ય કાર્યક્ષમતા રચે છે, જે વિવિધ એપ્લિકેશનોમાં
કાર્યક્ષમ ડેટા મેનિપ્યુલેશન અને મેનેજમેન્ટની મંજૂરી આપે છે.

\hypertarget{q3bor-explain-concept-of-circular-linked-list.-04-marks}{%
\subsubsection{Q3bOR: Explain concept of Circular linked list. (04
marks)}\label{q3bor-explain-concept-of-circular-linked-list.-04-marks}}

\textbf{Ans 3bOR:}

A circular linked list is a variation of a linked list in which the last
node points back to the first node, creating a circular structure. This
circular nature allows for continuous traversal through the list, as
there is no null end point.

Key characteristics of a circular linked list include:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{No Null Termination:} Unlike a standard linked list, there is
  no null at the end. The last node's next pointer points to the first
  node.
\item
  \textbf{Any Node Can Be a Starting Point:} Due to its circular nature,
  any node can serve as the starting point for traversal.
\item
  \textbf{Efficient Circular Operations:} It's particularly useful for
  applications requiring repeated cycling through a list of elements.
\item
  \textbf{Types:}

  \begin{itemize}
  \tightlist
  \item
    Singly Circular Linked List: Each node has only one link pointing to
    the next node.
  \item
    Doubly Circular Linked List: Each node has two links, one to the
    next node and one to the previous node.
  \end{itemize}
\item
  \textbf{Implementation:} Usually implemented with a header node or a
  tail pointer for efficient insertions and deletions.
\end{enumerate}

\textbf{Structure of a node in a circular linked list:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}  \CommentTok{\# In a doubly circular list, there would also be a self.prev}
\end{Highlighting}
\end{Shaded}

\textbf{Advantages:} - Allows for constant-time insertion at the
beginning and end of the list. - Useful for implementing circular
buffers or queues. - Simplifies certain algorithms, like round-robin
scheduling.

\textbf{Disadvantages:} - Slightly more complex to implement and manage
than linear linked lists. - Risk of infinite loops if not handled
carefully.

\textbf{Diagram of a Circular Linked List:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A((Node 1)) {-}{-}\textgreater{} B((Node 2))}
\NormalTok{    B {-}{-}\textgreater{} C((Node 3))}
\NormalTok{    C {-}{-}\textgreater{} D((Node 4))}
\NormalTok{    D {-}{-}\textgreater{}|Circular Link| A}
\end{Highlighting}
\end{Shaded}

In this diagram, Node 4 points back to Node 1, creating the circular
structure.

Applications of circular linked lists include: - Implementation of
circular buffers - Round-robin scheduling in operating systems -
Maintaining a playlist for music players - Implementing circular queues
in computer science

In conclusion, circular linked lists offer unique advantages in
scenarios requiring cyclic data structures, providing efficient circular
traversal and operations at both ends of the list.

\hypertarget{uxaaauxab0uxab6uxaa8-3bor-uxab8uxab0uxa95uxaafuxab2uxab0-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3bOR: સર્ક્યુલર લિંક્ડ લીસ્ટનો કોન્સેપ્ટ સમજાવો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3bor-uxab8uxab0uxa95uxaafuxab2uxab0-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxa95uxaa8uxab8uxaaauxa9f-uxab8uxaaeuxa9cuxab5.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 3bOR:}

સર્ક્યુલર લિંક્ડ લીસ્ટ એ લિંક્ડ લીસ્ટનો એક પ્રકાર છે જેમાં છેલ્લું નોડ પાછું પ્રથમ નોડ તરફ
પોઈન્ટ કરે છે, જે એક વર્તુળાકાર રચના બનાવે છે. આ વર્તુળાકાર પ્રકૃતિ લિસ્ટમાં સતત
ટ્રાવર્સલની મંજૂરી આપે છે, કારણ કે ત્યાં કોઈ null અંતિમ બિંદુ નથી.

સર્ક્યુલર લિંક્ડ લીસ્ટની મુખ્ય લાક્ષણિકતાઓમાં સામેલ છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Null સમાપ્તિ નથી:} પ્રમાણભૂત લિંક્ડ લીસ્ટથી વિપરીત, અંતે કોઈ null નથી.
  છેલ્લા નોડનું next પોઈન્ટર પ્રથમ નોડ તરફ પોઈન્ટ કરે છે.
\item
  \textbf{કોઈપણ નોડ પ્રારંભિક બિંદુ બની શકે છે:} તેની વર્તુળાકાર પ્રકૃતિને કારણે,
  કોઈપણ નોડ ટ્રાવર્સલ માટે પ્રારંભિક બિંદુ તરીકે કાર્ય કરી શકે છે.
\item
  \textbf{કાર્યક્ષમ વર્તુળાકાર ઓપરેશન્સ:} તે એલિમેન્ટ્સની સૂચિમાંથી વારંવાર સાયકલિંગની
  જરૂર પડતી એપ્લિકેશનો માટે ખાસ કરીને ઉપયોગી છે.
\item
  \textbf{પ્રકારો:}

  \begin{itemize}
  \tightlist
  \item
    સિંગલી સર્ક્યુલર લિંક્ડ લીસ્ટ: દરેક નોડમાં માત્ર એક લિંક હોય છે જે આગળના નોડ તરફ
    પોઈન્ટ કરે છે.
  \item
    ડબલી સર્ક્યુલર લિંક્ડ લીસ્ટ: દરેક નોડમાં બે લિંક હોય છે, એક આગળના નોડ તરફ અને એક
    પાછલા નોડ તરફ.
  \end{itemize}
\item
  \textbf{અમલીકરણ:} સામાન્ય રીતે કાર્યક્ષમ insertions અને deletions માટે હેડર
  નોડ અથવા tail પોઈન્ટર સાથે અમલમાં મૂકવામાં આવે છે.
\end{enumerate}

\textbf{સર્ક્યુલર લિંક્ડ લીસ્ટમાં નોડની રચના:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, data):}
        \VariableTok{self}\NormalTok{.data }\OperatorTok{=}\NormalTok{ data}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{next} \OperatorTok{=} \VariableTok{None}  \CommentTok{\# ડબલી સર્ક્યુલર લીસ્ટમાં, ત્યાં self.prev પણ હશે}
\end{Highlighting}
\end{Shaded}

\textbf{ફાયદા:} - લિસ્ટની શરૂઆત અને અંતમાં સતત-સમય insertion ની મંજૂરી આપે છે. -
સર્ક્યુલર બફર્સ અથવા queues ને અમલમાં મૂકવા માટે ઉપયોગી. - કેટલાક અલ્ગોરિધમ્સને સરળ
બનાવે છે, જેમ કે round-robin શેડ્યુલિંગ.

\textbf{ગેરફાયદા:} - લીનીયર લિંક્ડ લીસ્ટ્સ કરતાં થોડું વધુ જટિલ અમલીકરણ અને સંચાલન.
- કાળજીપૂર્વક હેન્ડલ ન કરવામાં આવે તો અનંત લૂપ્સનું જોખમ.

\textbf{સર્ક્યુલર લિંક્ડ લીસ્ટની આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A((નોડ 1)) {-}{-}\textgreater{} B((નોડ 2))}
\NormalTok{    B {-}{-}\textgreater{} C((નોડ 3))}
\NormalTok{    C {-}{-}\textgreater{} D((નોડ 4))}
\NormalTok{    D {-}{-}\textgreater{}|સર્ક્યુલર લિંક| A}
\end{Highlighting}
\end{Shaded}

આ આકૃતિમાં, નોડ 4 પાછું નોડ 1 તરફ પોઈન્ટ કરે છે, જે વર્તુળાકાર રચના બનાવે છે.

સર્ક્યુલર લિંક્ડ લીસ્ટના ઉપયોગોમાં સામેલ છે: - સર્ક્યુલર બફર્સનું અમલીકરણ - ઓપરેટિંગ
સિસ્ટમ્સમાં round-robin શેડ્યુલિંગ - મ્યુઝિક પ્લેયર્સ માટે પ્લેલિસ્ટ જાળવવી - કમ્પ્યુટર
સાયન્સમાં સર્ક્યુલર queues નું અમલીકરણ

નિષ્કર્ષમાં, સર્ક્યુલર લિંક્ડ લીસ્ટ્સ cyclic ડેટા સ્ટ્રક્ચર્સની જરૂર પડતા સંજોગોમાં અનન્ય
ફાયદાઓ આપે છે, કાર્યક્ષમ વર્તુળાકાર ટ્રાવર્સલ અને લિસ્ટના બંને છેડે ઓપરેશન્સ પૂરા પાડે છે.

\hypertarget{q3cor-list-applications-of-linked-list.-write-an-algorithm-to-count-the-number-of-nodes-in-singly-linked-list.-07-marks}{%
\subsubsection{Q3cOR: List applications of linked list. Write an
algorithm to count the number of nodes in singly linked list. (07
marks)}\label{q3cor-list-applications-of-linked-list.-write-an-algorithm-to-count-the-number-of-nodes-in-singly-linked-list.-07-marks}}

\textbf{Ans 3cOR:}

\textbf{Applications of Linked List:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Dynamic Memory Allocation:} Used in memory management systems.
\item
  \textbf{Implementation of Data Structures:}

  \begin{itemize}
  \tightlist
  \item
    Stacks and Queues
  \item
    Hash tables (for handling collisions)
  \item
    Graphs (adjacency lists)
  \end{itemize}
\item
  \textbf{Undo Functionality:} In applications like text editors for
  maintaining edit history.
\item
  \textbf{Polynomial Arithmetic:} Representing and manipulating
  polynomials.
\item
  \textbf{Music Player Playlists:} Managing songs in a playlist.
\item
  \textbf{Image Viewer:} For navigating through a series of images.
\item
  \textbf{Browser History:} Storing and navigating through visited web
  pages.
\item
  \textbf{Symbol Table Management:} In compiler design.
\item
  \textbf{File Systems:} In operating systems for directory management.
\item
  \textbf{Sparse Matrix Representation:} Efficient storage of matrices
  with many zero elements.
\end{enumerate}

\textbf{Algorithm to count the number of nodes in a singly linked list:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ count\_nodes(head):}
    \CommentTok{\# Step 1: Initialize counter}
\NormalTok{    count }\OperatorTok{=} \DecValTok{0}
    
    \CommentTok{\# Step 2: Initialize current node to head}
\NormalTok{    current }\OperatorTok{=}\NormalTok{ head}
    
    \CommentTok{\# Step 3: Traverse the list}
    \ControlFlowTok{while}\NormalTok{ current }\KeywordTok{is} \KeywordTok{not} \VariableTok{None}\NormalTok{:}
        \CommentTok{\# Step 3a: Increment counter}
\NormalTok{        count }\OperatorTok{+=} \DecValTok{1}
        
        \CommentTok{\# Step 3b: Move to next node}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    
    \CommentTok{\# Step 4: Return the count}
    \ControlFlowTok{return}\NormalTok{ count}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation of the algorithm:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We start by initializing a counter variable to 0.
\item
  We set a pointer (current) to the head of the list.
\item
  We enter a loop that continues as long as the current node is not
  None:

  \begin{itemize}
  \tightlist
  \item
    In each iteration, we increment the counter.
  \item
    We move the current pointer to the next node.
  \end{itemize}
\item
  Once we've traversed the entire list (current becomes None), we return
  the final count.
\end{enumerate}

\textbf{Time Complexity:} O(n), where n is the number of nodes in the
list. \textbf{Space Complexity:} O(1), as we only use a constant amount
of extra space.

\textbf{Diagram illustrating the node counting process:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A((1)) {-}{-}\textgreater{} B((2))}
\NormalTok{    B {-}{-}\textgreater{} C((3))}
\NormalTok{    C {-}{-}\textgreater{} D((4))}
\NormalTok{    D {-}{-}\textgreater{} E((NULL))}
\NormalTok{    F[Count: 0] {-}.{-}\textgreater{} A}
\NormalTok{    G[Count: 1] {-}.{-}\textgreater{} B}
\NormalTok{    H[Count: 2] {-}.{-}\textgreater{} C}
\NormalTok{    I[Count: 3] {-}.{-}\textgreater{} D}
\NormalTok{    J[Count: 4] {-}.{-}\textgreater{} E}
\end{Highlighting}
\end{Shaded}

This diagram shows how the count increases as we traverse each node in
the list.

In conclusion, linked lists have a wide range of applications in
computer science and software development. The algorithm to count nodes
demonstrates a fundamental operation on linked lists, showcasing the
sequential access nature of this data structure.

\hypertarget{uxaaauxab0uxab6uxaa8-3cor-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxa8fuxaaauxab2uxa95uxab6uxaa8uxaa8-uxaafuxaa6-uxa86uxaaa.-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaae-uxa95uxab2-uxaa8uxaa1-uxa97uxaa3uxab5-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 3cOR: લિંક્ડ લીસ્ટની એપ્લિકેશનોની યાદી આપો. સિંગલી લિંક્ડ
લીસ્ટમાં કુલ નોડ ગણવા માટેનો અલગોરિધમ લખો. (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-3cor-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaa8-uxa8fuxaaauxab2uxa95uxab6uxaa8uxaa8-uxaafuxaa6-uxa86uxaaa.-uxab8uxa97uxab2-uxab2uxa95uxaa1-uxab2uxab8uxa9fuxaae-uxa95uxab2-uxaa8uxaa1-uxa97uxaa3uxab5-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 3cOR:}

\textbf{લિંક્ડ લીસ્ટની એપ્લિકેશનો:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{ડાયનેમિક મેમરી એલોકેશન:} મેમરી મેનેજમેન્ટ સિસ્ટમ્સમાં વપરાય છે.
\item
  \textbf{ડેટા સ્ટ્રક્ચર્સનું અમલીકરણ:}

  \begin{itemize}
  \tightlist
  \item
    સ્ટેક્સ અને ક્યૂઝ
  \item
    હેશ ટેબલ્સ (કોલિઝન્સ હેન્ડલ કરવા માટે)
  \item
    ગ્રાફ્સ (એડજેસન્સી લિસ્ટ્સ)
  \end{itemize}
\item
  \textbf{અનડુ ફંક્શનાલિટી:} ટેક્સ્ટ એડિટર્સ જેવી એપ્લિકેશનોમાં એડિટ હિસ્ટ્રી જાળવવા
  માટે.
\item
  \textbf{પોલિનોમિયલ એરિથમેટિક:} પોલિનોમિયલ્સને રજૂ કરવા અને મેનિપ્યુલેટ કરવા
  માટે.
\item
  \textbf{મ્યુઝિક પ્લેયર પ્લેલિસ્ટ્સ:} પ્લેલિસ્ટમાં ગીતોનું સંચાલન કરવા માટે.
\item
  \textbf{ઇમેજ વ્યૂઅર:} ચિત્રોની શ્રેણીમાં નેવિગેટ કરવા માટે.
\item
  \textbf{બ્રાઉઝર હિસ્ટ્રી:} મુલાકાત લીધેલા વેબ પેજોને સંગ્રહિત કરવા અને નેવિગેટ કરવા
  માટે.
\item
  \textbf{સિમ્બોલ ટેબલ મેનેજમેન્ટ:} કમ્પાઇલર ડિઝાઇનમાં.
\item
  \textbf{ફાઇલ સિસ્ટમ્સ:} ઓપરેટિંગ સિસ્ટમ્સમાં ડિરેક્ટરી મેનેજમેન્ટ માટે.
\item
  \textbf{સ્પાર્સ મેટ્રિક્સ રિપ્રેઝન્ટેશન:} ઘણા શૂન્ય તત્વો ધરાવતી મેટ્રિસિસનો કાર્યક્ષમ
  સંગ્રહ.
\end{enumerate}

\textbf{સિંગલી લિંક્ડ લીસ્ટમાં કુલ નોડ ગણવા માટેનો અલગોરિધમ:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ count\_nodes(head):}
    \CommentTok{\# પગલું 1: કાઉન્ટર પ્રારંભિક કરો}
\NormalTok{    count }\OperatorTok{=} \DecValTok{0}
    
    \CommentTok{\# પગલું 2: વર્તમાન નોડને head પર સેટ કરો}
\NormalTok{    current }\OperatorTok{=}\NormalTok{ head}
    
    \CommentTok{\# પગલું 3: લિસ્ટને ટ્રાવર્સ કરો}
    \ControlFlowTok{while}\NormalTok{ current }\KeywordTok{is} \KeywordTok{not} \VariableTok{None}\NormalTok{:}
        \CommentTok{\# પગલું 3અ: કાઉન્ટર વધારો}
\NormalTok{        count }\OperatorTok{+=} \DecValTok{1}
        
        \CommentTok{\# પગલું 3બ: આગળના નોડ પર જાઓ}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current.}\BuiltInTok{next}
    
    \CommentTok{\# પગલું 4: કાઉન્ટ પરત કરો}
    \ControlFlowTok{return}\NormalTok{ count}
\end{Highlighting}
\end{Shaded}

\textbf{અલગોરિધમની સમજૂતી:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  આપણે 0 થી કાઉન્ટર વેરિએબલ પ્રારંભ કરીએ છીએ.
\item
  આપણે લિસ્ટના head પર એક પોઇન્ટર (current) સેટ કરીએ છીએ.
\item
  આપણે એક લૂપમાં પ્રવેશ કરીએ છીએ જે ત્યાં સુધી ચાલે છે જ્યાં સુધી વર્તમાન નોડ None ન
  થાય:

  \begin{itemize}
  \tightlist
  \item
    દરેક પુનરાવર્તનમાં, આપણે કાઉન્ટર વધારીએ છીએ.
  \item
    આપણે વર્તમાન પોઇન્ટરને આગળના નોડ પર ખસેડીએ છીએ.
  \end{itemize}
\item
  એકવાર આપણે સમગ્ર લિસ્ટને ટ્રાવર્સ કરી લીધા પછી (current None બને છે), આપણે અંતિમ
  કાઉન્ટ પરત કરીએ છીએ.
\end{enumerate}

\textbf{સમય જટિલતા:} O(n), જ્યાં n લિસ્ટમાં નોડની સંખ્યા છે. \textbf{સ્પેસ
જટિલતા:} O(1), કારણ કે આપણે માત્ર સ્થિર જથ્થામાં વધારાની જગ્યાનો ઉપયોગ કરીએ
છીએ.

\textbf{નોડ ગણતરી પ્રક્રિયાને દર્શાવતી આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A((1)) {-}{-}\textgreater{} B((2))}
\NormalTok{    B {-}{-}\textgreater{} C((3))}
\NormalTok{    C {-}{-}\textgreater{} D((4))}
\NormalTok{    D {-}{-}\textgreater{} E((NULL))}
\NormalTok{    F[કાઉન્ટ: 0] {-}.{-}\textgreater{} A}
\NormalTok{    G[કાઉન્ટ: 1] {-}.{-}\textgreater{} B}
\NormalTok{    H[કાઉન્ટ: 2] {-}.{-}\textgreater{} C}
\NormalTok{    I[કાઉન્ટ: 3] {-}.{-}\textgreater{} D}
\NormalTok{    J[કાઉન્ટ: 4] {-}.{-}\textgreater{} E}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બતાવે છે કે કેવી રીતે આપણે લિસ્ટમાં દરેક નોડને ટ્રાવર્સ કરતી વખતે કાઉન્ટ વધે છે.

નિષ્કર્ષમાં, લિંક્ડ લીસ્ટ્સ કમ્પ્યુટર સાયન્સ અને સોફ્ટવેર ડેવલપમેન્ટમાં વ્યાપક રેન્જની
એપ્લિકેશનો ધરાવે છે. નોડ્સ ગણવાનો અલગોરિધમ લિંક્ડ લીસ્ટ્સ પરની મૂળભૂત કામગીરીનું
પ્રદર્શન કરે છે, આ ડેટા સ્ટ્રક્ચરની અનુક્રમિક ઍક્સેસ પ્રકૃતિને પ્રકાશિત કરે છે.

\hypertarget{q4a-compare-linear-search-with-binary-search.-03-marks}{%
\subsubsection{Q4a: Compare Linear search with Binary search. (03
marks)}\label{q4a-compare-linear-search-with-binary-search.-03-marks}}

\textbf{Ans 4a:}

Linear search and Binary search are two fundamental algorithms used for
searching elements in a collection. Here's a comparison of these two
search methods:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2340}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3546}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4113}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Linear Search
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Binary Search
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Basic Principle} & Sequentially checks each element & Divides
the search interval in half repeatedly \\
\textbf{Data Structure Requirement} & Works on both sorted and unsorted
data & Requires sorted data \\
\textbf{Time Complexity} & O(n) - where n is the number of elements &
O(log n) - where n is the number of elements \\
\textbf{Space Complexity} & O(1) - constant space & O(1) for iterative,
O(log n) for recursive implementation \\
\textbf{Best Case Scenario} & O(1) - if the element is at the beginning
& O(1) - if the element is in the middle \\
\textbf{Worst Case Scenario} & O(n) - if the element is at the end or
not present & O(log n) - even in worst case \\
\textbf{Simplicity} & Very simple to implement & More complex, requires
understanding of divide-and-conquer \\
\textbf{Efficiency for Large Datasets} & Inefficient for large datasets
& Very efficient for large datasets \\
\textbf{Use Case} & Small datasets or unsorted lists & Large, sorted
datasets \\
\end{longtable}

\textbf{Diagram comparing search patterns:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TB}
\NormalTok{    subgraph "Linear Search"}
\NormalTok{        A1[1] {-}{-}\textgreater{} A2[2] {-}{-}\textgreater{} A3[3] {-}{-}\textgreater{} A4[4] {-}{-}\textgreater{} A5[5]}
\NormalTok{    end}
\NormalTok{    subgraph "Binary Search"}
\NormalTok{        B1[1] {-}{-}\textgreater{} B3[3]}
\NormalTok{        B3 {-}{-}\textgreater{} B2[2]}
\NormalTok{        B3 {-}{-}\textgreater{} B4[4]}
\NormalTok{        B4 {-}{-}\textgreater{} B5[5]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

In this diagram, the arrows show the typical search pattern for each
algorithm. Linear search checks each element sequentially, while Binary
search divides the search space in half each time.

\hypertarget{uxaaauxab0uxab6uxaa8-4uxa85-uxab2uxaa8uxaafuxab0-uxab8uxab0uxa9a-uxa85uxaa8-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9auxaa8-uxab8uxab0uxa96uxaaeuxaa3-uxa95uxab0.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4અ: લીનીયર સર્ચ અને બાયનરી સર્ચની સરખામણી કરો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4uxa85-uxab2uxaa8uxaafuxab0-uxab8uxab0uxa9a-uxa85uxaa8-uxaacuxaafuxaa8uxab0-uxab8uxab0uxa9auxaa8-uxab8uxab0uxa96uxaaeuxaa3-uxa95uxab0.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 4અ:}

લીનીયર સર્ચ અને બાયનરી સર્ચ એ કલેક્શનમાં એલિમેન્ટ્સ શોધવા માટે ઉપયોગમાં લેવાતી બે
મૂળભૂત અલ્ગોરિધમ્સ છે. અહીં આ બે શોધ પદ્ધતિઓની સરખામણી છે:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2479}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3504}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4017}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લીનીયર સર્ચ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
બાયનરી સર્ચ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{મૂળભૂત સિદ્ધાંત} & ક્રમશः દરેક એલિમેન્ટની તપાસ કરે છે & શોધ અંતરાલને વારંવાર
અડધો કરે છે \\
\textbf{ડેટા સ્ટ્રક્ચર આવશ્યકતા} & સોર્ટેડ અને અનસોર્ટેડ બંને ડેટા પર કામ કરે છે &
સોર્ટેડ ડેટાની જરૂર પડે છે \\
\textbf{સમય જટિલતા} & O(n) - જ્યાં n એલિમેન્ટ્સની સંખ્યા છે & O(log n) - જ્યાં n
એલિમેન્ટ્સની સંખ્યા છે \\
\textbf{સ્પેસ જટિલતા} & O(1) - સ્થિર જગ્યા & O(1) પુનરાવર્તી માટે, O(log n)
રિકર્સિવ અમલીકરણ માટે \\
\textbf{શ્રેષ્ઠ કેસ સ્થિતિ} & O(1) - જો એલિમેન્ટ શરૂઆતમાં હોય & O(1) - જો એલિમેન્ટ
મધ્યમાં હોય \\
\textbf{સૌથી ખરાબ કેસ સ્થિતિ} & O(n) - જો એલિમેન્ટ અંતમાં હોય અથવા હાજર ન હોય
& O(log n) - સૌથી ખરાબ કેસમાં પણ \\
\textbf{સરળતા} & અમલ કરવા માટે ખૂબ જ સરળ & વધુ જટિલ, ડિવાઇડ-એન્ડ-કોન્કર
સમજવાની જરૂર પડે છે \\
\textbf{મોટા ડેટાસેટ્સ માટે કાર્યક્ષમતા} & મોટા ડેટાસેટ્સ માટે અકાર્યક્ષમ & મોટા
ડેટાસેટ્સ માટે ખૂબ જ કાર્યક્ષમ \\
\textbf{ઉપયોગનો કેસ} & નાના ડેટાસેટ્સ અથવા અનસોર્ટેડ લિસ્ટ્સ & મોટા, સોર્ટેડ
ડેટાસેટ્સ \\
\end{longtable}

\textbf{શોધ પેટર્નની સરખામણી કરતી આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TB}
\NormalTok{    subgraph "લીનીયર સર્ચ"}
\NormalTok{        A1[1] {-}{-}\textgreater{} A2[2] {-}{-}\textgreater{} A3[3] {-}{-}\textgreater{} A4[4] {-}{-}\textgreater{} A5[5]}
\NormalTok{    end}
\NormalTok{    subgraph "બાયનરી સર્ચ"}
\NormalTok{        B1[1] {-}{-}\textgreater{} B3[3]}
\NormalTok{        B3 {-}{-}\textgreater{} B2[2]}
\NormalTok{        B3 {-}{-}\textgreater{} B4[4]}
\NormalTok{        B4 {-}{-}\textgreater{} B5[5]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

આ આકૃતિમાં, તીરો દરેક અલ્ગોરિધમ માટે સામાન્ય શોધ પેટર્ન બતાવે છે. લીનીયર સર્ચ દરેક
એલિમેન્ટની ક્રમશઃ તપાસ કરે છે, જ્યારે બાયનરી સર્ચ દર વખતે શોધ સ્પેસને અડધો કરે છે.

\hypertarget{q4b-write-an-algorithm-for-selection-sort-method.-04-marks}{%
\subsubsection{Q4b: Write an algorithm for selection sort method. (04
marks)}\label{q4b-write-an-algorithm-for-selection-sort-method.-04-marks}}

\textbf{Ans 4b:}

Selection Sort is a simple comparison-based sorting algorithm. The main
idea is to divide the input list into two parts: a sorted portion at the
left end and an unsorted portion at the right end. Initially, the sorted
portion is empty and the unsorted portion is the entire list.

\textbf{Algorithm for Selection Sort:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initialize the sorted portion as empty and the unsorted portion as the
  entire list.
\item
  For each iteration from i = 0 to n-1 (where n is the number of
  elements):

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Find the minimum element in the unsorted portion (from index i to
    n-1).
  \item
    Swap this minimum element with the first element of the unsorted
    portion.
  \item
    Expand the sorted portion to include this newly positioned element.
  \end{enumerate}
\item
  Repeat step 2 until the entire list is sorted.
\end{enumerate}

\textbf{Python implementation of Selection Sort:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ selection\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# Find the minimum element in the unsorted portion}
\NormalTok{        min\_idx }\OperatorTok{=}\NormalTok{ i}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{, n):}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textless{}}\NormalTok{ arr[min\_idx]:}
\NormalTok{                min\_idx }\OperatorTok{=}\NormalTok{ j}
        
        \CommentTok{\# Swap the found minimum element with the first element of the unsorted portion}
\NormalTok{        arr[i], arr[min\_idx] }\OperatorTok{=}\NormalTok{ arr[min\_idx], arr[i]}
    
    \ControlFlowTok{return}\NormalTok{ arr}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation of the algorithm:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We start with the entire list as unsorted.
\item
  In each iteration:

  \begin{itemize}
  \tightlist
  \item
    We find the smallest element in the unsorted portion.
  \item
    We swap this smallest element with the first element of the unsorted
    portion.
  \item
    This effectively moves the boundary of the sorted portion one step
    to the right.
  \end{itemize}
\item
  We repeat this process until the entire list is sorted.
\end{enumerate}

\textbf{Visualization of Selection Sort:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["[64, 25, 12, 22, 11]"] {-}{-}\textgreater{} B["[11, 25, 12, 22, 64]"]}
\NormalTok{    B {-}{-}\textgreater{} C["[11, 12, 25, 22, 64]"]}
\NormalTok{    C {-}{-}\textgreater{} D["[11, 12, 22, 25, 64]"]}
\NormalTok{    D {-}{-}\textgreater{} E["[11, 12, 22, 25, 64]"]}
\end{Highlighting}
\end{Shaded}

This diagram shows how the list is progressively sorted from left to
right.

\textbf{Time Complexity:} O(n\^{}2) for all cases (best, average, and
worst) \textbf{Space Complexity:} O(1) as it sorts in-place

Selection Sort is not efficient for large lists but can be useful for
small lists or when memory write is a costly operation.

\hypertarget{uxaaauxab0uxab6uxaa8-4uxaac-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4બ: સિલેક્શન સોર્ટ માટેનો અલગોરિધમ લખો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4uxaac-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxaaeuxa9fuxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 4બ:}

સિલેક્શન સોર્ટ એ એક સરળ તુલના-આધારિત સોર્ટિંગ અલગોરિધમ છે. મુખ્ય વિચાર ઇનપુટ લિસ્ટને
બે ભાગમાં વિભાજિત કરવાનો છે: ડાબા છેડે સોર્ટેડ ભાગ અને જમણા છેડે અનસોર્ટેડ ભાગ.
શરૂઆતમાં, સોર્ટેડ ભાગ ખાલી હોય છે અને અનસોર્ટેડ ભાગ સંપૂર્ણ લિસ્ટ હોય છે.

\textbf{સિલેક્શન સોર્ટ માટેનો અલગોરિધમ:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  સોર્ટેડ ભાગને ખાલી અને અનસોર્ટેડ ભાગને સંપૂર્ણ લિસ્ટ તરીકે પ્રારંભ કરો.
\item
  i = 0 થી n-1 સુધી દરેક પુનરાવર્તન માટે (જ્યાં n એલિમેન્ટ્સની સંખ્યા છે):

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    અનસોર્ટેડ ભાગમાં (ઇન્ડેક્સ i થી n-1) લઘુત્તમ એલિમેન્ટ શોધો.
  \item
    આ લઘુત્તમ એલિમેન્ટને અનસોર્ટેડ ભાગના પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો.
  \item
    સોર્ટેડ ભાગને વિસ્તૃત કરો જેથી આ નવા સ્થાનિત એલિમેન્ટનો સમાવેશ થાય.
  \end{enumerate}
\item
  સંપૂર્ણ લિસ્ટ સોર્ટેડ ન થાય ત્યાં સુધી પગલું 2 પુનરાવર્તિત કરો.
\end{enumerate}

\textbf{પાયથોનમાં સિલેક્શન સોર્ટનું અમલીકરણ:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ selection\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# અનસોર્ટેડ ભાગમાં લઘુત્તમ એલિમેન્ટ શોધો}
\NormalTok{        min\_idx }\OperatorTok{=}\NormalTok{ i}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{, n):}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textless{}}\NormalTok{ arr[min\_idx]:}
\NormalTok{                min\_idx }\OperatorTok{=}\NormalTok{ j}
        
        \CommentTok{\# શોધાયેલ લઘુત્તમ એલિમેન્ટને અનસોર્ટેડ ભાગના પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો}
\NormalTok{        arr[i], arr[min\_idx] }\OperatorTok{=}\NormalTok{ arr[min\_idx], arr[i]}
    
    \ControlFlowTok{return}\NormalTok{ arr}
\end{Highlighting}
\end{Shaded}

\textbf{અલગોરિધમની સમજૂતી:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  આપણે સંપૂર્ણ લિસ્ટને અનસોર્ટેડ તરીકે શરૂ કરીએ છીએ.
\item
  દરેક પુનરાવર્તનમાં:

  \begin{itemize}
  \tightlist
  \item
    આપણે અનસોર્ટેડ ભાગમાં સૌથી નાના એલિમેન્ટને શોધીએ છીએ.
  \item
    આપણે આ સૌથી નાના એલિમેન્ટને અનસોર્ટેડ ભાગના પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરીએ છીએ.
  \item
    આ અસરકારક રીતે સોર્ટેડ ભાગની સીમાને એક પગલું જમણી તરફ ખસેડે છે.
  \end{itemize}
\item
  આપણે સંપૂર્ણ લિસ્ટ સોર્ટેડ ન થાય ત્યાં સુધી આ પ્રક્રિયાને પુનરાવર્તિત કરીએ છીએ.
\end{enumerate}

\textbf{સિલેક્શન સોર્ટની દૃશ્યાત્મક રજૂઆત:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["[64, 25, 12, 22, 11]"] {-}{-}\textgreater{} B["[11, 25, 12, 22, 64]"]}
\NormalTok{    B {-}{-}\textgreater{} C["[11, 12, 25, 22, 64]"]}
\NormalTok{    C {-}{-}\textgreater{} D["[11, 12, 22, 25, 64]"]}
\NormalTok{    D {-}{-}\textgreater{} E["[11, 12, 22, 25, 64]"]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બતાવે છે કે કેવી રીતે લિસ્ટ ડાબેથી જમણે ક્રમશઃ સોર્ટેડ થાય છે.

\textbf{સમય જટિલતા:} O(n\^{}2) બધા કેસ માટે (શ્રેષ્ઠ, સરેરાશ, અને સૌથી ખરાબ)
\textbf{સ્પેસ જટિલતા:} O(1) કારણ કે તે ઇન-પ્લેસ સોર્ટ કરે છે

સિલેક્શન સોર્ટ મોટી લિસ્ટ્સ માટે કાર્યક્ષમ નથી પરંતુ નાની લિસ્ટ્સ માટે અથવા જ્યારે મેમરી
લખવાનું ખર્ચાળ ઓપરેશન હોય ત્યારે ઉપયોગી થઈ શકે છે.

\hypertarget{q4c-develop-a-python-code-to-sort-the-following-list-in-ascending-order-using-bubble-sort-method.-list1543210-07-marks}{%
\subsubsection{Q4c: Develop a Python code to sort the following list in
ascending order using Bubble sort method. list1={[}5,4,3,2,1,0{]} (07
marks)}\label{q4c-develop-a-python-code-to-sort-the-following-list-in-ascending-order-using-bubble-sort-method.-list1543210-07-marks}}

\textbf{Ans 4c:}

Here's a Python implementation of the Bubble Sort algorithm to sort the
given list in ascending order:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bubble\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# Flag to optimize the algorithm}
\NormalTok{        swapped }\OperatorTok{=} \VariableTok{False}
        
        \CommentTok{\# Last i elements are already in place}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
            \CommentTok{\# Swap if the element found is greater than the next element}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
\NormalTok{                arr[j], arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], arr[j]}
\NormalTok{                swapped }\OperatorTok{=} \VariableTok{True}
        
        \CommentTok{\# If no swapping occurred, array is already sorted}
        \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ swapped:}
            \ControlFlowTok{break}
    
    \ControlFlowTok{return}\NormalTok{ arr}

\CommentTok{\# Initialize the list}
\NormalTok{list1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Original list:"}\NormalTok{, list1)}

\CommentTok{\# Sort the list using bubble sort}
\NormalTok{sorted\_list }\OperatorTok{=}\NormalTok{ bubble\_sort(list1)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Sorted list:"}\NormalTok{, sorted\_list)}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation of the code:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We define a \texttt{bubble\_sort} function that takes an array as
  input.
\item
  We get the length of the array and store it in \texttt{n}.
\item
  We use two nested loops:

  \begin{itemize}
  \tightlist
  \item
    The outer loop \texttt{i} runs \texttt{n} times, representing
    \texttt{n} passes over the array.
  \item
    The inner loop \texttt{j} compares adjacent elements and swaps them
    if they are in the wrong order.
  \end{itemize}
\item
  We use a \texttt{swapped} flag to optimize the algorithm. If no swaps
  occur in a pass, the list is already sorted, and we can exit early.
\item
  After sorting, we return the sorted array.
\item
  We initialize \texttt{list1} with the given values.
\item
  We print the original list, call the \texttt{bubble\_sort} function,
  and then print the sorted list.
\end{enumerate}

\textbf{Output:}

\begin{verbatim}
Original list: [5, 4, 3, 2, 1, 0]
Sorted list: [0, 1, 2, 3, 4, 5]
\end{verbatim}

\textbf{Visualization of the sorting process:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["[5, 4, 3, 2, 1, 0]"] {-}{-}\textgreater{} B["[4, 3, 2, 1, 0, 5]"]}
\NormalTok{    B {-}{-}\textgreater{} C["[3, 2, 1, 0, 4, 5]"]}
\NormalTok{    C {-}{-}\textgreater{} D["[2, 1, 0, 3, 4, 5]"]}
\NormalTok{    D {-}{-}\textgreater{} E["[1, 0, 2, 3, 4, 5]"]}
\NormalTok{    E {-}{-}\textgreater{} F["[0, 1, 2, 3, 4, 5]"]}
\end{Highlighting}
\end{Shaded}

This diagram shows how the largest element ``bubbles up'' to the end in
each pass.

\textbf{Time Complexity:} O(n\^{}2) in worst and average cases, O(n) in
best case (when the list is already sorted) \textbf{Space Complexity:}
O(1) as it sorts in-place

Bubble Sort is simple but not efficient for large lists. It's mainly
used for educational purposes or for very small datasets.

\hypertarget{uxaaauxab0uxab6uxaa8-4uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxab2uxab8uxa9fuxaa8-uxaacuxaacuxab2-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab5uxaa1-uxa9auxaa1uxaa4-uxa95uxab0uxaaeuxaae-uxa97uxaa0uxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-list1543210-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4ક: નીચે આપેલા લીસ્ટને બબલ સોર્ટ મેથડ વડે ચડતા ક્રમમાં ગોઠવવા
માટેનો પાયથન કોડ વિકસાવો. list1={[}5,4,3,2,1,0{]} (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxab2uxab8uxa9fuxaa8-uxaacuxaacuxab2-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab5uxaa1-uxa9auxaa1uxaa4-uxa95uxab0uxaaeuxaae-uxa97uxaa0uxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-list1543210-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 4ક:}

અહીં આપેલ લીસ્ટને ચડતા ક્રમમાં ગોઠવવા માટે બબલ સોર્ટ અલ્ગોરિધમનું પાયથન અમલીકરણ છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bubble\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# અલ્ગોરિધમને ઓપ્ટિમાઇઝ કરવા માટે ફ્લેગ}
\NormalTok{        swapped }\OperatorTok{=} \VariableTok{False}
        
        \CommentTok{\# છેલ્લા i એલિમેન્ટ્સ પહેલેથી જ યોગ્ય સ્થાને છે}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
            \CommentTok{\# જો મળેલું એલિમેન્ટ પછીના એલિમેન્ટ કરતાં મોટું હોય તો સ્વેપ કરો}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
\NormalTok{                arr[j], arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], arr[j]}
\NormalTok{                swapped }\OperatorTok{=} \VariableTok{True}
        
        \CommentTok{\# જો કોઈ સ્વેપિંગ ન થયું હોય, તો એરે પહેલેથી જ સોર્ટેડ છે}
        \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ swapped:}
            \ControlFlowTok{break}
    
    \ControlFlowTok{return}\NormalTok{ arr}

\CommentTok{\# લીસ્ટને પ્રારંભ કરો}
\NormalTok{list1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"મૂળ લીસ્ટ:"}\NormalTok{, list1)}

\CommentTok{\# બબલ સોર્ટનો ઉપયોગ કરીને લીસ્ટને સોર્ટ કરો}
\NormalTok{sorted\_list }\OperatorTok{=}\NormalTok{ bubble\_sort(list1)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"સોર્ટેડ લીસ્ટ:"}\NormalTok{, sorted\_list)}
\end{Highlighting}
\end{Shaded}

\textbf{કોડની સમજૂતી:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  આપણે \texttt{bubble\_sort} ફંક્શન વ્યાખ્યાયિત કરીએ છીએ જે એરેને ઇનપુટ તરીકે લે છે.
\item
  આપણે એરેની લંબાઈ મેળવીએ છીએ અને તેને \texttt{n} માં સંગ્રહિત કરીએ છીએ.
\item
  આપણે બે નેસ્ટેડ લૂપ્સનો ઉપયોગ કરીએ છીએ:

  \begin{itemize}
  \tightlist
  \item
    બાહ્ય લૂપ \texttt{i} \texttt{n} વખત ચાલે છે, જે એરે પર \texttt{n} પાસને રજૂ
    કરે છે.
  \item
    આંતરિક લૂપ \texttt{j} બાજુના એલિમેન્ટ્સની સરખામણી કરે છે અને જો તેઓ ખોટા ક્રમમાં
    હોય તો તેમને સ્વેપ કરે છે.
  \end{itemize}
\item
  આપણે અલ્ગોરિધમને ઓપ્ટિમાઇઝ કરવા માટે \texttt{swapped} ફ્લેગનો ઉપયોગ કરીએ છીએ.
  જો કોઈ પાસમાં સ્વેપ ન થાય, તો લીસ્ટ પહેલેથી જ સોર્ટેડ છે, અને આપણે વહેલા બહાર
  નીકળી શકીએ છીએ.
\item
  સોર્ટિંગ પછી, આપણે સોર્ટેડ એરે પરત કરીએ છીએ.
\item
  આપણે \texttt{list1} ને આપેલ મૂલ્યો સાથે પ્રારંભ કરીએ છીએ.
\item
  આપણે મૂળ લીસ્ટ પ્રિન્ટ કરીએ છીએ, \texttt{bubble\_sort} ફંક્શનને કૉલ કરીએ છીએ,
  અને પછી સોર્ટેડ લીસ્ટ પ્રિન્ટ કરીએ છીએ.
\end{enumerate}

\textbf{આઉટપુટ:}

\begin{verbatim}
મૂળ લીસ્ટ: [5, 4, 3, 2, 1, 0]
સોર્ટેડ લીસ્ટ: [0, 1, 2, 3, 4, 5]
\end{verbatim}

\textbf{સોર્ટિંગ પ્રક્રિયાની દૃશ્યાત્મક રજૂઆત:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A["[5, 4, 3, 2, 1, 0]"] {-}{-}\textgreater{} B["[4, 3, 2, 1, 0, 5]"]}
\NormalTok{    B {-}{-}\textgreater{} C["[3, 2, 1, 0, 4, 5]"]}
\NormalTok{    C {-}{-}\textgreater{} D["[2, 1, 0, 3, 4, 5]"]}
\NormalTok{    D {-}{-}\textgreater{} E["[1, 0, 2, 3, 4, 5]"]}
\NormalTok{    E {-}{-}\textgreater{} F["[0, 1, 2, 3, 4, 5]"]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ બતાવે છે કે કેવી રીતે દરેક પાસમાં સૌથી મોટું એલિમેન્ટ ``બબલ્સ અપ'' થઈને અંત સુધી
પહોંચે છે.

\textbf{સમય જટિલતા:} સૌથી ખરાબ અને સરેરાશ કેસમાં O(n\^{}2), શ્રેષ્ઠ કેસમાં O(n)
(જ્યારે લીસ્ટ પહેલેથી જ સોર્ટેડ હોય) \textbf{સ્પેસ જટિલતા:} O(1) કારણ કે તે ઇન-પ્લેસ
સોર્ટ કરે છે

બબલ સોર્ટ સરળ છે પરંતુ મોટી લીસ્ટ્સ માટે કાર્યક્ષમ નથી. તે મુખ્યત્વે શૈક્ષણિક હેતુઓ માટે
અથવા ખૂબ જ નાના ડેટાસેટ્સ માટે વપરાય છે.

\hypertarget{q4aor-define-sorting.-list-different-sorting-methods.-03-marks}{%
\subsubsection{Q4aOR: Define sorting. List different sorting methods.
(03
marks)}\label{q4aor-define-sorting.-list-different-sorting-methods.-03-marks}}

\textbf{Ans 4aOR:}

\textbf{Definition of Sorting:} Sorting is the process of arranging a
collection of data elements in a specific order, typically in ascending
or descending order based on one or more attributes of the elements.
This fundamental operation in computer science aims to organize data for
easier searching, analysis, and further processing.

\textbf{List of Different Sorting Methods:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Comparison-based sorting algorithms:}

  \begin{itemize}
  \tightlist
  \item
    Bubble Sort
  \item
    Selection Sort
  \item
    Insertion Sort
  \item
    Merge Sort
  \item
    Quick Sort
  \item
    Heap Sort
  \item
    Shell Sort
  \end{itemize}
\item
  \textbf{Non-comparison based sorting algorithms:}

  \begin{itemize}
  \tightlist
  \item
    Counting Sort
  \item
    Radix Sort
  \item
    Bucket Sort
  \end{itemize}
\item
  \textbf{Hybrid sorting algorithms:}

  \begin{itemize}
  \tightlist
  \item
    Introsort (Introspective Sort)
  \item
    Timsort
  \end{itemize}
\item
  \textbf{Distribution-based sorting:}

  \begin{itemize}
  \tightlist
  \item
    Pigeonhole Sort
  \end{itemize}
\item
  \textbf{Concurrent sorting algorithms:}

  \begin{itemize}
  \tightlist
  \item
    Bitonic Sort
  \item
    Odd-Even Sort
  \end{itemize}
\item
  \textbf{External sorting algorithms:}

  \begin{itemize}
  \tightlist
  \item
    External Merge Sort
  \end{itemize}
\end{enumerate}

\textbf{Diagram illustrating the concept of sorting:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[Unsorted Data] {-}{-}\textgreater{} B[Sorting Algorithm]}
\NormalTok{    B {-}{-}\textgreater{} C[Sorted Data]}
\NormalTok{    D[5, 2, 8, 1, 9] {-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}\textgreater{} E[1, 2, 5, 8, 9]}
\end{Highlighting}
\end{Shaded}

This diagram shows the general process of sorting, transforming unsorted
data into sorted data using a sorting algorithm.

\hypertarget{uxaaauxab0uxab6uxaa8-4aor-uxab8uxab0uxa9fuxa97uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxab5uxab5uxaa7-uxaaauxab0uxa95uxab0uxaa8-uxab8uxab0uxa9fuxa97uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4aOR: સોર્ટિંગની વ્યાખ્યા આપો. વિવિધ પ્રકારના સોર્ટિંગની
યાદી આપો. (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4aor-uxab8uxab0uxa9fuxa97uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-uxab5uxab5uxaa7-uxaaauxab0uxa95uxab0uxaa8-uxab8uxab0uxa9fuxa97uxaa8-uxaafuxaa6-uxa86uxaaa.-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 4aOR:}

\textbf{સોર્ટિંગની વ્યાખ્યા:} સોર્ટિંગ એ ડેટા એલિમેન્ટ્સના સંગ્રહને ચોક્કસ ક્રમમાં
ગોઠવવાની પ્રક્રિયા છે, સામાન્ય રીતે એલિમેન્ટ્સના એક અથવા વધુ ગુણધર્મોના આધારે ચડતા
અથવા ઉતરતા ક્રમમાં. કમ્પ્યુટર સાયન્સમાં આ મૂળભૂત ઓપરેશનનો ઉદ્દેશ સરળ શોધ, વિશ્લેષણ અને
વધુ પ્રક્રિયા માટે ડેટાને વ્યવસ્થિત કરવાનો છે.

\textbf{વિવિધ પ્રકારના સોર્ટિંગની યાદી:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{તુલના-આધારિત સોર્ટિંગ અલ્ગોરિધમ્સ:}

  \begin{itemize}
  \tightlist
  \item
    બબલ સોર્ટ
  \item
    સિલેક્શન સોર્ટ
  \item
    ઇન્સર્શન સોર્ટ
  \item
    મર્જ સોર્ટ
  \item
    ક્વિક સોર્ટ
  \item
    હીપ સોર્ટ
  \item
    શેલ સોર્ટ
  \end{itemize}
\item
  \textbf{બિન-તુલના આધારિત સોર્ટિંગ અલ્ગોરિધમ્સ:}

  \begin{itemize}
  \tightlist
  \item
    કાઉન્ટિંગ સોર્ટ
  \item
    રેડિક્સ સોર્ટ
  \item
    બકેટ સોર્ટ
  \end{itemize}
\item
  \textbf{હાઇબ્રિડ સોર્ટિંગ અલ્ગોરિધમ્સ:}

  \begin{itemize}
  \tightlist
  \item
    ઇન્ટ્રોસોર્ટ (ઇન્ટ્રોસ્પેક્ટિવ સોર્ટ)
  \item
    ટિમસોર્ટ
  \end{itemize}
\item
  \textbf{વિતરણ-આધારિત સોર્ટિંગ:}

  \begin{itemize}
  \tightlist
  \item
    પિજનહોલ સોર્ટ
  \end{itemize}
\item
  \textbf{સમવર્તી સોર્ટિંગ અલ્ગોરિધમ્સ:}

  \begin{itemize}
  \tightlist
  \item
    બાયટોનિક સોર્ટ
  \item
    ઓડ-ઈવન સોર્ટ
  \end{itemize}
\item
  \textbf{બાહ્ય સોર્ટિંગ અલ્ગોરિધમ્સ:}

  \begin{itemize}
  \tightlist
  \item
    એક્સટર્નલ મર્જ સોર્ટ
  \end{itemize}
\end{enumerate}

\textbf{સોર્ટિંગના ખ્યાલને દર્શાવતી આકૃતિ:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph LR}
\NormalTok{    A[અસોર્ટેડ ડેટા] {-}{-}\textgreater{} B[સોર્ટિંગ અલ્ગોરિધમ]}
\NormalTok{    B {-}{-}\textgreater{} C[સોર્ટેડ ડેટા]}
\NormalTok{    D[5, 2, 8, 1, 9] {-}{-}\textgreater{} B}
\NormalTok{    B {-}{-}\textgreater{} E[1, 2, 5, 8, 9]}
\end{Highlighting}
\end{Shaded}

આ આકૃતિ સોર્ટિંગની સામાન્ય પ્રક્રિયા દર્શાવે છે, જેમાં સોર્ટિંગ અલ્ગોરિધમનો ઉપયોગ કરીને
અસોર્ટેડ ડેટાને સોર્ટેડ ડેટામાં રૂપાંતરિત કરવામાં આવે છે.

\hypertarget{question-4b-or-write-an-algorithm-for-insertion-sort-method.-04-marks}{%
\subsubsection{Question 4(b) OR: Write an algorithm for Insertion sort
method. (04
marks)}\label{question-4b-or-write-an-algorithm-for-insertion-sort-method.-04-marks}}

\textbf{Ans 4(b)OR:}

Insertion sort is a simple sorting algorithm that builds the final
sorted array one item at a time. Here's the algorithm for the Insertion
sort method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Initialize:}

  \begin{itemize}
  \tightlist
  \item
    Start with the first element (index 0) as a sorted subset.
  \item
    Consider the rest of the array as the unsorted portion.
  \end{itemize}
\item
  \textbf{Iterate through unsorted portion:}

  \begin{itemize}
  \tightlist
  \item
    For each element from index 1 to n-1 (where n is the array length):

    \begin{itemize}
    \tightlist
    \item
      Store the current element as a key.
    \item
      Initialize j as the index of the previous element.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Compare and shift:}

  \begin{itemize}
  \tightlist
  \item
    While j ≥ 0 and the element at index j is greater than the key:

    \begin{itemize}
    \tightlist
    \item
      Shift the element at index j one position to the right.
    \item
      Decrement j.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Insert the key:}

  \begin{itemize}
  \tightlist
  \item
    Place the key at index j+1.
  \end{itemize}
\item
  \textbf{Repeat:}

  \begin{itemize}
  \tightlist
  \item
    Continue steps 2-4 until all elements are sorted.
  \end{itemize}
\end{enumerate}

Here's a visual representation of the Insertion sort algorithm:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B[Initialize: First element as sorted]}
\NormalTok{    B {-}{-}\textgreater{} C[Iterate through unsorted portion]}
\NormalTok{    C {-}{-}\textgreater{} D[Store current element as key]}
\NormalTok{    D {-}{-}\textgreater{} E[Compare key with sorted portion]}
\NormalTok{    E {-}{-}\textgreater{} F\{Is previous element \textgreater{} key?\}}
\NormalTok{    F {-}{-}\textgreater{}|Yes| G[Shift element right]}
\NormalTok{    G {-}{-}\textgreater{} E}
\NormalTok{    F {-}{-}\textgreater{}|No| H[Insert key in correct position]}
\NormalTok{    H {-}{-}\textgreater{} I\{More unsorted elements?\}}
\NormalTok{    I {-}{-}\textgreater{}|Yes| C}
\NormalTok{    I {-}{-}\textgreater{}|No| J[End]}
\end{Highlighting}
\end{Shaded}

Python implementation of Insertion sort:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insertion\_sort(arr):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(arr)):}
\NormalTok{        key }\OperatorTok{=}\NormalTok{ arr[i]}
\NormalTok{        j }\OperatorTok{=}\NormalTok{ i }\OperatorTok{{-}} \DecValTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textgreater{}=} \DecValTok{0} \KeywordTok{and}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ key:}
\NormalTok{            arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j]}
\NormalTok{            j }\OperatorTok{{-}=} \DecValTok{1}
\NormalTok{        arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ key}
    \ControlFlowTok{return}\NormalTok{ arr}
\end{Highlighting}
\end{Shaded}

\textbf{Time Complexity:} - Best Case: O(n) when the array is already
sorted - Average and Worst Case: O(n\^{}2)

\textbf{Space Complexity:} O(1) as it sorts in-place

Insertion sort is efficient for small data sets and nearly-sorted
arrays. It's stable and works well as an online algorithm, where new
elements can be added to the array efficiently.

\hypertarget{uxaaauxab0uxab6uxaa8-4uxaac-or-insertion-sort-method-uxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4(બ) OR: Insertion sort method નો અલગોરિધમ લખો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-insertion-sort-method-uxaa8-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 4(બ)OR:}

Insertion sort એ એક સરળ sorting અલગોરિધમ છે જે અંતિમ sorted array ને એક સમયે
એક item બનાવે છે. અહીં Insertion sort method નો અલગોરિધમ આપેલ છે:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{પ્રારંભ કરો:}

  \begin{itemize}
  \tightlist
  \item
    પ્રથમ element (index 0) ને sorted subset તરીકે લો.
  \item
    બાકીના array ને unsorted ભાગ તરીકે ગણો.
  \end{itemize}
\item
  \textbf{Unsorted ભાગ પર પુનરાવર્તન કરો:}

  \begin{itemize}
  \tightlist
  \item
    Index 1 થી n-1 સુધીના દરેક element માટે (જ્યાં n array ની લંબાઈ છે):

    \begin{itemize}
    \tightlist
    \item
      વર્તમાન element ને key તરીકે સંગ્રહિત કરો.
    \item
      j ને અગાઉના element ના index તરીકે initialize કરો.
    \end{itemize}
  \end{itemize}
\item
  \textbf{સરખામણી કરો અને ખસેડો:}

  \begin{itemize}
  \tightlist
  \item
    જ્યાં સુધી j ≥ 0 હોય અને index j પરનું element key કરતાં મોટું હોય:

    \begin{itemize}
    \tightlist
    \item
      Index j પરના element ને એક સ્થાન જમણી તરફ ખસેડો.
    \item
      j ને ઘટાડો.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Key ને દાખલ કરો:}

  \begin{itemize}
  \tightlist
  \item
    Key ને index j+1 પર મૂકો.
  \end{itemize}
\item
  \textbf{પુનરાવર્તન કરો:}

  \begin{itemize}
  \tightlist
  \item
    બધા elements sorted ન થાય ત્યાં સુધી પગલાં 2-4 ચાલુ રાખો.
  \end{itemize}
\end{enumerate}

અહીં Insertion sort અલગોરિધમનું દૃશ્યમાન રજૂઆત આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B[પ્રારંભ: પ્રથમ element ને sorted માનો]}
\NormalTok{    B {-}{-}\textgreater{} C[Unsorted ભાગ પર પુનરાવર્તન]}
\NormalTok{    C {-}{-}\textgreater{} D[વર્તમાન element ને key તરીકે સંગ્રહો]}
\NormalTok{    D {-}{-}\textgreater{} E[Key ની sorted ભાગ સાથે સરખામણી કરો]}
\NormalTok{    E {-}{-}\textgreater{} F\{શું અગાઉનો element \textgreater{} key?\}}
\NormalTok{    F {-}{-}\textgreater{}|હા| G[Element ને જમણે ખસેડો]}
\NormalTok{    G {-}{-}\textgreater{} E}
\NormalTok{    F {-}{-}\textgreater{}|ના| H[Key ને યોગ્ય સ્થાને દાખલ કરો]}
\NormalTok{    H {-}{-}\textgreater{} I\{વધુ unsorted elements?\}}
\NormalTok{    I {-}{-}\textgreater{}|હા| C}
\NormalTok{    I {-}{-}\textgreater{}|ના| J[અંત]}
\end{Highlighting}
\end{Shaded}

Insertion sort નું Python implementation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ insertion\_sort(arr):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(arr)):}
\NormalTok{        key }\OperatorTok{=}\NormalTok{ arr[i]}
\NormalTok{        j }\OperatorTok{=}\NormalTok{ i }\OperatorTok{{-}} \DecValTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textgreater{}=} \DecValTok{0} \KeywordTok{and}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ key:}
\NormalTok{            arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j]}
\NormalTok{            j }\OperatorTok{{-}=} \DecValTok{1}
\NormalTok{        arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ key}
    \ControlFlowTok{return}\NormalTok{ arr}
\end{Highlighting}
\end{Shaded}

\textbf{Time Complexity:} - શ્રેષ્ઠ કેસ: O(n) જ્યારે array પહેલેથી જ sorted હોય
- સરેરાશ અને ખરાબમાં ખરાબ કેસ: O(n\^{}2)

\textbf{Space Complexity:} O(1) કારણ કે તે in-place sort કરે છે

Insertion sort નાના data sets અને લગભગ-sorted arrays માટે કાર્યક્ષમ છે. તે
સ્થિર છે અને online algorithm તરીકે સારી રીતે કામ કરે છે, જ્યાં નવા elements ને
array માં કાર્યક્ષમ રીતે ઉમેરી શકાય છે.

\hypertarget{question-4c-or-develop-a-python-code-to-sort-following-list-in-ascending-order-using-selection-sort-method.-list163258-1550-07-marks}{%
\subsubsection{Question 4(c) OR: Develop a python code to sort following
list in ascending order using selection sort method.
list1={[}6,3,25,8,-1,55,0{]} (07
marks)}\label{question-4c-or-develop-a-python-code-to-sort-following-list-in-ascending-order-using-selection-sort-method.-list163258-1550-07-marks}}

\textbf{Ans 4(c)OR:}

Selection sort is a simple comparison-based sorting algorithm. Here's a
Python implementation to sort the given list using the selection sort
method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ selection\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# Find the minimum element in the unsorted portion}
\NormalTok{        min\_idx }\OperatorTok{=}\NormalTok{ i}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i }\OperatorTok{+} \DecValTok{1}\NormalTok{, n):}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textless{}}\NormalTok{ arr[min\_idx]:}
\NormalTok{                min\_idx }\OperatorTok{=}\NormalTok{ j}
        
        \CommentTok{\# Swap the found minimum element with the first element of the unsorted portion}
\NormalTok{        arr[i], arr[min\_idx] }\OperatorTok{=}\NormalTok{ arr[min\_idx], arr[i]}
    
    \ControlFlowTok{return}\NormalTok{ arr}

\CommentTok{\# Given list}
\NormalTok{list1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{8}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{0}\NormalTok{]}

\CommentTok{\# Sort the list}
\NormalTok{sorted\_list }\OperatorTok{=}\NormalTok{ selection\_sort(list1)}

\CommentTok{\# Print the sorted list}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sorted list:"}\NormalTok{, sorted\_list)}
\end{Highlighting}
\end{Shaded}

Let's break down the algorithm and explain its working:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Function Definition:}

  \begin{itemize}
  \tightlist
  \item
    We define a function \texttt{selection\_sort} that takes an array
    (or list) as input.
  \end{itemize}
\item
  \textbf{Outer Loop:}

  \begin{itemize}
  \tightlist
  \item
    The outer loop runs from 0 to n-1, where n is the length of the
    list.
  \item
    In each iteration, it considers the current index i as the start of
    the unsorted portion.
  \end{itemize}
\item
  \textbf{Inner Loop:}

  \begin{itemize}
  \tightlist
  \item
    The inner loop finds the minimum element in the unsorted portion
    (from i to n-1).
  \item
    It keeps track of the index of the minimum element found.
  \end{itemize}
\item
  \textbf{Swapping:}

  \begin{itemize}
  \tightlist
  \item
    After finding the minimum element, it swaps it with the first
    element of the unsorted portion.
  \end{itemize}
\item
  \textbf{Repeat:}

  \begin{itemize}
  \tightlist
  \item
    This process repeats until the entire list is sorted.
  \end{itemize}
\end{enumerate}

Here's a visualization of how the algorithm works on the given list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B["Initialize list1 = [6, 3, 25, 8, {-}1, 55, 0]"]}
\NormalTok{    B {-}{-}\textgreater{} C[Iteration 1: Find min, swap {-}1 with 6]}
\NormalTok{    C {-}{-}\textgreater{} D[[{-}1, 3, 25, 8, 6, 55, 0]]}
\NormalTok{    D {-}{-}\textgreater{} E[Iteration 2: Find min, swap 0 with 3]}
\NormalTok{    E {-}{-}\textgreater{} F[[{-}1, 0, 25, 8, 6, 55, 3]]}
\NormalTok{    F {-}{-}\textgreater{} G[Iteration 3: Find min, swap 3 with 25]}
\NormalTok{    G {-}{-}\textgreater{} H[[{-}1, 0, 3, 8, 6, 55, 25]]}
\NormalTok{    H {-}{-}\textgreater{} I[Iteration 4: Find min, swap 6 with 8]}
\NormalTok{    I {-}{-}\textgreater{} J[[{-}1, 0, 3, 6, 8, 55, 25]]}
\NormalTok{    J {-}{-}\textgreater{} K[Iteration 5: No swap needed]}
\NormalTok{    K {-}{-}\textgreater{} L[Iteration 6: Swap 25 with 55]}
\NormalTok{    L {-}{-}\textgreater{} M[[{-}1, 0, 3, 6, 8, 25, 55]]}
\NormalTok{    M {-}{-}\textgreater{} N[Iteration 7: No swap needed]}
\NormalTok{    N {-}{-}\textgreater{} O["End: Sorted list [{-}1, 0, 3, 6, 8, 25, 55]"]}
\end{Highlighting}
\end{Shaded}

\textbf{Time Complexity:} O(n\^{}2) for all cases (best, average, and
worst) \textbf{Space Complexity:} O(1) as it sorts in-place

This implementation efficiently sorts the given list in ascending order
using the selection sort method.

\hypertarget{uxaaauxab0uxab6uxaa8-4uxa95-or-uxaa8uxa9a-uxa86uxaaauxab2-uxab2uxab8uxa9f-uxaa8-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab5uxaa1-uxa9auxaa1uxaa4-uxa95uxab0uxaaeuxaae-uxa97uxaa0uxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-list163258-1550-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 4(ક) OR: નીચે આપેલા લીસ્ટ ને સિલેકશન સોર્ટ મેથડ વડે ચડતા
ક્રમમાં ગોઠવવા માટેનો પાયથન કોડ વિકસાવો. list1={[}6,3,25,8,-1,55,0{]} (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-uxaa8uxa9a-uxa86uxaaauxab2-uxab2uxab8uxa9f-uxaa8-uxab8uxab2uxa95uxab6uxaa8-uxab8uxab0uxa9f-uxaaeuxaa5uxaa1-uxab5uxaa1-uxa9auxaa1uxaa4-uxa95uxab0uxaaeuxaae-uxa97uxaa0uxab5uxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-list163258-1550-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 4(ક)OR:}

Selection sort એ એક સરળ તુલના-આધારિત sorting અલગોરિધમ છે. અહીં આપેલી list ને
selection sort method નો ઉપયોગ કરીને ગોઠવવા માટેનું Python implementation
આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ selection\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \CommentTok{\# અસોર્ટેડ ભાગમાં લઘુત્તમ element શોધો}
\NormalTok{        min\_idx }\OperatorTok{=}\NormalTok{ i}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i }\OperatorTok{+} \DecValTok{1}\NormalTok{, n):}
            \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textless{}}\NormalTok{ arr[min\_idx]:}
\NormalTok{                min\_idx }\OperatorTok{=}\NormalTok{ j}
        
        \CommentTok{\# મળેલા લઘુત્તમ element ને અસોર્ટેડ ભાગના પ્રથમ element સાથે બદલો}
\NormalTok{        arr[i], arr[min\_idx] }\OperatorTok{=}\NormalTok{ arr[min\_idx], arr[i]}
    
    \ControlFlowTok{return}\NormalTok{ arr}

\CommentTok{\# આપેલી list}
\NormalTok{list1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{8}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{0}\NormalTok{]}

\CommentTok{\# list ને સોર્ટ કરો}
\NormalTok{sorted\_list }\OperatorTok{=}\NormalTok{ selection\_sort(list1)}

\CommentTok{\# સોર્ટ કરેલી list પ્રિન્ટ કરો}
\BuiltInTok{print}\NormalTok{(}\StringTok{"સોર્ટ કરેલી list:"}\NormalTok{, sorted\_list)}
\end{Highlighting}
\end{Shaded}

ચાલો અલગોરિધમને તોડીએ અને તેની કાર્યપ્રણાલી સમજાવીએ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{ફંક્શન વ્યાખ્યા:}

  \begin{itemize}
  \tightlist
  \item
    અમે \texttt{selection\_sort} નામનું ફંક્શન વ્યાખ્યાયિત કરીએ છીએ જે array
    (અથવા list) ને input તરીકે લે છે.
  \end{itemize}
\item
  \textbf{બાહ્ય લૂપ:}

  \begin{itemize}
  \tightlist
  \item
    બાહ્ય લૂપ 0 થી n-1 સુધી ચાલે છે, જ્યાં n list ની લંબાઈ છે.
  \item
    દરેક પુનરાવર્તનમાં, તે વર્તમાન index i ને unsorted ભાગની શરૂઆત તરીકે ગણે છે.
  \end{itemize}
\item
  \textbf{આંતરિક લૂપ:}

  \begin{itemize}
  \tightlist
  \item
    આંતરિક લૂપ unsorted ભાગમાં (i થી n-1 સુધી) લઘુત્તમ element શોધે છે.
  \item
    તે મળેલા લઘુત્તમ element ના index ને ટ્રૅક કરે છે.
  \end{itemize}
\item
  \textbf{બદલી:}

  \begin{itemize}
  \tightlist
  \item
    લઘુત્તમ element શોધ્યા પછી, તેને unsorted ભાગના પ્રથમ element સાથે બદલે છે.
  \end{itemize}
\item
  \textbf{પુનરાવર્તન:}

  \begin{itemize}
  \tightlist
  \item
    આ પ્રક્રિયા સમગ્ર list સોર્ટ ન થાય ત્યાં સુધી પુનરાવર્તિત થાય છે.
  \end{itemize}
\end{enumerate}

અહીં આપેલી list પર અલગોરિધમ કેવી રીતે કામ કરે છે તેનું visualization આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂઆત] {-}{-}\textgreater{} B["list1 = [6, 3, 25, 8, {-}1, 55, 0] પ્રારંભ કરો"]}
\NormalTok{    B {-}{-}\textgreater{} C[પુનરાવર્તન 1: લઘુત્તમ શોધો, {-}1 ને 6 સાથે બદલો]}
\NormalTok{    C {-}{-}\textgreater{} D[[{-}1, 3, 25, 8, 6, 55, 0]]}
\NormalTok{    D {-}{-}\textgreater{} E[પુનરાવર્તન 2: લઘુત્તમ શોધો, 0 ને 3 સાથે બદલો]}
\NormalTok{    E {-}{-}\textgreater{} F[[{-}1, 0, 25, 8, 6, 55, 3]]}
\NormalTok{    F {-}{-}\textgreater{} G[પુનરાવર્તન 3: લઘુત્તમ શોધો, 3 ને 25 સાથે બદલો]}
\NormalTok{    G {-}{-}\textgreater{} H[[{-}1, 0, 3, 8, 6, 55, 25]]}
\NormalTok{    H {-}{-}\textgreater{} I[પુનરાવર્તન 4: લઘુત્તમ શોધો, 6 ને 8 સાથે બદલો]}
\NormalTok{    I {-}{-}\textgreater{} J[[{-}1, 0, 3, 6, 8, 55, 25]]}
\NormalTok{    J {-}{-}\textgreater{} K[પુનરાવર્તન 5: કોઈ બદલી જરૂરી નથી]}
\NormalTok{    K {-}{-}\textgreater{} L[પુનરાવર્તન 6: 25 ને 55 સાથે બદલો]}
\NormalTok{    L {-}{-}\textgreater{} M[[{-}1, 0, 3, 6, 8, 25, 55]]}
\NormalTok{    M {-}{-}\textgreater{} N[પુનરાવર્તન 7: કોઈ બદલી જરૂરી નથી]}
\NormalTok{    N {-}{-}\textgreater{} O["અંત: સોર્ટ કરેલી list [{-}1, 0, 3, 6, 8, 25, 55]"]}
\end{Highlighting}
\end{Shaded}

\textbf{Time Complexity:} બધા કેસ માટે O(n\^{}2) (શ્રેષ્ઠ, સરેરાશ, અને ખરાબમાં
ખરાબ) \textbf{Space Complexity:} O(1) કારણ કે તે in-place sort કરે છે

આ implementation આપેલી list ને selection sort method નો ઉપયોગ કરીને કાર્યક્ષમ
રીતે ચડતા ક્રમમાં ગોઠવે છે.

\hypertarget{question-5a-define-following-terms-regarding-tree-data-structure-1.-forest-2.-root-node-3.-leaf-node-03-marks}{%
\subsubsection{Question 5(a): Define following terms regarding Tree data
structure: 1. Forest 2. Root node 3. Leaf node (03
marks)}\label{question-5a-define-following-terms-regarding-tree-data-structure-1.-forest-2.-root-node-3.-leaf-node-03-marks}}

\textbf{Ans 5(a):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Forest:}

  \begin{itemize}
  \tightlist
  \item
    A forest is a collection of disjoint trees.
  \item
    It consists of multiple trees that are not connected to each other.
  \item
    Each tree in a forest has its own root node.
  \end{itemize}
\item
  \textbf{Root Node:}

  \begin{itemize}
  \tightlist
  \item
    The root node is the topmost node in a tree structure.
  \item
    It is the first node of the tree and has no parent.
  \item
    All other nodes in the tree are descendants of the root node.
  \end{itemize}
\item
  \textbf{Leaf Node:}

  \begin{itemize}
  \tightlist
  \item
    A leaf node is a node in a tree that has no children.
  \item
    It is also known as an external node or terminal node.
  \item
    Leaf nodes are the endpoints of the tree structure.
  \end{itemize}
\end{enumerate}

Here's a visual representation of these concepts:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    subgraph "Forest"}
\NormalTok{    A[Root] {-}{-}\textgreater{} B[Child]}
\NormalTok{    A {-}{-}\textgreater{} C[Child]}
\NormalTok{    B {-}{-}\textgreater{} D[Leaf]}
\NormalTok{    B {-}{-}\textgreater{} E[Leaf]}
\NormalTok{    C {-}{-}\textgreater{} F[Leaf]}
    
\NormalTok{    G[Root] {-}{-}\textgreater{} H[Child]}
\NormalTok{    H {-}{-}\textgreater{} I[Leaf]}
\NormalTok{    H {-}{-}\textgreater{} J[Leaf]}
    
\NormalTok{    K[Root] {-}{-}\textgreater{} L[Leaf]}
\NormalTok{    K {-}{-}\textgreater{} M[Leaf]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

In this diagram: - The entire structure represents a forest with three
separate trees. - Nodes A, G, and K are root nodes of their respective
trees. - Nodes D, E, F, I, J, L, and M are leaf nodes as they have no
children.

\hypertarget{uxaaauxab0uxab6uxaa8-5uxa85-tree-data-structure-uxaa8-uxab2uxa97uxaa4-uxaa8uxa9a-uxa86uxaaauxab2-uxaaauxaa6uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-1.-forest-2.-root-node-3.-leaf-node-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(અ): Tree data structure ને લગતા નીચે આપેલ પદોની
વ્યાખ્યા આપો. 1. Forest 2. Root node 3. Leaf node (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxa85-tree-data-structure-uxaa8-uxab2uxa97uxaa4-uxaa8uxa9a-uxa86uxaaauxab2-uxaaauxaa6uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-1.-forest-2.-root-node-3.-leaf-node-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 5(અ):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Forest:}

  \begin{itemize}
  \tightlist
  \item
    Forest એ અલગ-અલગ trees નો સમૂહ છે.
  \item
    તેમાં એકબીજા સાથે જોડાયેલા ન હોય તેવા અનેક trees હોય છે.
  \item
    Forest માંના દરેક tree ને તેનો પોતાનો root node હોય છે.
  \end{itemize}
\item
  \textbf{Root Node:}

  \begin{itemize}
  \tightlist
  \item
    Root node એ tree structure માં સૌથી ઉપરનો node છે.
  \item
    તે tree નો પ્રથમ node છે અને તેને કોઈ parent હોતું નથી.
  \item
    Tree ના બાકીના બધા nodes root node ના વંશજો છે.
  \end{itemize}
\item
  \textbf{Leaf Node:}

  \begin{itemize}
  \tightlist
  \item
    Leaf node એ tree માંનો એવો node છે જેને કોઈ children નથી હોતા.
  \item
    તેને external node અથવા terminal node તરીકે પણ ઓળખવામાં આવે છે.
  \item
    Leaf nodes એ tree structure ના અંતિમ બિંદુઓ છે.
  \end{itemize}
\end{enumerate}

આ concepts નું દૃશ્યમાન રજૂઆત અહીં આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    subgraph "Forest"}
\NormalTok{    A[Root] {-}{-}\textgreater{} B[Child]}
\NormalTok{    A {-}{-}\textgreater{} C[Child]}
\NormalTok{    B {-}{-}\textgreater{} D[Leaf]}
\NormalTok{    B {-}{-}\textgreater{} E[Leaf]}
\NormalTok{    C {-}{-}\textgreater{} F[Leaf]}
    
\NormalTok{    G[Root] {-}{-}\textgreater{} H[Child]}
\NormalTok{    H {-}{-}\textgreater{} I[Leaf]}
\NormalTok{    H {-}{-}\textgreater{} J[Leaf]}
    
\NormalTok{    K[Root] {-}{-}\textgreater{} L[Leaf]}
\NormalTok{    K {-}{-}\textgreater{} M[Leaf]}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

આ આકૃતિમાં: - સમગ્ર માળખું ત્રણ અલગ trees વાળા forest નું પ્રતિનિધિત્વ કરે છે. - A,
G, અને K nodes તેમના સંબંધિત trees ના root nodes છે. - D, E, F, I, J, L, અને M
nodes leaf nodes છે કારણ કે તેમને કોઈ children નથી.

\hypertarget{question-5b-draw-binary-search-tree-for-78588215668099-and-write-in-order-traversal-for-the-tree.-04-marks}{%
\subsubsection{Question 5(b): Draw Binary search tree for
78,58,82,15,66,80,99 and write In-order traversal for the tree. (04
marks)}\label{question-5b-draw-binary-search-tree-for-78588215668099-and-write-in-order-traversal-for-the-tree.-04-marks}}

\textbf{Ans 5(b):}

Let's construct a Binary Search Tree (BST) using the given numbers: 78,
58, 82, 15, 66, 80, 99

Here's the Binary Search Tree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[78] {-}{-}\textgreater{} B[58]}
\NormalTok{    A {-}{-}\textgreater{} C[82]}
\NormalTok{    B {-}{-}\textgreater{} D[15]}
\NormalTok{    B {-}{-}\textgreater{} E[66]}
\NormalTok{    C {-}{-}\textgreater{} F[80]}
\NormalTok{    C {-}{-}\textgreater{} G[99]}
\end{Highlighting}
\end{Shaded}

Explanation of the BST construction: 1. 78 is the root node. 2. 58 is
less than 78, so it goes to the left. 3. 82 is greater than 78, so it
goes to the right. 4. 15 is less than 78 and 58, so it goes to the left
of 58. 5. 66 is less than 78 but greater than 58, so it goes to the
right of 58. 6. 80 is greater than 78 but less than 82, so it goes to
the left of 82. 7. 99 is greater than 78 and 82, so it goes to the right
of 82.

\textbf{In-order Traversal:}

The in-order traversal of a binary tree visits the left subtree, then
the root, and finally the right subtree. For a BST, this results in
visiting the nodes in ascending order.

The in-order traversal for this BST is:

15, 58, 66, 78, 80, 82, 99

Steps for in-order traversal: 1. Visit the left subtree of 78: (15, 58,
66) 2. Visit 78 3. Visit the right subtree of 78: (80, 82, 99)

This traversal gives us the elements of the BST in sorted (ascending)
order.

\hypertarget{uxaaauxab0uxab6uxaa8-5uxaac-78588215668099-uxaaeuxa9f-binary-search-tree-uxaa6uxab0-uxa85uxaa8-uxaa4-tree-uxaaeuxa9fuxaa8-in-order-traversal-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(બ): 78,58,82,15,66,80,99 માટે Binary search tree
દોરો અને તે tree માટેનું In-order traversal લખો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxaac-78588215668099-uxaaeuxa9f-binary-search-tree-uxaa6uxab0-uxa85uxaa8-uxaa4-tree-uxaaeuxa9fuxaa8-in-order-traversal-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 5(બ):}

ચાલો આપેલા નંબરો: 78, 58, 82, 15, 66, 80, 99 નો ઉપયોગ કરીને Binary Search
Tree (BST) બનાવીએ

અહીં Binary Search Tree આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[78] {-}{-}\textgreater{} B[58]}
\NormalTok{    A {-}{-}\textgreater{} C[82]}
\NormalTok{    B {-}{-}\textgreater{} D[15]}
\NormalTok{    B {-}{-}\textgreater{} E[66]}
\NormalTok{    C {-}{-}\textgreater{} F[80]}
\NormalTok{    C {-}{-}\textgreater{} G[99]}
\end{Highlighting}
\end{Shaded}

BST રચનાનું સ્પષ્ટીકરણ: 1. 78 root node છે. 2. 58, 78 કરતા ઓછું છે, તેથી તે ડાબી
બાજુ જાય છે. 3. 82, 78 કરતા વધારે છે, તેથી તે જમણી બાજુ જાય છે. 4. 15, 78 અને 58
કરતા ઓછું છે, તેથી તે 58 ની ડાબી બાજુ જાય છે. 5. 66, 78 કરતા ઓછું પણ 58 કરતા વધારે
છે, તેથી તે 58 ની જમણી બાજુ જાય છે. 6. 80, 78 કરતા વધારે પણ 82 કરતા ઓછું છે, તેથી
તે 82 ની ડાબી બાજુ જાય છે. 7. 99, 78 અને 82 કરતા વધારે છે, તેથી તે 82 ની જમણી
બાજુ જાય છે.

\textbf{In-order Traversal:}

Binary tree નું in-order traversal પ્રથમ ડાબા subtree ને, પછી root ને, અને અંતે
જમણા subtree ને મુલાકાત લે છે. BST માટે, આનાથી nodes ની મુલાકાત ચઢતા ક્રમમાં થાય
છે.

આ BST માટે in-order traversal આ મુજબ છે:

15, 58, 66, 78, 80, 82, 99

In-order traversal માટેના પગલાં: 1. 78 ના ડાબા subtree ની મુલાકાત લો: (15,
58, 66) 2. 78 ની મુલાકાત લો 3. 78 ના જમણા subtree ની મુલાકાત લો: (80, 82,
99)

આ traversal આપણને BST ના elements ને સોર્ટેડ (ચઢતા) ક્રમમાં આપે છે.

\hypertarget{question-5c-write-an-algorithm-for-following-operations-1.-insertion-of-node-in-binary-tree-2.-deletion-of-node-in-binary-tree-07-marks}{%
\subsubsection{Question 5(c): Write an algorithm for following
operations: 1. Insertion of Node in Binary Tree 2. Deletion of Node in
Binary Tree (07
marks)}\label{question-5c-write-an-algorithm-for-following-operations-1.-insertion-of-node-in-binary-tree-2.-deletion-of-node-in-binary-tree-07-marks}}

\textbf{Ans 5(c):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Insertion of Node in Binary Tree:}
\end{enumerate}

Algorithm: 1. Start at the root of the tree. 2. If the tree is empty,
create a new node as the root and return. 3. Create a queue and enqueue
the root node. 4. While the queue is not empty: a. Dequeue a node from
the front of the queue. b. If the left child of the node is null: -
Create a new node and set it as the left child. - Return as insertion is
complete. c.~Else, enqueue the left child. d.~If the right child of the
node is null: - Create a new node and set it as the right child. -
Return as insertion is complete. e. Else, enqueue the right child. 5.
Repeat step 4 until a vacant position is found.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B\{Is tree empty?\}}
\NormalTok{    B {-}{-}\textgreater{}|Yes| C[Create root node]}
\NormalTok{    B {-}{-}\textgreater{}|No| D[Create queue, enqueue root]}
\NormalTok{    D {-}{-}\textgreater{} E\{Is queue empty?\}}
\NormalTok{    E {-}{-}\textgreater{}|No| F[Dequeue node]}
\NormalTok{    F {-}{-}\textgreater{} G\{Left child null?\}}
\NormalTok{    G {-}{-}\textgreater{}|Yes| H[Insert as left child]}
\NormalTok{    G {-}{-}\textgreater{}|No| I[Enqueue left child]}
\NormalTok{    I {-}{-}\textgreater{} J\{Right child null?\}}
\NormalTok{    J {-}{-}\textgreater{}|Yes| K[Insert as right child]}
\NormalTok{    J {-}{-}\textgreater{}|No| L[Enqueue right child]}
\NormalTok{    L {-}{-}\textgreater{} E}
\NormalTok{    E {-}{-}\textgreater{}|Yes| M[End]}
\NormalTok{    H {-}{-}\textgreater{} M}
\NormalTok{    K {-}{-}\textgreater{} M}
\NormalTok{    C {-}{-}\textgreater{} M}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Deletion of Node in Binary Tree:}
\end{enumerate}

Algorithm: 1. Start at the root of the tree. 2. If the tree is empty,
return. 3. Create a queue and enqueue the root node. 4. While the queue
is not empty: a. Dequeue a node from the front of the queue. b. If this
is the node to be deleted: - Find the deepest rightmost node in the
tree. - Replace the node to be deleted with the deepest rightmost node.
- Delete the deepest rightmost node. - Return as deletion is complete.
c.~If the node has a left child, enqueue it. d.~If the node has a right
child, enqueue it. 5. If the node to be deleted is not found, return
(node not in the tree).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Start] {-}{-}\textgreater{} B\{Is tree empty?\}}
\NormalTok{    B {-}{-}\textgreater{}|Yes| C[Return]}
\NormalTok{    B {-}{-}\textgreater{}|No| D[Create queue, enqueue root]}
\NormalTok{    D {-}{-}\textgreater{} E\{Is queue empty?\}}
\NormalTok{    E {-}{-}\textgreater{}|No| F[Dequeue node]}
\NormalTok{    F {-}{-}\textgreater{} G\{Is this the node to delete?\}}
\NormalTok{    G {-}{-}\textgreater{}|Yes| H[Find deepest rightmost node]}
\NormalTok{    H {-}{-}\textgreater{} I[Replace node with deepest rightmost]}
\NormalTok{    I {-}{-}\textgreater{} J[Delete deepest rightmost]}
\NormalTok{    G {-}{-}\textgreater{}|No| K\{Has left child?\}}
\NormalTok{    K {-}{-}\textgreater{}|Yes| L[Enqueue left child]}
\NormalTok{    K {-}{-}\textgreater{}|No| M\{Has right child?\}}
\NormalTok{    M {-}{-}\textgreater{}|Yes| N[Enqueue right child]}
\NormalTok{    M {-}{-}\textgreater{}|No| E}
\NormalTok{    L {-}{-}\textgreater{} M}
\NormalTok{    N {-}{-}\textgreater{} E}
\NormalTok{    E {-}{-}\textgreater{}|Yes| O[Node not found, return]}
\NormalTok{    J {-}{-}\textgreater{} P[End]}
\NormalTok{    C {-}{-}\textgreater{} P}
\NormalTok{    O {-}{-}\textgreater{} P}
\end{Highlighting}
\end{Shaded}

These algorithms provide a general approach for insertion and deletion
in a binary tree. Note that for a Binary Search Tree (BST), the
algorithms would be different to maintain the BST property.

\hypertarget{uxaaauxab0uxab6uxaa8-5uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96-uxae7.-binary-tree-uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5-uxae8.-binary-tree-uxaaeuxaa5-uxaa8uxaa1-uxa95uxaa2uxab5-uxaaeuxa9f-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(ક): નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો: ૧. Binary Tree
માં નોડ દાખલ કરવા ૨. Binary Tree માંથી નોડ કાઢવા માટે (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxa95-uxaa8uxa9a-uxa86uxaaauxab2-uxa93uxaaauxab0uxab6uxaa8-uxaaeuxa9f-uxa85uxab2uxa97uxab0uxaa7uxaae-uxab2uxa96-uxae7.-binary-tree-uxaae-uxaa8uxaa1-uxaa6uxa96uxab2-uxa95uxab0uxab5-uxae8.-binary-tree-uxaaeuxaa5-uxaa8uxaa1-uxa95uxaa2uxab5-uxaaeuxa9f-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 5(ક):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Binary Tree માં નોડ દાખલ કરવા:}
\end{enumerate}

અલગોરિધમ: 1. Tree ના root થી શરૂ કરો. 2. જો tree ખાલી હોય, તો નવો node
બનાવીને તેને root તરીકે સેટ કરો અને પરત ફરો. 3. એક queue બનાવો અને તેમાં root
node ને enqueue કરો. 4. જ્યાં સુધી queue ખાલી ન થાય ત્યાં સુધી: a. Queue ની
આગળથી એક node ને dequeue કરો. b. જો node નો left child null હોય: - નવો
node બનાવો અને તેને left child તરીકે સેટ કરો. - દાખલ કરવાનું પૂર્ણ થયું છે, તેથી પરત
ફરો. c.~અન્યથા, left child ને enqueue કરો. d.~જો node નો right child null
હોય: - નવો node બનાવો અને તેને right child તરીકે સેટ કરો. - દાખલ કરવાનું પૂર્ણ થયું
છે, તેથી પરત ફરો. e. અન્યથા, right child ને enqueue કરો. 5. જ્યાં સુધી ખાલી
સ્થાન ન મળે ત્યાં સુધી પગલું 4 પુનરાવર્તિત કરો.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂ] {-}{-}\textgreater{} B\{શું tree ખાલી છે?\}}
\NormalTok{    B {-}{-}\textgreater{}|હા| C[Root node બનાવો]}
\NormalTok{    B {-}{-}\textgreater{}|ના| D[Queue બનાવો, root ને enqueue કરો]}
\NormalTok{    D {-}{-}\textgreater{} E\{શું queue ખાલી છે?\}}
\NormalTok{    E {-}{-}\textgreater{}|ના| F[Node ને dequeue કરો]}
\NormalTok{    F {-}{-}\textgreater{} G\{શું left child null છે?\}}
\NormalTok{    G {-}{-}\textgreater{}|હા| H[Left child તરીકે દાખલ કરો]}
\NormalTok{    G {-}{-}\textgreater{}|ના| I[Left child ને enqueue કરો]}
\NormalTok{    I {-}{-}\textgreater{} J\{શું right child null છે?\}}
\NormalTok{    J {-}{-}\textgreater{}|હા| K[Right child તરીકે દાખલ કરો]}
\NormalTok{    J {-}{-}\textgreater{}|ના| L[Right child ને enqueue કરો]}
\NormalTok{    L {-}{-}\textgreater{} E}
\NormalTok{    E {-}{-}\textgreater{}|હા| M[અંત]}
\NormalTok{    H {-}{-}\textgreater{} M}
\NormalTok{    K {-}{-}\textgreater{} M}
\NormalTok{    C {-}{-}\textgreater{} M}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Binary Tree માંથી નોડ કાઢવા માટે:}
\end{enumerate}

અલગોરિધમ: 1. Tree ના root થી શરૂ કરો. 2. જો tree ખાલી હોય, તો પરત ફરો. 3.
એક queue બનાવો અને તેમાં root node ને enqueue કરો. 4. જ્યાં સુધી queue ખાલી ન
થાય ત્યાં સુધી: a. Queue ની આગળથી એક node ને dequeue કરો. b. જો આ કાઢવાનો
node હોય: - Tree માં સૌથી ઊંડા જમણા છેડાનો node શોધો. - કાઢવાના node ને સૌથી
ઊંડા જમણા છેડાના node સાથે બદલો. - સૌથી ઊંડા જમણા છેડાનો node કાઢી નાખો. -
કાઢવાનું પૂર્ણ થયું છે, તેથી પરત ફરો. c.~જો node ને left child હોય, તો તેને enqueue
કરો. d.~જો node ને right child હોય, તો તેને enqueue કરો. 5. જો કાઢવાનો node
ન મળે, તો પરત ફરો (node tree માં નથી).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[શરૂ] {-}{-}\textgreater{} B\{શું tree ખાલી છે?\}}
\NormalTok{    B {-}{-}\textgreater{}|હા| C[પરત ફરો]}
\NormalTok{    B {-}{-}\textgreater{}|ના| D[Queue બનાવો, root ને enqueue કરો]}
\NormalTok{    D {-}{-}\textgreater{} E\{શું queue ખાલી છે?\}}
\NormalTok{    E {-}{-}\textgreater{}|ના| F[Node ને dequeue કરો]}
\NormalTok{    F {-}{-}\textgreater{} G\{શું આ કાઢવાનો node છે?\}}
\NormalTok{    G {-}{-}\textgreater{}|હા| H[સૌથી ઊંડો જમણો છેડાનો node શોધો]}
\NormalTok{    H {-}{-}\textgreater{} I[Node ને સૌથી ઊંડા જમણા છેડાના node સાથે બદલો]}
\NormalTok{    I {-}{-}\textgreater{} J[સૌથી ઊંડો જમણો છેડાનો node કાઢી નાખો]}
\NormalTok{    G {-}{-}\textgreater{}|ના| K\{શું left child છે?\}}
\NormalTok{    K {-}{-}\textgreater{}|હા| L[Left child ને enqueue કરો]}
\NormalTok{    K {-}{-}\textgreater{}|ના| M\{શું right child છે?\}}
\NormalTok{    M {-}{-}\textgreater{}|હા| N[Right child ને enqueue કરો]}
\NormalTok{    M {-}{-}\textgreater{}|ના| E}
\NormalTok{    L {-}{-}\textgreater{} M}
\NormalTok{    N {-}{-}\textgreater{} E}
\NormalTok{    E {-}{-}\textgreater{}|હા| O[Node મળ્યો નથી, પરત ફરો]}
\NormalTok{    J {-}{-}\textgreater{} P[અંત]}
\NormalTok{    C {-}{-}\textgreater{} P}
\NormalTok{    O {-}{-}\textgreater{} P}
\end{Highlighting}
\end{Shaded}

આ અલગોરિધમ્સ binary tree માં દાખલ કરવા અને કાઢવા માટેનો સામાન્ય અભિગમ પ્રદાન
કરે છે. નોંધ કરો કે Binary Search Tree (BST) માટે, BST ની વિશેષતા જાળવવા માટે
અલગોરિધમ્સ અલગ હશે.

\hypertarget{question-5a-or-define-following-terms-regarding-tree-data-structure-1.-in-degree-2.-out-degree-3.-depth-03-marks}{%
\subsubsection{Question 5(a) OR: Define following terms regarding Tree
data structure: 1. In-degree 2. Out-degree 3. Depth (03
marks)}\label{question-5a-or-define-following-terms-regarding-tree-data-structure-1.-in-degree-2.-out-degree-3.-depth-03-marks}}

\textbf{Ans 5(a)OR:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{In-degree:}

  \begin{itemize}
  \tightlist
  \item
    In-degree of a node is the number of edges coming into the node.
  \item
    In a tree, every node except the root has an in-degree of 1.
  \item
    The root node has an in-degree of 0.
  \end{itemize}
\item
  \textbf{Out-degree:}

  \begin{itemize}
  \tightlist
  \item
    Out-degree of a node is the number of edges going out from the node.
  \item
    In a binary tree, the maximum out-degree of any node is 2.
  \item
    Leaf nodes have an out-degree of 0.
  \end{itemize}
\item
  \textbf{Depth:}

  \begin{itemize}
  \tightlist
  \item
    Depth of a node is the number of edges in the path from the root to
    that node.
  \item
    The root node has a depth of 0.
  \item
    Depth increases by 1 for each level down the tree.
  \end{itemize}
\end{enumerate}

Here's a visual representation of these concepts:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Root: Depth 0] {-}{-}\textgreater{} B[Child: Depth 1]}
\NormalTok{    A {-}{-}\textgreater{} C[Child: Depth 1]}
\NormalTok{    B {-}{-}\textgreater{} D[Leaf: Depth 2]}
\NormalTok{    B {-}{-}\textgreater{} E[Leaf: Depth 2]}
\NormalTok{    C {-}{-}\textgreater{} F[Leaf: Depth 2]}

\NormalTok{    classDef default fill:\#f9f,stroke:\#333,stroke{-}width:2px;}
\NormalTok{    class A,B,C,D,E,F default;}
\end{Highlighting}
\end{Shaded}

In this diagram: - Node A (Root) has in-degree 0 and out-degree 2 -
Nodes B and C have in-degree 1 and out-degree 2 and 1 respectively -
Nodes D, E, and F (Leaves) have in-degree 1 and out-degree 0 - The depth
increases as we move down the tree

\hypertarget{uxaaauxab0uxab6uxaa8-5uxa85-or-tree-data-structure-uxaa8-uxab2uxa97uxaa4-uxaa8uxa9a-uxa86uxaaauxab2-uxaaauxaa6uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-1.-in-degree-2.-out-degree-3.-depth-uxae6uxae9-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(અ) OR: Tree data structure ને લગતા નીચે આપેલ પદોની
વ્યાખ્યા આપો. 1. In-degree 2. Out-degree 3. Depth (૦૩
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-tree-data-structure-uxaa8-uxab2uxa97uxaa4-uxaa8uxa9a-uxa86uxaaauxab2-uxaaauxaa6uxaa8-uxab5uxaafuxa96uxaaf-uxa86uxaaa.-1.-in-degree-2.-out-degree-3.-depth-uxae6uxae9-uxa97uxaa3}}

\textbf{જવાબ 5(અ)OR:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{In-degree:}

  \begin{itemize}
  \tightlist
  \item
    Node નો in-degree એ તે node માં આવતા edges ની સંખ્યા છે.
  \item
    Tree માં, root સિવાયના દરેક node નો in-degree 1 હોય છે.
  \item
    Root node નો in-degree 0 હોય છે.
  \end{itemize}
\item
  \textbf{Out-degree:}

  \begin{itemize}
  \tightlist
  \item
    Node નો out-degree એ તે node માંથી નીકળતા edges ની સંખ્યા છે.
  \item
    Binary tree માં, કોઈપણ node નો મહત્તમ out-degree 2 હોય છે.
  \item
    Leaf nodes નો out-degree 0 હોય છે.
  \end{itemize}
\item
  \textbf{Depth:}

  \begin{itemize}
  \tightlist
  \item
    Node ની depth એ root થી તે node સુધીના પાથમાં રહેલા edges ની સંખ્યા છે.
  \item
    Root node ની depth 0 હોય છે.
  \item
    Tree માં દરેક સ્તર નીચે જતાં depth 1 વધે છે.
  \end{itemize}
\end{enumerate}

આ concepts નું દૃશ્યમાન રજૂઆત અહીં આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    A[Root: Depth 0] {-}{-}\textgreater{} B[Child: Depth 1]}
\NormalTok{    A {-}{-}\textgreater{} C[Child: Depth 1]}
\NormalTok{    B {-}{-}\textgreater{} D[Leaf: Depth 2]}
\NormalTok{    B {-}{-}\textgreater{} E[Leaf: Depth 2]}
\NormalTok{    C {-}{-}\textgreater{} F[Leaf: Depth 2]}

\NormalTok{    classDef default fill:\#f9f,stroke:\#333,stroke{-}width:2px;}
\NormalTok{    class A,B,C,D,E,F default;}
\end{Highlighting}
\end{Shaded}

આ આકૃતિમાં: - Node A (Root) નો in-degree 0 અને out-degree 2 છે - Nodes B અને
C નો in-degree 1 અને out-degree અનુક્રમે 2 અને 1 છે - Nodes D, E, અને F
(Leaves) નો in-degree 1 અને out-degree 0 છે - Tree માં નીચે જતાં depth વધે છે

\hypertarget{question-5b-or-write-preorder-and-postorder-traversal-of-the-given-binary-tree.-04-marks}{%
\subsubsection{Question 5(b) OR: Write Preorder and postorder traversal
of the given Binary tree. (04
marks)}\label{question-5b-or-write-preorder-and-postorder-traversal-of-the-given-binary-tree.-04-marks}}

\textbf{Ans 5(b)OR:}

For the given Binary tree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    100((100)) {-}{-}{-} 20((20))}
\NormalTok{    100 {-}{-}{-} 200((200))}
\NormalTok{    20 {-}{-}{-} 10((10))}
\NormalTok{    20 {-}{-}{-} 30((30))}
\NormalTok{    200 {-}{-}{-} 150((150))}
\NormalTok{    200 {-}{-}{-} 300((300))}
    
\NormalTok{    classDef default fill:\#fff,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Preorder Traversal:} In preorder traversal, we visit the root
  node first, then the left subtree, and finally the right subtree.

  The preorder traversal for this binary tree is: 100, 20, 10, 30, 200,
  150, 300

  Steps:

  \begin{itemize}
  \tightlist
  \item
    Visit root (100)
  \item
    Visit left subtree of 100: 20, 10, 30
  \item
    Visit right subtree of 100: 200, 150, 300
  \end{itemize}
\item
  \textbf{Postorder Traversal:} In postorder traversal, we visit the
  left subtree first, then the right subtree, and finally the root node.

  The postorder traversal for this binary tree is: 10, 30, 20, 150, 300,
  200, 100

  Steps:

  \begin{itemize}
  \tightlist
  \item
    Visit left subtree of 100: 10, 30, 20
  \item
    Visit right subtree of 100: 150, 300, 200
  \item
    Visit root (100)
  \end{itemize}
\end{enumerate}

These traversals provide different ways to visit all nodes in the binary
tree, each with its own use cases in various algorithms and
applications.

\hypertarget{uxaaauxab0uxab6uxaa8-5uxaac-or-uxaa8uxa9a-uxaa6uxab0uxab6uxab5uxab2-binary-tree-uxaaeuxa9f-preorder-and-postorder-traversal-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(બ) OR: નીચે દર્શાવેલા Binary tree માટે Preorder and
postorder traversal લખો. (૦૪
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-uxaa8uxa9a-uxaa6uxab0uxab6uxab5uxab2-binary-tree-uxaaeuxa9f-preorder-and-postorder-traversal-uxab2uxa96.-uxae6uxaea-uxa97uxaa3}}

\textbf{જવાબ 5(બ)OR:}

આપેલા Binary tree માટે:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{graph TD}
\NormalTok{    100((100)) {-}{-}{-} 20((20))}
\NormalTok{    100 {-}{-}{-} 200((200))}
\NormalTok{    20 {-}{-}{-} 10((10))}
\NormalTok{    20 {-}{-}{-} 30((30))}
\NormalTok{    200 {-}{-}{-} 150((150))}
\NormalTok{    200 {-}{-}{-} 300((300))}
    
\NormalTok{    classDef default fill:\#fff,stroke:\#000,stroke{-}width:1px;}
\NormalTok{    linkStyle default stroke:\#000,stroke{-}width:1px;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Preorder Traversal:} Preorder traversal માં, આપણે પ્રથમ root node
  ની મુલાકાત લઈએ છીએ, પછી ડાબા subtree ની, અને અંતે જમણા subtree ની.

  આ binary tree માટે preorder traversal આ મુજબ છે: 100, 20, 10, 30, 200,
  150, 300

  પગલાં:

  \begin{itemize}
  \tightlist
  \item
    Root ની મુલાકાત લો (100)
  \item
    100 ના ડાબા subtree ની મુલાકાત લો: 20, 10, 30
  \item
    100 ના જમણા subtree ની મુલાકાત લો: 200, 150, 300
  \end{itemize}
\item
  \textbf{Postorder Traversal:} Postorder traversal માં, આપણે પ્રથમ ડાબા
  subtree ની મુલાકાત લઈએ છીએ, પછી જમણા subtree ની, અને અંતે root node ની.

  આ binary tree માટે postorder traversal આ મુજબ છે: 10, 30, 20, 150, 300,
  200, 100

  પગલાં:

  \begin{itemize}
  \tightlist
  \item
    100 ના ડાબા subtree ની મુલાકાત લો: 10, 30, 20
  \item
    100 ના જમણા subtree ની મુલાકાત લો: 150, 300, 200
  \item
    Root ની મુલાકાત લો (100)
  \end{itemize}
\end{enumerate}

આ traversals binary tree ના બધા nodes ની મુલાકાત લેવા માટે અલગ-અલગ રીતો
પ્રદાન કરે છે, જે વિવિધ algorithms અને applications માં તેમના પોતાના ઉપયોગ કેસ
ધરાવે છે.

\hypertarget{question-5c-or-develop-a-program-to-implement-construction-of-binary-search-tree.-07-marks}{%
\subsubsection{Question 5(c) OR: Develop a program to implement
construction of Binary Search Tree. (07
marks)}\label{question-5c-or-develop-a-program-to-implement-construction-of-binary-search-tree.-07-marks}}

\textbf{Ans 5(c)OR:}

Here's a Python program that implements the construction of a Binary
Search Tree (BST):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, key):}
        \VariableTok{self}\NormalTok{.key }\OperatorTok{=}\NormalTok{ key}
        \VariableTok{self}\NormalTok{.left }\OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.right }\OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ BinarySearchTree:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.root }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ insert(}\VariableTok{self}\NormalTok{, key):}
        \VariableTok{self}\NormalTok{.root }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(}\VariableTok{self}\NormalTok{.root, key)}

    \KeywordTok{def}\NormalTok{ \_insert\_recursive(}\VariableTok{self}\NormalTok{, root, key):}
        \CommentTok{\# If the tree is empty, return a new node}
        \ControlFlowTok{if}\NormalTok{ root }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ Node(key)}

        \CommentTok{\# Otherwise, recur down the tree}
        \ControlFlowTok{if}\NormalTok{ key }\OperatorTok{\textless{}}\NormalTok{ root.key:}
\NormalTok{            root.left }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(root.left, key)}
        \ControlFlowTok{elif}\NormalTok{ key }\OperatorTok{\textgreater{}}\NormalTok{ root.key:}
\NormalTok{            root.right }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(root.right, key)}

        \CommentTok{\# Return the unchanged node pointer}
        \ControlFlowTok{return}\NormalTok{ root}

    \KeywordTok{def}\NormalTok{ inorder\_traversal(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.\_inorder\_recursive(}\VariableTok{self}\NormalTok{.root)}

    \KeywordTok{def}\NormalTok{ \_inorder\_recursive(}\VariableTok{self}\NormalTok{, root):}
        \ControlFlowTok{if}\NormalTok{ root:}
            \VariableTok{self}\NormalTok{.\_inorder\_recursive(root.left)}
            \BuiltInTok{print}\NormalTok{(root.key, end}\OperatorTok{=}\StringTok{" "}\NormalTok{)}
            \VariableTok{self}\NormalTok{.\_inorder\_recursive(root.right)}

\CommentTok{\# Example usage}
\NormalTok{bst }\OperatorTok{=}\NormalTok{ BinarySearchTree()}
\NormalTok{keys }\OperatorTok{=}\NormalTok{ [}\DecValTok{50}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{80}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Inserting keys into BST:"}\NormalTok{, keys)}
\ControlFlowTok{for}\NormalTok{ key }\KeywordTok{in}\NormalTok{ keys:}
\NormalTok{    bst.insert(key)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Inorder traversal of the constructed BST:"}\NormalTok{)}
\NormalTok{bst.inorder\_traversal()}
\end{Highlighting}
\end{Shaded}

Explanation of the code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We define a \texttt{Node} class to represent each node in the BST.
  Each node has a key value and left and right child pointers.
\item
  The \texttt{BinarySearchTree} class is defined with methods:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_\_init\_\_}: Initializes an empty BST.
  \item
    \texttt{insert}: Public method to insert a new key into the BST.
  \item
    \texttt{\_insert\_recursive}: Private method that recursively
    inserts a new key.
  \item
    \texttt{inorder\_traversal}: Public method to perform an inorder
    traversal of the BST.
  \item
    \texttt{\_inorder\_recursive}: Private method that recursively
    performs inorder traversal.
  \end{itemize}
\item
  The insertion algorithm works as follows:

  \begin{itemize}
  \tightlist
  \item
    If the tree is empty, create a new node as the root.
  \item
    If the key is less than the current node's key, recursively insert
    into the left subtree.
  \item
    If the key is greater than the current node's key, recursively
    insert into the right subtree.
  \item
    If the key is equal to the current node's key, we ignore it (BST
    typically doesn't allow duplicates).
  \end{itemize}
\item
  The inorder traversal visits the left subtree, then the root, and
  finally the right subtree, which for a BST results in a sorted order
  of keys.
\end{enumerate}

This implementation allows for the construction of a BST by inserting
keys one by one, and provides a method to verify the correct
construction through inorder traversal.

\hypertarget{uxaaauxab0uxab6uxaa8-5uxa95-or-binary-search-tree-uxab0uxa9auxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}{%
\subsubsection{પ્રશ્ન 5(ક) OR: Binary Search Tree રચવા માટેનો પાયથન કોડ
વિકસાવો. (૦૭
ગુણ)}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-binary-search-tree-uxab0uxa9auxab5-uxaaeuxa9fuxaa8-uxaaauxaafuxaa5uxaa8-uxa95uxaa1-uxab5uxa95uxab8uxab5.-uxae6uxaed-uxa97uxaa3}}

\textbf{જવાબ 5(ક)OR:}

અહીં Binary Search Tree (BST) ની રચના માટેનો Python પ્રોગ્રામ આપેલ છે:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Node:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, key):}
        \VariableTok{self}\NormalTok{.key }\OperatorTok{=}\NormalTok{ key}
        \VariableTok{self}\NormalTok{.left }\OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.right }\OperatorTok{=} \VariableTok{None}

\KeywordTok{class}\NormalTok{ BinarySearchTree:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.root }\OperatorTok{=} \VariableTok{None}

    \KeywordTok{def}\NormalTok{ insert(}\VariableTok{self}\NormalTok{, key):}
        \VariableTok{self}\NormalTok{.root }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(}\VariableTok{self}\NormalTok{.root, key)}

    \KeywordTok{def}\NormalTok{ \_insert\_recursive(}\VariableTok{self}\NormalTok{, root, key):}
        \CommentTok{\# જો tree ખાલી હોય, તો નવો node પરત કરો}
        \ControlFlowTok{if}\NormalTok{ root }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ Node(key)}

        \CommentTok{\# અન્યથા, tree માં નીચે જાઓ}
        \ControlFlowTok{if}\NormalTok{ key }\OperatorTok{\textless{}}\NormalTok{ root.key:}
\NormalTok{            root.left }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(root.left, key)}
        \ControlFlowTok{elif}\NormalTok{ key }\OperatorTok{\textgreater{}}\NormalTok{ root.key:}
\NormalTok{            root.right }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_insert\_recursive(root.right, key)}

        \CommentTok{\# અપરિવર્તિત node pointer પરત કરો}
        \ControlFlowTok{return}\NormalTok{ root}

    \KeywordTok{def}\NormalTok{ inorder\_traversal(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.\_inorder\_recursive(}\VariableTok{self}\NormalTok{.root)}

    \KeywordTok{def}\NormalTok{ \_inorder\_recursive(}\VariableTok{self}\NormalTok{, root):}
        \ControlFlowTok{if}\NormalTok{ root:}
            \VariableTok{self}\NormalTok{.\_inorder\_recursive(root.left)}
            \BuiltInTok{print}\NormalTok{(root.key, end}\OperatorTok{=}\StringTok{" "}\NormalTok{)}
            \VariableTok{self}\NormalTok{.\_inorder\_recursive(root.right)}

\CommentTok{\# ઉદાહરણ ઉપયોગ}
\NormalTok{bst }\OperatorTok{=}\NormalTok{ BinarySearchTree()}
\NormalTok{keys }\OperatorTok{=}\NormalTok{ [}\DecValTok{50}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{80}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"BST માં keys દાખલ કરવી:"}\NormalTok{, keys)}
\ControlFlowTok{for}\NormalTok{ key }\KeywordTok{in}\NormalTok{ keys:}
\NormalTok{    bst.insert(key)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"નિર્માણ કરેલા BST નું inorder traversal:"}\NormalTok{)}
\NormalTok{bst.inorder\_traversal()}
\end{Highlighting}
\end{Shaded}

કોડનું સ્પષ્ટીકરણ:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  આપણે \texttt{Node} ક્લાસ વ્યાખ્યાયિત કરીએ છીએ જે BST માં દરેક node નું
  પ્રતિનિધિત્વ કરે છે. દરેક node માં key value અને left અને right child pointers
  હોય છે.
\item
  \texttt{BinarySearchTree} ક્લાસ નીચેની methods સાથે વ્યાખ્યાયિત કરવામાં આવે
  છે:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_\_init\_\_}: ખાલી BST ને પ્રારંભ કરે છે.
  \item
    \texttt{insert}: BST માં નવી key દાખલ કરવા માટેની public method.
  \item
    \texttt{\_insert\_recursive}: નવી key ને પુનરાવર્તી રીતે દાખલ કરતી
    private method.
  \item
    \texttt{inorder\_traversal}: BST નું inorder traversal કરવા માટેની
    public method.
  \item
    \texttt{\_inorder\_recursive}: પુનરાવર્તી રીતે inorder traversal કરતી
    private method.
  \end{itemize}
\item
  દાખલ કરવાનો અલગોરિધમ આ રીતે કામ કરે છે:

  \begin{itemize}
  \tightlist
  \item
    જો tree ખાલી હોય, તો root તરીકે નવો node બનાવો.
  \item
    જો key વર્તમાન node ની key કરતા ઓછી હોય, તો ડાબા subtree માં પુનરાવર્તી
    રીતે દાખલ કરો.
  \item
    જો key વર્તમાન node ની key કરતા વધારે હોય, તો જમણા subtree માં પુનરાવર્તી
    રીતે દાખલ કરો.
  \item
    જો key વર્તમાન node ની key ની સમાન હોય, તો આપણે તેને અવગણીએ છીએ (BST
    સામાન્ય રીતે duplicates ની મંજૂરી આપતું નથી).
  \end{itemize}
\item
  Inorder traversal પ્રથમ ડાબા subtree ની, પછી root ની, અને અંતે જમણા
  subtree ની મુલાકાત લે છે, જે BST માટે keys ના સોર્ટેડ ક્રમમાં પરિણમે છે.
\end{enumerate}

આ implementation એક પછી એક keys દાખલ કરીને BST ની રચના કરવાની મંજૂરી આપે છે,
અને inorder traversal દ્વારા યોગ્ય રચનાની ચકાસણી કરવા માટેની method પ્રદાન કરે
છે.
